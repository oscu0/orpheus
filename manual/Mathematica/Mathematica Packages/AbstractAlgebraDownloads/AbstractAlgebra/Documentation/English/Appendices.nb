(* Content-type: application/mathematica *)

(*** Wolfram Notebook File ***)
(* http://www.wolfram.com/nb *)

(* CreatedBy='Mathematica 6.0' *)

(*CacheID: 234*)
(* Internal cache information:
NotebookFileLineBreakTest
NotebookFileLineBreakTest
NotebookDataPosition[       145,          7]
NotebookDataLength[    566852,      16993]
NotebookOptionsPosition[    451170,      13477]
NotebookOutlinePosition[    517557,      15399]
CellTagsIndexPosition[    515621,      15333]
WindowFrame->Normal
ContainsDynamic->False*)

(* Beginning of Notebook Content *)
Notebook[{
Cell[TextData[{
 StyleBox["Exploring Abstract Algebra with Mathematica",
  Evaluatable->False,
  AspectRatioFixed->True,
  FontFamily->"Times",
  FontSize->24],
 StyleBox["\n",
  Evaluatable->False,
  AspectRatioFixed->True,
  FontFamily->"Times"],
 StyleBox["Al Hibbard and Ken Levasseur",
  Evaluatable->False,
  AspectRatioFixed->True,
  FontFamily->"Times",
  FontSize->14,
  FontSlant->"Plain"],
 StyleBox["\n",
  Evaluatable->False,
  AspectRatioFixed->True,
  FontFamily->"Times"],
 StyleBox["\[Copyright] Copyright 1998 Springer-Verlag New York, Inc.",
  Evaluatable->False,
  AspectRatioFixed->True,
  FontFamily->"Times",
  FontSize->10,
  FontSlant->"Plain"]
}], "Subsubtitle",
 Evaluatable->False,
 TextAlignment->Center,
 TextJustification->0,
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell["6. Appendices", "Title",
 CellMargins->{{Inherited, Inherited}, {12, 18}},
 TextAlignment->Center,
 TextJustification->0,
 FontFamily->"Times",
 FontSize->24],

Cell[CellGroupData[{

Cell["6.1 Appendix A - Installation instructions", "Section",
 FontFamily->"Times",
 FontSize->18,
 CellTags->{"i:1", "install2w"}],

Cell[CellGroupData[{

Cell["6.1.1 Version 2.x under Windows", "Subsection",
 FontFamily->"Times",
 CellTags->"install2w"],

Cell[TextData[{
 "From the web site (",
 ButtonBox["http://www.central.edu/eaam.html",
  BaseStyle->"Hyperlink",
  ButtonData:>{
    URL["http://www.central.edu/eaam.html"], None}],
 ") or from the CD, find the files appropriate for version 2.x under Windows. \
Place the entire ",
 StyleBox["AbstractAlgebra", "MR"],
 " directory (called ",
 StyleBox["Abstract", "MR"],
 " to limit the name to 8 characters) into the ",
 StyleBox["Packages", "SR"],
 " directory (in the ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " directory). The GrpLabs and RngLabs directories can be placed wherever \
convenient."
}], "Text",
 CellTags->"install2w"],

Cell[TextData[{
 "As users of version 2.x under Windows are well aware, each cell contains \
only one possible style. Therefore, some of the emphases (italics, bold or \
otherwise) may be lost that are provided in other versions. Additonally, to \
discriminate input cells from text cells, all input cells have been colored \
yellow. (This can be changed by the user, if so inclined.) As you may be \
aware, there are a large number of advantages in upgrading to version 3.x, \
including a number of palettes available that complement ",
 StyleBox["Exploring Abstract Algebra with",
  FontSlant->"Italic"],
 " ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 "."
}], "Text",
 CellTags->"install2w"]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.1.2 Version 2.x under other platforms", "Subsection",
 FontFamily->"Times",
 CellTags->"install2o"],

Cell[TextData[{
 "From the web site (",
 ButtonBox["http://www.central.edu/eaam.html",
  BaseStyle->"Hyperlink",
  ButtonData:>{
    URL["http://www.central.edu/eaam.html"], None}],
 ") or from the CD, find the files appropriate for version 2.x under \
Macintosh or Unix. Place the entire ",
 StyleBox["AbstractAlgebra", "MR"],
 " directory into the ",
 StyleBox["Packages", "SR"],
 " directory (in the ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " directory). The GrpLabs and RngLabs directories can be placed wherever \
convenient."
}], "Text",
 CellTags->"install2o"],

Cell[TextData[{
 "As you may be aware, there are a large number of advantages in upgrading to \
version 3.x, including a number of palettes available that complement ",
 StyleBox["Exploring Abstract Algebra with",
  FontSlant->"Italic"],
 " ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 "."
}], "Text",
 CellTags->"install2o"]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.1.3 Version 3.0 or higher", "Subsection",
 FontFamily->"Times",
 CellTags->"install3"],

Cell[TextData[{
 "From the web site (",
 ButtonBox["http://www.central.edu/eaam.html",
  BaseStyle->"Hyperlink",
  ButtonData:>{
    URL["http://www.central.edu/eaam.html"], None}],
 "\[LongDash]you may wish to check here for updates to the files) or from the \
CD, find the files appropriate for version 3.0, 4.0, or higher. (Note that \
these files should work equally well on Macintosh, Unix, or Windows \
platforms. Note also that the first run of CDs presented a problem for \
Macintosh users. A solution can be found at ",
 ButtonBox["http://www.central.edu/homepages/hibbarda/EAAM/MacCDFix.html",
  BaseStyle->"Hyperlink",
  ButtonData:>{
    URL["http://www.central.edu/homepages/hibbarda/EAAM/MacCDFix.html"], 
    None}],
 ".) "
}], "Text",
 CellTags->"install3"],

Cell[TextData[{
 "Note that you may wish to install the files by downloading more current \
copies from the web. For further details, see ",
 ButtonBox["section 6.1.4",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Install-from WWW page", "Install-from WWW page"}],
 "."
}], "Text",
 CellTags->"install3"],

Cell[TextData[{
 "The files are located on the CD in such a way to imitate the layout of the \
main ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " directory. Here is a schematic of what is on the CD and on the web page \
(except the CD uses initial lower-case directory names that correspond to ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " directories to avoid an accidental overwrite of files). Note that the \
AddOns and Configuration directories are inside the main ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " 3.0 Files directory. "
}], "Text",
 CellTags->"install3"],

Cell["\<\

AddOns 
    Applications 
        AbstractAlgebra 
            package files (.m files) 
            Documentation 
                English 
                    documentation files 
            GroupLabs 
                group lab notebooks from EAAM 
            Kernel 
                init.m (Master.m copied here and renamed to init.m) 
            Palettes 
                palette files from EAAM 
                palette files for general distribution 
            RingLabs  
                ring lab notebooks from EAAM 
Configuration 
    FrontEnd 
        StyleSheets 
            EAAM.nb (needed if labs are moved from AbstractAlgebra)
        Palettes 
            AbstractAlgebraPalette.nb (can also be found via the Help \
Browser)\
\>", "Text",
 CellMargins->{{Inherited, Inherited}, {0, 0}},
 LineSpacing->{1, -6},
 CellTags->"install3"],

Cell[TextData[{
 "Place the entire ",
 StyleBox["AbstractAlgebra", "MR"],
 " directory into the Applications directory (in the AddOns directory in the \
",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " directory). From the above schematic, observe that this places the package \
files, labs, and Browser documentation in an accessible location for ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ". In particular, the group and ring labs are in the obvious directories. If \
it is more convenient, the lab directories can be moved to another location. \
(The only loss in doing so is that links related to these labs in the Help \
Browser will become broken. If the labs are not moved, they are easily \
accessible from the EAAM Info section of the accompanying help files.) After \
placing these files in the Applications directory, open ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " and choose Rebuild Help Index from the Help menu; this will enable the \
Help Browser to be aware of the documentation files accompanying ",
 StyleBox["AbstractAlgebra", "MR"],
 ". (Choose the Add-ons button in the Help Browser and ",
 StyleBox["AbstractAlgebra", "MR"],
 " will show up in the left-most column.)"
}], "Text",
 CellTags->"install3"],

Cell[TextData[{
 "In addition to copying the ",
 StyleBox["AbstractAlgebra", "MR"],
 " directory into the Applications directory, copy the EAAM.nb style sheet \
into the StyleSheets directory (in the FrontEnd directory in the \
Configuration directory in the ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " directory). Similarly, the AbstractAlgebraPalette.nb palette should be \
copied into the Palettes directory (in the FrontEnd directory in the \
Configuration directory). From this palette, all the other palettes in the \
Palettes directory in the ",
 StyleBox["AbstractAlgebra", "MR"],
 " directory will be accessible. For those who have downloaded the ",
 StyleBox["AbstractAlgebra", "MR"],
 " packages, but have not adopted the ",
 StyleBox["Exploring Abstract Algebra with",
  FontSlant->"Italic"],
 " ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " text, there is a palette at our web site (",
 ButtonBox["http://www.central.edu/eaam.html",
  BaseStyle->"Hyperlink",
  ButtonData:>{
    URL["http://www.central.edu/eaam.html"], None}],
 ") that is publicly available. For more information on the available \
palettes, consult the ",
 ButtonBox["palette chapter",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Palette introduction", "Palette introduction"}],
 " of the EAAM Info section of this documention"
}], "Text",
 CellTags->"install3"]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.1.4 Installation from WWW page", "Subsection",
 CellTags->"installFromWeb"],

Cell[TextData[{
 "You may find it advantageous to download an updated version of the ",
 StyleBox["AbstractAlgebra",
  FontFamily->"Courier"],
 " packages (and accompanying files). These can be found from our EAAM home \
page (",
 ButtonBox["http://www.central.edu/eaam.html",
  BaseStyle->"Hyperlink",
  ButtonData:>{
    URL["http://www.central.edu/eaam.html"], None}],
 ") or directly from the download page (",
 ButtonBox["http://www.central.edu/homepages/hibbarda/EAAM/DownloadAA.html",
  BaseStyle->"Hyperlink",
  ButtonData:>{
    URL["http://www.central.edu/homepages/hibbarda/EAAM/DownloadAA.html"], 
    None}],
 "). Users of ",
 StyleBox["Exploring Abstract Algebra with Mathematica",
  FontSlant->"Italic"],
 " will need to contact one of us (",
 ButtonBox["hibbarda@central.edu",
  BaseStyle->"Hyperlink",
  ButtonData:>{
    URL["mailto://hibbarda@central.edu"], None}],
 " or ",
 ButtonBox["Kenneth_Levasseur@uml.edu",
  BaseStyle->"Hyperlink",
  ButtonData:>{
    URL["mailto://Kenneth_Levasseur@uml.edu"], None}],
 ") to obtain new versions of the labs, ",
 StyleBox["if ",
  FontSlant->"Italic"],
 "you want to utilize the new means of accessing them in the Browser, found \
",
 ButtonBox["here",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Labs-READ ME first", "Labs-READ ME first"}],
 ". (There are no substantial changes in the labs relative to what is found \
on the CD, only some tagging to make them more accessible from the Browser.)\n\
Installation is now easier. Simply download either a compressed single file, \
decompress it, and place it in the AddOns/Application directory. After this, \
you will need to Rebuild the Help Index. Alternatively, download fragments of \
the packages, gather them together in a directory called AbstractAlgebra and \
place as above.\nThe basic contents of the ",
 StyleBox["AbstractAlgebra",
  FontFamily->"Courier"],
 " directory should look like this. (Note that this is slighlty different \
from above. It is simpler but equivalent.)"
}], "Text",
 CellTags->"installFromWeb"],

Cell[TextData[{
 "\nAbstractAlgebra\n\tpackage files (.m files), distributed alphabetically\n\
\tDocumentation\n\t\tEnglish\n\t\t\tdocumentation files\n\tFrontEnd\n\t\t\
StyleSheets\n\t\t\tEAAM.nb\n\t\tPalettes\n\t\t\tAbstractAlgebraPalette.nb\n\t\
GroupLabQuestions\n\t\tquestions for group labs (or truncated files for \
others)\n\tGroupLabs\n\t\tlab notebooks from EAAM (or truncated files for \
others)\n\tKernel\n\t\tinit.m (copy of Master.m, but renamed)\n\tLab0\n\t\t\
notebook to introduce ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " and EAAM\n\tPalettes\n\t\tpalette files from EAAM\n\t\tpalette files for \
general distribution\n\tRingLabQuestions\n\t\tquestions for ring labs (or \
truncated files for others)\n\tRingLabs\n\t\tlab notebooks from EAAM (or \
truncated files for others)\n\t\n\t"
}], "Text",
 LineSpacing->{1, -6},
 TabSpacings->2,
 CellTags->"installFromWeb"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.2 Appendix A - References", "Section",
 FontFamily->"Times",
 FontSize->18,
 CellTags->{"i:3", "MathematicaRefs"}],

Cell[TextData[{
 "Anick, David, \[OpenCurlyDoubleQuote]A Model of Adams-Hilton Type for Fiber \
Squares,\[CloseCurlyDoubleQuote] ",
 StyleBox["Illinois J. Math",
  FontSlant->"Italic"],
 ", 29 (3), 1985, pp. 463-502."
}], "Text",
 CellMargins->{{Inherited, Inherited}, {3, 2}},
 CellTags->"MathematicaRefs"],

Cell[TextData[{
 "Dornhoff, L. and",
 StyleBox[" ",
  FontSlant->"Italic"],
 "F. Hohn, ",
 StyleBox["Applied Modern Algebra",
  FontSlant->"Italic"],
 ", Macmillan, New York, 1978."
}], "Text",
 CellMargins->{{Inherited, Inherited}, {3, 2}},
 CellTags->"MathematicaRefs"],

Cell[TextData[{
 "Fraleigh, J., ",
 StyleBox["A First Course in Abstract Algebra",
  FontSlant->"Italic"],
 ", Fifth Edition, Addison-Wesley, Reading, MA, 1994."
}], "Text",
 CellMargins->{{Inherited, Inherited}, {3, 2}},
 CellTags->"MathematicaRefs"],

Cell[TextData[{
 "Gray, T. and J. Glynn, ",
 StyleBox["Exploring Mathematics with Mathematica,",
  FontSlant->"Italic"],
 " Addison-Wesley, Reading, MA, 1991."
}], "Text",
 CellMargins->{{Inherited, Inherited}, {3, 2}},
 CellTags->"MathematicaRefs"],

Cell[TextData[{
 "Herstein, I., ",
 StyleBox["Topics in Algebra",
  FontSlant->"Italic"],
 ", Second Edition, Wiley, New York, 1975."
}], "Text",
 CellMargins->{{Inherited, Inherited}, {3, 2}},
 CellTags->"MathematicaRefs"],

Cell[TextData[{
 "Herstein, I., ",
 StyleBox["Abstract Algebra",
  FontSlant->"Italic"],
 ", Third Edition, Prentice-Hall, Upper Saddle River, NJ, 1990."
}], "Text",
 CellMargins->{{Inherited, Inherited}, {3, 2}},
 CellTags->"MathematicaRefs"],

Cell[TextData[{
 "Hungerford, T., ",
 StyleBox["Abstract Algebra: An Introduction,",
  FontSlant->"Italic"],
 " Second Edition, Saunders, New York, 1997."
}], "Text",
 CellMargins->{{Inherited, Inherited}, {3, 2}},
 CellTags->"MathematicaRefs"],

Cell[TextData[{
 "Levasseur, K., \[OpenCurlyDoubleQuote]A Microworld for Elementary Group \
Theory,\[CloseCurlyDoubleQuote] ",
 StyleBox["Mathematica in Education",
  FontSlant->"Italic"],
 ", 3 (Fall, 1994), pp. 5-10."
}], "Text",
 CellMargins->{{Inherited, Inherited}, {3, 2}},
 CellTags->"MathematicaRefs"],

Cell[TextData[{
 "Lindl, R. and G. Pilz, ",
 StyleBox["Applied Abstract Algebra,",
  FontSlant->"Italic"],
 " Springer-Verlag, New York, 1984."
}], "Text",
 CellMargins->{{Inherited, Inherited}, {3, 2}},
 CellTags->"MathematicaRefs"],

Cell[TextData[{
 "Lipson, J., ",
 StyleBox["Elements of Algebra & Algebraic Computing,",
  FontSlant->"Italic"],
 " Addison-Wesley, Reading, MA, 1981."
}], "Text",
 CellMargins->{{Inherited, Inherited}, {3, 2}},
 CellTags->"MathematicaRefs"],

Cell[TextData[{
 "Pinter, C., ",
 StyleBox["A Book of Abstract Algebra,",
  FontSlant->"Italic"],
 " McGraw Hill, New York, 1990."
}], "Text",
 CellMargins->{{Inherited, Inherited}, {3, 2}},
 CellTags->"MathematicaRefs"],

Cell[TextData[{
 "Rotman, J., ",
 StyleBox["The Theory of Groups,",
  FontSlant->"Italic"],
 " Allyn & Bacon, Boston, 1965."
}], "Text",
 CellMargins->{{Inherited, Inherited}, {3, 2}},
 CellTags->"MathematicaRefs"],

Cell[TextData[{
 "Rotman, J., ",
 StyleBox["A First Course in Abstract Algebra,",
  FontSlant->"Italic"],
 " Prentice-Hall, Upper Saddle River, NJ, 1996."
}], "Text",
 CellMargins->{{Inherited, Inherited}, {3, 2}},
 CellTags->"MathematicaRefs"],

Cell[TextData[{
 "Sims, C., ",
 StyleBox["Abstract Algebra: a Computational Approach,",
  FontSlant->"Italic"],
 " Wiley, New York, 1984."
}], "Text",
 CellMargins->{{Inherited, Inherited}, {3, 2}},
 CellTags->"MathematicaRefs"],

Cell[TextData[{
 "Wolfram, S., ",
 StyleBox["Mathematica, A System for Doing Mathematics by Computer",
  FontSlant->"Italic"],
 ",",
 " ",
 "Second Edition, Addison-Wesley, Redwood City, CA, 1991."
}], "Text",
 CellMargins->{{Inherited, Inherited}, {3, 2}},
 CellTags->"MathematicaRefs"],

Cell[TextData[{
 "Wolfram, S., ",
 StyleBox["The Mathematica Book",
  FontSlant->"Italic"],
 ",",
 " ",
 "Third Edition, Wolfram Media, Champaign, IL, 1997."
}], "Text",
 CellMargins->{{Inherited, Inherited}, {3, 2}},
 CellTags->"MathematicaRefs"],

Cell[TextData[{
 "Wolfram Research,",
 " ",
 StyleBox["Mathematica 3.0 Standard Add-on Packages",
  FontSlant->"Italic"],
 ", Wolfram Media, Champaign, IL, 1996."
}], "Text",
 CellMargins->{{Inherited, Inherited}, {3, 2}},
 CellTags->"MathematicaRefs"]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3 Appendix A - Objects in AbstractAlgebra", "Section",
 FontFamily->"Times",
 FontSize->18],

Cell[CellGroupData[{

Cell["6.3.1 Objects listed alphabetically", "Subsection",
 FontFamily->"Times",
 CellTags->{"alpha", "i:4"}],

Cell[TextData[{
 "AbelianQ",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:5"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Addition",
 ", ",
 "as an operation on polynomials",
 ", ",
 ButtonBox["Polynomial arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Polynomial arithmetic", "i:28"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Addition",
 ", ",
 "as applied to functions over a Ringoid",
 ", ",
 ButtonBox["Function Arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Function Arithmetic", "i:77"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Addition",
 ", ",
 "as applied to matrices",
 ", ",
 ButtonBox["Matrix arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix arithmetic", "i:59"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Addition",
 ", ",
 "as applied to Ringoid extensions",
 ", ",
 ButtonBox["Extension ringoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Extension ringoids", "i:19"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Addition",
 ", ",
 "in a Ringoid",
 ", ",
 ButtonBox["Basic functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Basic functions", "i:7"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Addition",
 ", ",
 "value for the Operation option",
 ", ",
 ButtonBox["Additive properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Additive properties", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "AdditiveGroupoid",
 ", ",
 ButtonBox["Groupoids from ringoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groupoids from ringoids", "i:13"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "AdditiveToMultiplicative",
 ", ",
 ButtonBox["Finite fields",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Finite fields", "i:88"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Adjoin",
 ", ",
 "as applied to algebraic integers",
 ", ",
 ButtonBox["Adjoin",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Adjoin", "i:34"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "AGroupoid",
 ", ",
 ButtonBox["Groupoids from ringoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groupoids from ringoids", "i:13"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "All",
 ", ",
 "as a value of the MatrixType option",
 ", ",
 ButtonBox["Individual matrices",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Individual matrices", "i:55"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Alternating Group",
 ", ",
 ButtonBox["Groups of permutations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groups of permutations", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "AlternatingGroup",
 ", ",
 "the family of Groupoids",
 ", ",
 ButtonBox["Groups of permutations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groups of permutations", "i:19"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Alternating",
 ", ",
 "the family of Groupoids",
 ", ",
 ButtonBox["Groups of permutations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groups of permutations", "i:19"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Annihilator",
 ", ",
 ButtonBox["Subrings and ideals",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subrings and ideals", "i:11"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Annihilator of a Set",
 ", ",
 ButtonBox["Subrings and ideals",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subrings and ideals", "i:10"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Any",
 ", ",
 "value for the SelectFrom option for RandomElement(s)",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:2"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "@",
 ", ",
 "as a short form of MultiplyCycles",
 ", ",
 ButtonBox["Cycle operations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cycle operations", "i:14"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "AsIJK",
 ", ",
 "value for Form option for QuaternionGroup",
 ", ",
 ButtonBox["Other groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other groupoids", "i:25"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "AsMatrices",
 ", ",
 "value for Form option for QuaternionGroup",
 ", ",
 ButtonBox["Other groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other groupoids", "i:25"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Associates",
 ", ",
 "value for Combine option for divisor functions",
 ", ",
 ButtonBox["Divisibility",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Divisibility", "i:26"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "AssociativeQ",
 ", ",
 "applied to Groupoids",
 ", ",
 ButtonBox["The four standard functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"The four standard functions", "i:14"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "AssociativeQ",
 ", ",
 "as applied to addition in a Ringoid",
 ", ",
 ButtonBox["Additive properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Additive properties", "i:16"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "AssociativeQ",
 ", ",
 "as applied to multiplication in a Ringoid",
 ", ",
 ButtonBox["Multiplicative properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Multiplicative properties", "i:20"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "AssociativeQ",
 ", ",
 "complexity",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:21"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "AssociativeQ",
 ", ",
 "variations",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:21"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "AsSymbols",
 ", ",
 "value for Form option for QuaternionGroup",
 ", ",
 ButtonBox["Other groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other groupoids", "i:25"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "A",
 ", ",
 "the family of Groupoids",
 ", ",
 ButtonBox["Groups of permutations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groups of permutations", "i:19"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Aut",
 ", ",
 ButtonBox["Automorphisms",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Automorphisms", "i:23"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Automorphism",
 ", ",
 ButtonBox["Automorphisms",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Automorphisms", "i:23"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "AutomorphismGroup",
 ", ",
 ButtonBox["Automorphisms",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Automorphisms", "i:23"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Automorphisms",
 ", ",
 ButtonBox["Automorphisms",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Automorphisms", "i:22"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "BackgroundColors",
 ", ",
 ButtonBox["Global variables and options",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Global variables and options", "i:2"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "BaseRing",
 ", ",
 "as applied to a polynomial",
 ", ",
 ButtonBox["Miscellaneous functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Miscellaneous functions", "i:46"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "BaseRing",
 ", ",
 "as applied to Ringoid extensions",
 ", ",
 ButtonBox["Extension ringoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Extension ringoids", "i:19"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "BooleanRing",
 ", ",
 "the family of Ringoids",
 ", ",
 ButtonBox["Other Rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other Rings", "i:33"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Both",
 ", ",
 "value for the Operation option",
 ", ",
 ButtonBox["Additive properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Additive properties", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Building Groupoids from Groupoids",
 ", ",
 ButtonBox["StructureIntroduction",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"StructureIntroduction", "i:1"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Canonical",
 ", ",
 "value for the Representatives option of QuotientGroup",
 ", ",
 ButtonBox["Quotient groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient groups", "i:27"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CartesianProduct",
 ", ",
 ButtonBox["Working with lists",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Working with lists", "i:31"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Cautious",
 ", ",
 "option for IsomorphismQ",
 ", ",
 ButtonBox["Preserving Operations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Preserving Operations", "i:19"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CayleyForm",
 ", ",
 "as an option to CayleyTable",
 ", ",
 ButtonBox["Cayley tables",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cayley tables", "i:28"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CayleyForm",
 ", ",
 "as an option to FormGroupoid",
 ", ",
 ButtonBox["FormGroupoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormGroupoid", "i:3"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CayleyForm",
 ", ",
 "as an option to FormRingoid",
 ", ",
 ButtonBox["FormRingoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormRingoid", "i:4"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CayleyForm",
 ", ",
 "illustration",
 ", ",
 ButtonBox["FormRingoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormRingoid", "i:34"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CayleyTable",
 ", ",
 ButtonBox["Cayley tables",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cayley tables", "i:27"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CayleyTable",
 ", ",
 "as applied to Ringoids",
 ", ",
 ButtonBox["Using Cayley tables ",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Using Cayley tables ", "i:1"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CayleyTables",
 ", ",
 "of a Ringoid",
 ", ",
 ButtonBox["Using Cayley tables ",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Using Cayley tables ", "i:1"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CayleyTable",
 ", ",
 "with Graphics options",
 ", ",
 ButtonBox["Cayley tables",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cayley tables", "i:30"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CayleyTable",
 ", ",
 "with \"wide elements\"",
 ", ",
 ButtonBox["Cayley tables",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cayley tables", "i:29"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Center",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:7"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Centralizer",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:7"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Characteristic",
 ", ",
 "of a Ringoid",
 ", ",
 ButtonBox["Testing other properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Testing other properties", "i:29"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ClosedDiffQ",
 ", ",
 ButtonBox["Closure of subsets",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Closure of subsets", "i:28"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ClosedPlusQ",
 ", ",
 ButtonBox["Closure of subsets",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Closure of subsets", "i:28"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ClosedQ",
 ", ",
 "applied to a subset of a Groupoid",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:16"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ClosedQ",
 ", ",
 "applied to Groupoids",
 ", ",
 ButtonBox["The four standard functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"The four standard functions", "i:14"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ClosedQ",
 ", ",
 "as applied to multiplication in a Ringoid",
 ", ",
 ButtonBox["Multiplicative properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Multiplicative properties", "i:20"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ClosedQ",
 ", ",
 "as applied to Ringoids",
 ", ",
 ButtonBox["Closure of subsets",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Closure of subsets", "i:28"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ClosedQ",
 ", ",
 "as applied to test additive closure in a Ringoid",
 ", ",
 ButtonBox["Additive properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Additive properties", "i:16"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ClosedTimesQ",
 ", ",
 ButtonBox["Closure of subsets",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Closure of subsets", "i:28"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CloseSets",
 ", ",
 ButtonBox["Working with lists",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Working with lists", "i:31"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Closure",
 ", ",
 ButtonBox["Subgroups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subgroups", "i:9"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Codomain",
 ", ",
 "of a Morphoid",
 ", ",
 ButtonBox["The structure of Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"The structure of Morphoids", "i:6"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Coefficient",
 ", ",
 "EAAM usage for polynomials",
 ", ",
 ButtonBox["Extensions of Stnrd Mathematica",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Extensions of Stnrd Mathematica", "i:45"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CoefficientList",
 ", ",
 "EAAM usage for polynomials",
 ", ",
 ButtonBox["Extensions of Stnrd Mathematica",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Extensions of Stnrd Mathematica", "i:45"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CollectOrders",
 ", ",
 ButtonBox["A look at some functions in LabCode",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"A look at some functions in LabCode", "i:38"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ColorCodomain",
 ", ",
 "as an option to VisualizeMorphoid",
 ", ",
 ButtonBox["Visualizing Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Visualizing Morphoids", "i:25"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ColorDomain",
 ", ",
 "as an option to VisualizeMorphoid",
 ", ",
 ButtonBox["Visualizing Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Visualizing Morphoids", "i:25"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Combine",
 ", ",
 "as an option with algebraic integers",
 ", ",
 ButtonBox["Divisibility",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Divisibility", "i:26"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CommutativeQ",
 ", ",
 "as applied to addition in a Ringoid",
 ", ",
 ButtonBox["Additive properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Additive properties", "i:16"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CommutativeQ",
 ", ",
 "as applied to Groupoids",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:5"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CommutativeQ",
 ", ",
 "as applied to multiplication on a Ringoid",
 ", ",
 ButtonBox["Multiplicative properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Multiplicative properties", "i:21"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Commutator",
 ", ",
 "in a Groupoid",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:5"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Commutators",
 ", ",
 "of a Groupoid",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:5"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CommutatorSubgroup",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:5"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ComplementNoSort",
 ", ",
 ButtonBox["Working with lists",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Working with lists", "i:31"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ComplexToPoint",
 ", ",
 ButtonBox["Potpourri",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Potpourri", "i:39"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Computational",
 ", ",
 "value for Mode option",
 ", ",
 ButtonBox["How to use a Mode",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"How to use a Mode", "i:14"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ConjugacyClass",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:9"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Conjugacy Class",
 ", ",
 "concept",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:8"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Conjugate",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:9"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CosetLists",
 ", ",
 "value for the Form option of QuotientGroup",
 ", ",
 ButtonBox["Quotient groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient groups", "i:27"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Cosets",
 ", ",
 "value for the Form option of QuotientGroup",
 ", ",
 ButtonBox["Quotient groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient groups", "i:27"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CosetToList",
 ", ",
 "applied to elements of a quotient group",
 ", ",
 ButtonBox["Quotient groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient groups", "i:28"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CosetToList",
 ", ",
 "as applied to Ringoids",
 ", ",
 ButtonBox["Quotient Rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient Rings", "i:15"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CycleAs",
 ", ",
 "as an option to ToCycles",
 ", ",
 ButtonBox["Cycles",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cycles", "i:12"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Cycles",
 ", ",
 ButtonBox["Cycles",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cycles", "i:10"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Cycle",
 ", ",
 "value for CycleAs option for ToCycles",
 ", ",
 ButtonBox["Cycles",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cycles", "i:12"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CyclicGenerators",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:10"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CyclicGroup",
 ", ",
 "the family of Groupoids",
 ", ",
 ButtonBox["Dihedral and Cyclic groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Dihedral and Cyclic groups", "i:24"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CyclicQ",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:10"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "CyclicSubgroups",
 ", ",
 ButtonBox["Subgroups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subgroups", "i:15"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Cyclic",
 ", ",
 "the family of Groupoids",
 ", ",
 ButtonBox["Dihedral and Cyclic groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Dihedral and Cyclic groups", "i:24"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "D",
 ", ",
 "EAAM usage",
 ", ",
 ButtonBox["Dihedral and Cyclic groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Dihedral and Cyclic groups", "i:21"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "DefaultOrder",
 ", ",
 ButtonBox["Global variables and options",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Global variables and options", "i:2"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "DefaultStructure",
 ", ",
 ButtonBox["Global variables and options",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Global variables and options", "i:2"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "DefaultStructure",
 ", ",
 "how to change",
 ", ",
 ButtonBox["Changing the DefaultStructure",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Changing the DefaultStructure", "i:13"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Degree",
 ", ",
 "EAAM usage for polynomials",
 ", ",
 ButtonBox["Extensions of Stnrd Mathematica",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Extensions of Stnrd Mathematica", "i:45"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Det",
 ", ",
 "EAAM usage",
 ", ",
 ButtonBox["Determinants & inverses",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Determinants & inverses", "i:62"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Diag",
 ", ",
 "as a matrix sub-extension",
 ", ",
 ButtonBox["Matrix groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix groupoids", "i:70"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Diag",
 ", ",
 "as a value of the MatrixType option",
 ", ",
 ButtonBox["Individual matrices",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Individual matrices", "i:55"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "DiagonalMatrices",
 ", ",
 ButtonBox["Matrix groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix groupoids", "i:71"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "DiagQ",
 ", ",
 ButtonBox["Individual matrices",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Individual matrices", "i:57"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "DihedralGroup",
 ", ",
 "the family of Groupoids",
 ", ",
 ButtonBox["Dihedral and Cyclic groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Dihedral and Cyclic groups", "i:21"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Dihedral",
 ", ",
 "the family of Groupoids",
 ", ",
 ButtonBox["Dihedral and Cyclic groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Dihedral and Cyclic groups", "i:21"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "DirectProduct",
 ", ",
 "applied to Groupoids",
 ", ",
 ButtonBox["Direct products",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Direct products", "i:3"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "DirectProduct",
 ", ",
 "as applied to Ringoids",
 ", ",
 ButtonBox["Direct products of rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Direct products of rings", "i:6"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "DirectSum",
 ", ",
 "applied to Groupoids",
 ", ",
 ButtonBox["Direct products",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Direct products", "i:3"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "DirectSum",
 ", ",
 "as applied to Ringoids",
 ", ",
 ButtonBox["Direct products of rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Direct products of rings", "i:6"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "DisguiseGroupoid",
 ", ",
 ButtonBox["Disguising groups and rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Disguising groups and rings", "i:36"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "DisguiseRingoid",
 ", ",
 ButtonBox["Disguising groups and rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Disguising groups and rings", "i:36"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "DisjointCyclesQ",
 ", ",
 ButtonBox["Other cycle-related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other cycle-related functions", "i:15"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "DistributiveQ",
 ", ",
 "as applied to Ringoids",
 ", ",
 ButtonBox["Distributive property",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Distributive property", "i:24"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "DividesQ",
 ", ",
 "as applied to Z[Sqrt[d]]",
 ", ",
 ButtonBox["Divisibility",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Divisibility", "i:25"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "DividesQ",
 ", ",
 "on integers",
 ", ",
 ButtonBox["Divisibility",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Divisibility", "i:24"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Divisibility",
 ", ",
 "Groupoids based on",
 ", ",
 ButtonBox["Other numeric groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other numeric groupoids", "i:10"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "DivisorsComplete",
 ", ",
 "as an option with algebraic integers",
 ", ",
 ButtonBox["Divisibility",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Divisibility", "i:26"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Dot",
 ", ",
 "EAAM usage",
 ", ",
 ButtonBox["Determinants & inverses",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Determinants & inverses", "i:65"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "DrawNgon",
 ", ",
 ButtonBox["Working with graphics",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Working with graphics", "i:33"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "EisensteinsCriterionQ",
 ", ",
 ButtonBox["Irreducibility of Polynomials",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Irreducibility of Polynomials", "i:41"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ElementConjugate",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:9"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ElementQ",
 ", ",
 "applied to Groupoids",
 ", ",
 ButtonBox["Structure of Groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Structure of Groupoids", "i:12"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ElementQ",
 ", ",
 "as applied to functions over a Ringoid",
 ", ",
 ButtonBox["Function Extensions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Function Extensions", "i:74"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ElementQ",
 ", ",
 "as applied to matrices",
 ", ",
 ButtonBox["Individual matrices",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Individual matrices", "i:53"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ElementQ",
 ", ",
 "as applied to Ringoid extensions",
 ", ",
 ButtonBox["Extension ringoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Extension ringoids", "i:19"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ElementQ",
 ", ",
 "as applied to Ringoids",
 ", ",
 ButtonBox["Ring related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Ring related functions", "i:8"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Elements",
 ", ",
 "applied to Groupoids",
 ", ",
 ButtonBox["Structure of Groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Structure of Groupoids", "i:11"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Elements",
 ", ",
 "as applied to Ringoids",
 ", ",
 ButtonBox["Basic functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Basic functions", "i:7"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ElementsQ",
 ", ",
 "applied to Groupoids",
 ", ",
 ButtonBox["Structure of Groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Structure of Groupoids", "i:12"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ElementsQ",
 ", ",
 "as applied to Ringoids",
 ", ",
 ButtonBox["Ring related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Ring related functions", "i:8"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ElementToCoset",
 ", ",
 "as applied to elements in a quotient group",
 ", ",
 ButtonBox["Quotient groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient groups", "i:28"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ElementToKey",
 ", ",
 ButtonBox["Visual mode with large elements",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Visual mode with large elements", "i:16"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ElementToPower",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:11"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ElementToPower",
 ", ",
 "as applied to Ringoids",
 ", ",
 ButtonBox["Testing other properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Testing other properties", "i:29"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Equal",
 ", ",
 "EAAM usage for polynomials",
 ", ",
 ButtonBox["Extensions of Stnrd Mathematica",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Extensions of Stnrd Mathematica", "i:45"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "EqualMorphiodQ",
 ", ",
 ButtonBox["The structure of Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"The structure of Morphoids", "i:8"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "EqualMorphoidQ",
 ", ",
 "illustration",
 ", ",
 ButtonBox["Forming Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Forming Morphoids", "i:27"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ESG",
 ", ",
 ButtonBox["Potpourri",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Potpourri", "i:39"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "EvaluationInExtension",
 ", ",
 ButtonBox["Polynomial Quotient Rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Polynomial Quotient Rings", "i:37"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "EvenPermutationQ",
 ", ",
 ButtonBox["Other cycle-related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other cycle-related functions", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Exponent",
 ", ",
 "EAAM usage for polynomials",
 ", ",
 ButtonBox["Extensions of Stnrd Mathematica",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Extensions of Stnrd Mathematica", "i:45"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ExtendPermutation",
 ", ",
 ButtonBox["Permutation operations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Permutation operations", "i:7"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ExtendPermutation",
 ", ",
 "illustration",
 ", ",
 ButtonBox["Permutation operations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Permutation operations", "i:41"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ExtensionDegree",
 ", ",
 ButtonBox["Finite fields",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Finite fields", "i:86"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ExtensionType",
 ", ",
 "as applied to Ringoid extensions",
 ", ",
 ButtonBox["Extension ringoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Extension ringoids", "i:19"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FactorGroup",
 ", ",
 ButtonBox["Quotient groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient groups", "i:26"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FactorRing",
 ", ",
 ButtonBox["Quotient Rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient Rings", "i:15"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Fiber",
 ", ",
 ButtonBox["Kernel, Image, and InverseImage(s)",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Kernel, Image, and InverseImage(s)", "i:21"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FieldIrreducible",
 ", ",
 ButtonBox["Finite fields",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Finite fields", "i:86"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FieldQ",
 ", ",
 ButtonBox["Specialized rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Specialized rings", "i:26"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FirstTaker",
 ", ",
 "the family of Groupids",
 ", ",
 ButtonBox["Other numeric groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other numeric groupoids", "i:9"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FixQ",
 ", ",
 ButtonBox["Stabilizers and orbits",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Stabilizers and orbits", "i:19"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Form",
 ", ",
 "as an option to Dihedral",
 ", ",
 ButtonBox["Dihedral and Cyclic groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Dihedral and Cyclic groups", "i:22"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Form",
 ", ",
 "as an option to QuotientGroup",
 ", ",
 ButtonBox["Quotient groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient groups", "i:27"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Form",
 ", ",
 "as an option to QuotientRing",
 ", ",
 ButtonBox["Quotient Rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient Rings", "i:16"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FormatElements",
 ", ",
 "as an option to FormGroupoid",
 ", ",
 ButtonBox["FormGroupoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormGroupoid", "i:3"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FormatElements",
 ", ",
 "as an option to FormRingoid",
 ", ",
 ButtonBox["FormRingoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormRingoid", "i:4"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FormatFunction",
 ", ",
 "illustration",
 ", ",
 ButtonBox["Automorphisms",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Automorphisms", "i:34"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FormatFunction",
 ", ",
 "option for FormMorphoid",
 ", ",
 ButtonBox["Forming Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Forming Morphoids", "i:3"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FormatOperator",
 ", ",
 "as an option to FormGroupoid",
 ", ",
 ButtonBox["FormGroupoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormGroupoid", "i:3"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FormatOperator",
 ", ",
 "as an option to FormRingoid",
 ", ",
 ButtonBox["FormRingoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormRingoid", "i:4"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FormGroupoid",
 ", ",
 ButtonBox["FormGroupoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormGroupoid", "i:2"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FormGroupoidByTable",
 ", ",
 ButtonBox["FormGroupoidByTable",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormGroupoidByTable", "i:6"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FormGroupoidFromCycles",
 ", ",
 ButtonBox["FormGroupoidFromCycles and RandomGroupoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormGroupoidFromCycles and RandomGroupoid", "i:7"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FormMorphoid",
 ", ",
 ButtonBox["Forming Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Forming Morphoids", "i:3"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FormMorphoidSetup",
 ", ",
 ButtonBox["Forming Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Forming Morphoids", "i:3"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FormMorphoidSetup",
 ", ",
 "illustration",
 ", ",
 ButtonBox["Forming Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Forming Morphoids", "i:28"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FormMorphoidSetup",
 ", ",
 "implementation of the graphic",
 ", ",
 ButtonBox["Forming Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Forming Morphoids", "i:29"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Form",
 ", ",
 "option for QuaternionGroup",
 ", ",
 ButtonBox["Other groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other groupoids", "i:25"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FormRingoid",
 ", ",
 ButtonBox["FormRingoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormRingoid", "i:3"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FormRingoidByTable",
 ", ",
 ButtonBox["FormRingoidByTable",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormRingoidByTable", "i:5"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FromCycles",
 ", ",
 ButtonBox["Cycles",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cycles", "i:11"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Func",
 ", ",
 ButtonBox["Function Extensions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Function Extensions", "i:74"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FuncRing",
 ", ",
 "a value of ExtensionType",
 ", ",
 ButtonBox["Extension ringoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Extension ringoids", "i:91"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FunctionForm",
 ", ",
 "option for InnerAutomorphism",
 ", ",
 ButtonBox["Automorphisms",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Automorphisms", "i:23"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FunctionsOver",
 ", ",
 ButtonBox["Function Extensions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Function Extensions", "i:74"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Function",
 ", ",
 "value for FunctionForm option for InnerAutomorphism",
 ", ",
 ButtonBox["Automorphisms",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Automorphisms", "i:23"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "FuncToRules",
 ", ",
 ButtonBox["Function Extensions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Function Extensions", "i:75"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GaloisFieldQ",
 ", ",
 ButtonBox["Finite fields",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Finite fields", "i:86"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GaussianIntegerQ",
 ", ",
 ButtonBox["Potpourri",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Potpourri", "i:39"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GaussianIntegersAdditive",
 ", ",
 "the family of Groupoids",
 ", ",
 ButtonBox["Groupoids based on the integers mod n",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groupoids based on the integers mod n", "i:5"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GaussianIntegersMultiplicative",
 ", ",
 "the family of Groupids",
 ", ",
 ButtonBox["Groupoids based on the integers mod n",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groupoids based on the integers mod n", "i:6"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GaussianIntegers",
 ", ",
 "the family of Ringoid",
 ", ",
 ButtonBox["Groupoids based on the integers mod n",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groupoids based on the integers mod n", "i:5"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GaussianUnits",
 ", ",
 "the Groupoid",
 ", ",
 ButtonBox["Other numeric groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other numeric groupoids", "i:12"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GeneralLinear",
 ", ",
 ButtonBox["Matrix groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix groupoids", "i:71"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GeneralLinearGroup",
 ", ",
 ButtonBox["Matrix groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix groupoids", "i:71"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GenerateGroupoid",
 ", ",
 ButtonBox["GenerateGroupoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"GenerateGroupoid", "i:4"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GeneratingSet",
 ", ",
 ButtonBox["Structure of Groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Structure of Groupoids", "i:12"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Generator",
 ", ",
 "option for Cyclic",
 ", ",
 ButtonBox["Dihedral and Cyclic groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Dihedral and Cyclic groups", "i:24"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Generators",
 ", ",
 "as an option to FormGroupoid",
 ", ",
 ButtonBox["FormGroupoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormGroupoid", "i:3"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GF",
 ", ",
 ButtonBox["Finite fields",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Finite fields", "i:84"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GL",
 ", ",
 "alternate syntax",
 ", ",
 ButtonBox["Matrix groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix groupoids", "i:71"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GL",
 ", ",
 "as a matrix sub-extension",
 ", ",
 ButtonBox["Matrix groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix groupoids", "i:70"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GL",
 ", ",
 "as a value of the MatrixType option",
 ", ",
 ButtonBox["Individual matrices",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Individual matrices", "i:55"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GLQ",
 ", ",
 ButtonBox["Individual matrices",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Individual matrices", "i:57"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GraphicsArray",
 ", ",
 "illustration of Output option",
 ", ",
 ButtonBox["Subgroups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subgroups", "i:29"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GraphicsArray",
 ", ",
 "value for Output option",
 ", ",
 ButtonBox["Global variables and options",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Global variables and options", "i:2"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Group",
 ", ",
 "argument for SwitchStructureTo function",
 ", ",
 ButtonBox["Changing the DefaultStructure",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Changing the DefaultStructure", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GroupCenter",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:7"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GroupExponent",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:11"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GroupIdentity",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GroupInfo",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:24"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GroupInverse",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:20"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Groupoid",
 ", ",
 "argument for SwitchStructureTo function",
 ", ",
 ButtonBox["Changing the DefaultStructure",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Changing the DefaultStructure", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GroupoidDescription",
 ", ",
 "as an option to FormGroupoid",
 ", ",
 ButtonBox["FormGroupoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormGroupoid", "i:3"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GroupoidName",
 ", ",
 ButtonBox["Structure of Groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Structure of Groupoids", "i:12"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Groupoids",
 ", ",
 "Structure",
 ", ",
 ButtonBox["Structure of Groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Structure of Groupoids", "i:10"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GroupProperties",
 ", ",
 "list of objects in package",
 ", ",
 ButtonBox["By Packages",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"By Packages", "i:10"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "GroupQ",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:24"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Groups",
 ", ",
 "argument for SwitchStructureTo function",
 ", ",
 ButtonBox["Changing the DefaultStructure",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Changing the DefaultStructure", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Group",
 ", ",
 "value for Structure option",
 ", ",
 ButtonBox["The four standard functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"The four standard functions", "i:15"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "HasIdentityQ",
 ", ",
 ButtonBox["The four standard functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"The four standard functions", "i:14"}],
 ", ",
 ButtonBox["Multiplicative properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Multiplicative properties", "i:21"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "HasIdentityQ",
 ", ",
 "as applied to testing for a zero in a Ringoid",
 ", ",
 ButtonBox["Additive properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Additive properties", "i:16"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "HasIdentityQ",
 ", ",
 "variations",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:17"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "HasInversesQ",
 ", ",
 ButtonBox["The four standard functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"The four standard functions", "i:14"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "HasInversesQ",
 ", ",
 "as applied to negations in a Ringoid",
 ", ",
 ButtonBox["Additive properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Additive properties", "i:16"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "HasInversesQ",
 ", ",
 "variations",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:19"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "HasLeftIdentityQ",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "HasNegativeQ",
 ", ",
 "as applies to Ringoids",
 ", ",
 ButtonBox["Additive properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Additive properties", "i:17"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "HasRightIdentityQ",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "HasUnityQ",
 ", ",
 ButtonBox["Multiplicative properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Multiplicative properties", "i:21"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "HasZeroQ",
 ", ",
 ButtonBox["Additive properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Additive properties", "i:16"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "HasZeroQ",
 ", ",
 "as applied to functions over a Ringoid",
 ", ",
 ButtonBox["Function Arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Function Arithmetic", "i:78"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "HasZeroQ",
 ", ",
 "as applied to matrix extensions",
 ", ",
 ButtonBox["Matrix arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix arithmetic", "i:60"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "HasZeroQ",
 ", ",
 "as applied to polynomial extensions",
 ", ",
 ButtonBox["Polynomial arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Polynomial arithmetic", "i:29"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "HeadingsColored",
 ", ",
 "as an option to CayleyTable",
 ", ",
 ButtonBox["Cayley tables",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cayley tables", "i:28"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "HomomorphismQ",
 ", ",
 ButtonBox["Preserving Operations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Preserving Operations", "i:16"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "IdealQ",
 ", ",
 ButtonBox["Subrings and ideals",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subrings and ideals", "i:8"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "IdempotentQ",
 ", ",
 ButtonBox["Testing other properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Testing other properties", "i:30"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Idempotents",
 ", ",
 ButtonBox["Testing other properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Testing other properties", "i:30"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Identity",
 ", ",
 "EAAM usage",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "IdentityMatrix",
 ", ",
 "EAAM usage",
 ", ",
 ButtonBox["Miscellaneous matrix functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Miscellaneous matrix functions", "i:72"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "IgnoreIndeterminate",
 ", ",
 "option for Equal for testing polynomials",
 ", ",
 ButtonBox["Extensions of Stnrd Mathematica",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Extensions of Stnrd Mathematica", "i:45"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Image",
 ", ",
 "of a Morphoid",
 ", ",
 ButtonBox["Kernel, Image, and InverseImage(s)",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Kernel, Image, and InverseImage(s)", "i:20"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Indeterminate",
 ", ",
 "as an option to Poly",
 ", ",
 ButtonBox["Forming polynomials",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Forming polynomials", "i:23"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Indeterminate",
 ", ",
 "as an option to polynomial lists",
 ", ",
 ButtonBox["Miscellaneous functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Miscellaneous functions", "i:48"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "IndexLimit",
 ", ",
 "as an option to Symmetric",
 ", ",
 ButtonBox["Groups of permutations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groups of permutations", "i:16"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Index",
 ", ",
 "of a subgroup",
 ", ",
 ButtonBox["Quotient groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient groups", "i:25"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "InducedCanonical",
 ", ",
 ButtonBox["Built-in Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Built-in Morphoids", "i:11"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "InducedIsomorphism",
 ", ",
 ButtonBox["Built-in Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Built-in Morphoids", "i:11"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "InjectiveQ",
 ", ",
 "as applied to Morphoids",
 ", ",
 ButtonBox["Surjectivity and injectivity",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Surjectivity and injectivity", "i:14"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Inn",
 ", ",
 ButtonBox["Automorphisms",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Automorphisms", "i:23"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "InnerAutomorphism",
 ", ",
 ButtonBox["Automorphisms",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Automorphisms", "i:23"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "InnerAutomorphismGroup",
 ", ",
 ButtonBox["Automorphisms",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Automorphisms", "i:23"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "IntegerDivisors",
 ", ",
 ButtonBox["Divisibility",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Divisibility", "i:24"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "IntegerLatticeGrid",
 ", ",
 ButtonBox["Potpourri",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Potpourri", "i:39"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Integers mod n",
 ", ",
 ButtonBox["Groupoids based on the integers mod n",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groupoids based on the integers mod n", "i:2"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "IntegerUnits",
 ", ",
 "the Groupoid",
 ", ",
 ButtonBox["Other numeric groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other numeric groupoids", "i:12"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "IntegralDomainQ",
 ", ",
 ButtonBox["Specialized rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Specialized rings", "i:26"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "InterpolatingPolynomial",
 ", ",
 "EAAM usage",
 ", ",
 ButtonBox["Polynomial Conversion, Interpolation",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Polynomial Conversion, Interpolation", "i:82"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Inverse",
 ", ",
 "EAAM usage",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:20"}],
 ", ",
 ButtonBox["Determinants & inverses",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Determinants & inverses", "i:62"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "InverseImage",
 ", ",
 ButtonBox["Kernel, Image, and InverseImage(s)",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Kernel, Image, and InverseImage(s)", "i:21"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "InverseImages",
 ", ",
 ButtonBox["Kernel, Image, and InverseImage(s)",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Kernel, Image, and InverseImage(s)", "i:21"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Inverses",
 ", ",
 "as applied to a Ringoid",
 ", ",
 ButtonBox["Additive properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Additive properties", "i:17"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Inverses",
 ", ",
 "as applied to Groupids",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:20"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Inverses",
 ", ",
 "as applied to multiplication in a Ringoid",
 ", ",
 ButtonBox["Multiplicative properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Multiplicative properties", "i:21"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Inverses",
 ", ",
 "matrix",
 ", ",
 ButtonBox["Determinants & inverses",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Determinants & inverses", "i:61"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "InvertibleQ",
 ", ",
 "as applied to addition in a Ringoid",
 ", ",
 ButtonBox["Additive properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Additive properties", "i:17"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "InvertibleQ",
 ", ",
 "as applied to multiplication in a Ringoid",
 ", ",
 ButtonBox["Multiplicative properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Multiplicative properties", "i:21"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "IrreduciblePolynomial",
 ", ",
 ButtonBox["Finite fields",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Finite fields", "i:86"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "IrreduciblePolyOverZpQ",
 ", ",
 ButtonBox["Finite fields",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Finite fields", "i:86"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "IsAGroup",
 ", ",
 "as an option to FormGroupoid",
 ", ",
 ButtonBox["FormGroupoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormGroupoid", "i:3"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "IsARing",
 ", ",
 "as an option to FormRingoid",
 ", ",
 ButtonBox["FormRingoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormRingoid", "i:4"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "IsomorphismQ",
 ", ",
 ButtonBox["Preserving Operations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Preserving Operations", "i:19"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "JoinDivisors",
 ", ",
 "the family of Groupoids",
 ", ",
 ButtonBox["Other numeric groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other numeric groupoids", "i:11"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Kernel",
 ", ",
 ButtonBox["Kernel, Image, and InverseImage(s)",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Kernel, Image, and InverseImage(s)", "i:20"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "KeyForm",
 ", ",
 "as an option to CayleyTable",
 ", ",
 ButtonBox["Cayley tables",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cayley tables", "i:28"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "KeyForm",
 ", ",
 "as an option to FormGroupoid",
 ", ",
 ButtonBox["FormGroupoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormGroupoid", "i:3"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "KeyForm",
 ", ",
 "as an option to FormRingoid",
 ", ",
 ButtonBox["FormRingoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormRingoid", "i:4"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "KeyForm",
 ", ",
 "illustration",
 ", ",
 ButtonBox["Visual mode with large elements",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Visual mode with large elements", "i:17"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "KeyToElement",
 ", ",
 ButtonBox["Visual mode with large elements",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Visual mode with large elements", "i:16"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Klein4",
 ", ",
 "elements as strings",
 ", ",
 ButtonBox["Other groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other groupoids", "i:38"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Klein4",
 ", ",
 "the Groupoid",
 ", ",
 ButtonBox["Other groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other groupoids", "i:25"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "LatticeRing",
 ", ",
 "the family of Ringoids",
 ", ",
 ButtonBox["Numeric Rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Numeric Rings", "i:32"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "LeftCoset",
 ", ",
 "as applied to Ringoids",
 ", ",
 ButtonBox["Quotient Rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient Rings", "i:15"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "LeftCoset",
 ", ",
 "of a subgroup",
 ", ",
 ButtonBox["Quotient groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient groups", "i:20"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "LeftCosets",
 ", ",
 "as applied to Ringoids",
 ", ",
 ButtonBox["Quotient Rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient Rings", "i:15"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "LeftCosets",
 ", ",
 "of a subgroup",
 ", ",
 ButtonBox["Quotient groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient groups", "i:21"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "LeftDistributiveQ",
 ", ",
 "as applied to Ringoids",
 ", ",
 ButtonBox["Distributive property",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Distributive property", "i:24"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "LeftIdealQ",
 ", ",
 ButtonBox["Subrings and ideals",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subrings and ideals", "i:8"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "LeftIdentity",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "LeftInverse",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:20"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "LeftInvertibleQ",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:20"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "LeftToRight",
 ", ",
 "illustration",
 ", ",
 ButtonBox["Groups of permutations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groups of permutations", "i:36"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "LeftToRight",
 ", ",
 "value for ProductOrder option",
 ", ",
 ButtonBox["Groups of permutations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groups of permutations", "i:16"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ListDensityPlot",
 ", ",
 "as an alternative it CayleyTable",
 ", ",
 ButtonBox["Using Cayley tables ",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Using Cayley tables ", "i:2"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "List",
 ", ",
 "value for CycleAs option for ToCycles",
 ", ",
 ButtonBox["Cycles",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cycles", "i:12"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "LowerDegreeOK",
 ", ",
 "as an option with random polynomials",
 ", ",
 ButtonBox["Random polynomials",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Random polynomials", "i:26"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "LT",
 ", ",
 "as a matrix sub-extension",
 ", ",
 ButtonBox["Matrix groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix groupoids", "i:70"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "LT",
 ", ",
 "as a value of the MatrixType option",
 ", ",
 ButtonBox["Individual matrices",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Individual matrices", "i:55"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "LTD",
 ", ",
 "as a matrix sub-extension",
 ", ",
 ButtonBox["Matrix groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix groupoids", "i:70"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "LTD",
 ", ",
 "as a value of the MatrixType option",
 ", ",
 ButtonBox["Individual matrices",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Individual matrices", "i:55"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Mat",
 ", ",
 ButtonBox["MatricesOver",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"MatricesOver", "i:51"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MatA",
 ", ",
 ButtonBox["MatricesOver",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"MatricesOver", "i:51"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MatM",
 ", ",
 ButtonBox["MatricesOver",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"MatricesOver", "i:51"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Matrices",
 ", ",
 "a value of ExtensionType",
 ", ",
 ButtonBox["Extension ringoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Extension ringoids", "i:91"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MatricesOver",
 ", ",
 ButtonBox["MatricesOver",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"MatricesOver", "i:50"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MatrixOperation",
 ", ",
 ButtonBox["Miscellaneous matrix functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Miscellaneous matrix functions", "i:72"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MatrixOverQ",
 ", ",
 ButtonBox["Miscellaneous matrix functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Miscellaneous matrix functions", "i:72"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MatrixPower",
 ", ",
 ButtonBox["Matrix arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix arithmetic", "i:59"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MatrixType",
 ", ",
 "as an option to RandomMatrix",
 ", ",
 ButtonBox["Individual matrices",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Individual matrices", "i:56"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MatrixType",
 ", ",
 "illustrations",
 ", ",
 ButtonBox["Individual matrices",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Individual matrices", "i:94"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MaxElementsToList",
 ", ",
 "as an option to FormGroupoid",
 ", ",
 ButtonBox["FormGroupoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormGroupoid", "i:3"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MaxElementsToList",
 ", ",
 "as an option to FormRingoid",
 ", ",
 ButtonBox["FormRingoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormRingoid", "i:4"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MaximalIdealQ",
 ", ",
 ButtonBox["Subrings and ideals",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subrings and ideals", "i:12"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Maximal Ideals",
 ", ",
 ButtonBox["Subrings and ideals",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subrings and ideals", "i:13"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MaxTaker",
 ", ",
 "the family of Groupids",
 ", ",
 ButtonBox["Other numeric groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other numeric groupoids", "i:9"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MeetDivisors",
 ", ",
 "the family of Groupoids",
 ", ",
 ButtonBox["Other numeric groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other numeric groupoids", "i:11"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MGroupoid",
 ", ",
 ButtonBox["Groupoids from ringoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groupoids from ringoids", "i:13"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MinTaker",
 ", ",
 "the family of Groupids",
 ", ",
 ButtonBox["Other numeric groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other numeric groupoids", "i:9"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MixedDivisors",
 ", ",
 "the family of Groupoids",
 ", ",
 ButtonBox["Other numeric groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other numeric groupoids", "i:11"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Mode",
 ", ",
 "as an option to ClosedQ",
 ", ",
 ButtonBox["The four standard functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"The four standard functions", "i:15"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Mode",
 ", ",
 "as an option to ring properties functions",
 ", ",
 ButtonBox["Additive properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Additive properties", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Mode",
 ", ",
 "how to use",
 ", ",
 ButtonBox["How to use a Mode",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"How to use a Mode", "i:11"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Mode",
 ", ",
 "illustration of various values",
 ", ",
 ButtonBox["How to use a Mode",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"How to use a Mode", "i:15"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ModpIrreducibilityQ",
 ", ",
 ButtonBox["Irreducibility of Polynomials",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Irreducibility of Polynomials", "i:41"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ModulusPolynomial",
 ", ",
 "of a polynomial quotient ring",
 ", ",
 ButtonBox["Polynomial Quotient Rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Polynomial Quotient Rings", "i:36"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Monic",
 ", ",
 "as an option with random polynomials",
 ", ",
 ButtonBox["Random polynomials",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Random polynomials", "i:26"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MonoidQ",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:24"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Monomial",
 ", ",
 ButtonBox["Miscellaneous functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Miscellaneous functions", "i:46"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MorphismQ",
 ", ",
 ButtonBox["Preserving Operations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Preserving Operations", "i:16"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MorphoidComposition",
 ", ",
 ButtonBox["The structure of Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"The structure of Morphoids", "i:8"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Morphoid",
 ", ",
 "formation",
 ", ",
 ButtonBox["How to form Structures",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"How to form Structures", "i:10"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MorphoidFunction",
 ", ",
 ButtonBox["The structure of Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"The structure of Morphoids", "i:6"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MorphoidRules",
 ", ",
 ButtonBox["The structure of Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"The structure of Morphoids", "i:6"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Morphoids",
 ", ",
 "concept",
 ", ",
 ButtonBox["Introduction",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Introduction", "i:1"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Morphoids",
 ", ",
 "formation",
 ", ",
 ButtonBox["Forming Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Forming Morphoids", "i:2"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Morphoids",
 ", ",
 "properties",
 ", ",
 ButtonBox["Surjectivity and injectivity",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Surjectivity and injectivity", "i:13"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Morphoids",
 ", ",
 "structure",
 ", ",
 ButtonBox["The structure of Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"The structure of Morphoids", "i:5"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Morphoids",
 ", ",
 "visualization",
 ", ",
 ButtonBox["Visualizing Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Visualizing Morphoids", "i:24"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MultipleOfElement",
 ", ",
 ButtonBox["Testing other properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Testing other properties", "i:29"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Multiplication",
 ", ",
 "as an operation on polynomials",
 ", ",
 ButtonBox["Polynomial arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Polynomial arithmetic", "i:28"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Multiplication",
 ", ",
 "as applied to functions over a Ringoid",
 ", ",
 ButtonBox["Function Arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Function Arithmetic", "i:77"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Multiplication",
 ", ",
 "as applied to matrices",
 ", ",
 ButtonBox["Matrix arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix arithmetic", "i:59"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Multiplication",
 ", ",
 "as applied to Ringoid extensions",
 ", ",
 ButtonBox["Extension ringoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Extension ringoids", "i:19"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Multiplication",
 ", ",
 "in a Ringoid",
 ", ",
 ButtonBox["Basic functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Basic functions", "i:7"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MultiplicationTable",
 ", ",
 "of a Ringoid",
 ", ",
 ButtonBox["Using Cayley tables ",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Using Cayley tables ", "i:1"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Multiplication",
 ", ",
 "value for the Operation option",
 ", ",
 ButtonBox["Additive properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Additive properties", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MultiplicativeGroupoid",
 ", ",
 ButtonBox["Groupoids from ringoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groupoids from ringoids", "i:13"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MultiplicativeInverse",
 ", ",
 "as applied to functions over a Ringoid",
 ", ",
 ButtonBox["Function Arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Function Arithmetic", "i:80"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MultiplicativeInverse",
 ", ",
 "as applied to matrices",
 ", ",
 ButtonBox["Determinants & inverses",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Determinants & inverses", "i:62"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MultiplicativeToAdditive",
 ", ",
 ButtonBox["Finite fields",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Finite fields", "i:88"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MultiplyCycles",
 ", ",
 ButtonBox["Cycle operations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cycle operations", "i:14"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "MultiplyPermutations",
 ", ",
 ButtonBox["Permutation operations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Permutation operations", "i:6"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "NegationOf",
 ", ",
 "as applied to functions over a Ringoid",
 ", ",
 ButtonBox["Function Arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Function Arithmetic", "i:78"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "NegationOf",
 ", ",
 "as applied to matrix extensions",
 ", ",
 ButtonBox["Matrix arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix arithmetic", "i:60"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "NegationOf",
 ", ",
 "as applied to polynomial extensions",
 ", ",
 ButtonBox["Polynomial arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Polynomial arithmetic", "i:29"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "NegationOf",
 ", ",
 "as applies to Ringoids",
 ", ",
 ButtonBox["Additive properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Additive properties", "i:17"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Negations",
 ", ",
 "value for Combine option for divisor functions",
 ", ",
 ButtonBox["Divisibility",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Divisibility", "i:26"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "NextStage",
 ", ",
 ButtonBox["Subgroups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subgroups", "i:12"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "NilpotentDegree",
 ", ",
 ButtonBox["Testing other properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Testing other properties", "i:30"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "NilpotentQ",
 ", ",
 ButtonBox["Testing other properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Testing other properties", "i:30"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Nilpotents",
 ", ",
 ButtonBox["Testing other properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Testing other properties", "i:30"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "NonAssociatingTriples",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:22"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "NonCommutingPairs",
 ", ",
 "in a Groupoid",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:5"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "NonIdentity",
 ", ",
 "value for the SelectFrom option for RandomElement(s)",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:2"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "NonTrivialOnly",
 ", ",
 "as an option with algebraic integers",
 ", ",
 ButtonBox["Divisibility",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Divisibility", "i:26"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "NonUnity",
 ", ",
 "value for the SelectFrom option of RandomElement(s)",
 ", ",
 ButtonBox["Ring related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Ring related functions", "i:11"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "NonZeroMGroupoid",
 ", ",
 ButtonBox["Groupoids from ringoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groupoids from ringoids", "i:13"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "NonZero",
 ", ",
 "value for the SelectFrom option of RandomElement(s)",
 ", ",
 ButtonBox["Ring related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Ring related functions", "i:11"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Normalize",
 ", ",
 "as an option to ToCycles",
 ", ",
 ButtonBox["Cycles",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cycles", "i:12"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Normalizer",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:9"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Normalizer",
 ", ",
 "concept",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:8"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "NormalQ",
 ", ",
 ButtonBox["Quotient groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient groups", "i:25"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "NS",
 ", ",
 "usage explained",
 ", ",
 ButtonBox["Quotient groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient groups", "i:31"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "OddPermutationQ",
 ", ",
 ButtonBox["Other cycle-related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other cycle-related functions", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "OneToOneQ",
 ", ",
 "as applied to Morphoids",
 ", ",
 ButtonBox["Surjectivity and injectivity",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Surjectivity and injectivity", "i:14"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "OntoQ",
 ", ",
 "as applied to Morphoids",
 ", ",
 ButtonBox["Surjectivity and injectivity",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Surjectivity and injectivity", "i:14"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Operation",
 ", ",
 "applied to Groupoids",
 ", ",
 ButtonBox["Structure of Groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Structure of Groupoids", "i:11"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Operation",
 ", ",
 "as an option to ring properties functions",
 ", ",
 ButtonBox["Additive properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Additive properties", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "OperatorSymbol",
 ", ",
 ButtonBox["Structure of Groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Structure of Groupoids", "i:12"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "OperatorSymbol",
 ", ",
 "illustration",
 ", ",
 ButtonBox["FormGroupoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormGroupoid", "i:26"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Orbit",
 ", ",
 ButtonBox["Stabilizers and orbits",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Stabilizers and orbits", "i:20"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Ordering",
 ", ",
 ButtonBox["Introduction to Permutations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Introduction to Permutations", "i:4"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Order",
 ", ",
 "of a Groupoid",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:4"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "OrderOfAllElements",
 ", ",
 "in a Groupoid",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:4"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Order",
 ", ",
 "of an element in a Groupoid",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:4"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "OrderOfElement",
 ", ",
 "in a Groupoid",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:4"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Orders",
 ", ",
 "in a Groupoid",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:4"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Output",
 ", ",
 ButtonBox["Global variables and options",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Global variables and options", "i:2"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Parity",
 ", ",
 ButtonBox["Other cycle-related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other cycle-related functions", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Parity",
 ", ",
 "as a Morphoid",
 ", ",
 ButtonBox["Forming Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Forming Morphoids", "i:4"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Parity",
 ", ",
 "used in Morphoid",
 ", ",
 ButtonBox["Kernel, Image, and InverseImage(s)",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Kernel, Image, and InverseImage(s)", "i:33"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Partition",
 ", ",
 "option for CartesianProduct",
 ", ",
 ButtonBox["Working with lists",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Working with lists", "i:31"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PermutationComposition",
 ", ",
 ButtonBox["Permutation operations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Permutation operations", "i:6"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PermutationGroup",
 ", ",
 "the family of Groupoids",
 ", ",
 ButtonBox["Groups of permutations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groups of permutations", "i:14"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PermutationImage",
 ", ",
 ButtonBox["Stabilizers and orbits",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Stabilizers and orbits", "i:19"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PermutationInverse",
 ", ",
 ButtonBox["Permutation operations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Permutation operations", "i:7"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PermutationMatrix",
 ", ",
 ButtonBox["Permutation operations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Permutation operations", "i:7"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PermutationQ",
 ", ",
 ButtonBox["Introduction to Permutations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Introduction to Permutations", "i:4"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Permutations",
 ", ",
 "an AbstractAlgebra package",
 ", ",
 ButtonBox["Packages in AbstractAlgebra",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Packages in AbstractAlgebra", "i:3"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Permutations",
 ", ",
 "list of objects in package",
 ", ",
 ButtonBox["By Packages",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"By Packages", "i:15"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Permutations",
 ", ",
 "operations",
 ", ",
 ButtonBox["Permutation operations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Permutation operations", "i:5"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Permutations",
 ", ",
 "representations",
 ", ",
 ButtonBox["Representing permutations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Representing permutations", "i:8"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Permutations",
 ", ",
 "value for Form option for Dihedral",
 ", ",
 ButtonBox["Dihedral and Cyclic groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Dihedral and Cyclic groups", "i:22"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PermutationToPower",
 ", ",
 ButtonBox["Permutation operations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Permutation operations", "i:7"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PlusSymbol",
 ", ",
 ButtonBox["Ring related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Ring related functions", "i:8"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Poly",
 ", ",
 "as a head for polynomials",
 ", ",
 ButtonBox["Forming polynomials",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Forming polynomials", "i:22"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Poly",
 ", ",
 "InputForm",
 ", ",
 ButtonBox["Polynomial arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Polynomial arithmetic", "i:93"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PolynomialDivision",
 ", ",
 ButtonBox["Polynomial arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Polynomial arithmetic", "i:32"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PolynomialEvaluation",
 ", ",
 ButtonBox["Solving Equations, Evaluation",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Solving Equations, Evaluation", "i:43"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Polynomial Evaluation",
 ", ",
 "in a polynomial quotient ring",
 ", ",
 ButtonBox["Polynomial Quotient Rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Polynomial Quotient Rings", "i:37"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PolynomialGCD",
 ", ",
 ButtonBox["Polynomial arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Polynomial arithmetic", "i:33"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Polynomial Interpolation",
 ", ",
 ButtonBox["Polynomial Conversion, Interpolation",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Polynomial Conversion, Interpolation", "i:81"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PolynomialLCM",
 ", ",
 ButtonBox["Polynomial arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Polynomial arithmetic", "i:33"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PolynomialQuotient",
 ", ",
 ButtonBox["Polynomial arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Polynomial arithmetic", "i:32"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PolynomialRemainder",
 ", ",
 ButtonBox["Polynomial arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Polynomial arithmetic", "i:32"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PolynomialsOfDegreeN",
 ", ",
 ButtonBox["Miscellaneous functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Miscellaneous functions", "i:47"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PolynomialsUpToDegreeN",
 ", ",
 ButtonBox["Miscellaneous functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Miscellaneous functions", "i:47"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PolyQ",
 ", ",
 ButtonBox["Miscellaneous functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Miscellaneous functions", "i:46"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PolyRing",
 ", ",
 "a value of ExtensionType",
 ", ",
 ButtonBox["Extension ringoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Extension ringoids", "i:91"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PolyToFunction",
 ", ",
 ButtonBox["Polynomial Conversion, Interpolation",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Polynomial Conversion, Interpolation", "i:82"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PowerList",
 ", ",
 ButtonBox["Finite fields",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Finite fields", "i:87"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PowersIncrease",
 ", ",
 "as an option to Poly",
 ", ",
 ButtonBox["Forming polynomials",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Forming polynomials", "i:23"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PreservesQ",
 ", ",
 ButtonBox["Preserving Operations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Preserving Operations", "i:16"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PreservesQ",
 ", ",
 "visualization",
 ", ",
 ButtonBox["Preserving Operations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Preserving Operations", "i:31"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PreservesQ",
 ", ",
 "visualization for ring Morphoid",
 ", ",
 ButtonBox["Preserving Operations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Preserving Operations", "i:32"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PreviousStage",
 ", ",
 ButtonBox["Subgroups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subgroups", "i:12"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PrimeIdealQ",
 ", ",
 ButtonBox["Subrings and ideals",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subrings and ideals", "i:12"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Prime Ideals",
 ", ",
 ButtonBox["Subrings and ideals",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subrings and ideals", "i:13"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PrimitivePolynomials",
 ", ",
 ButtonBox["Finite fields",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Finite fields", "i:87"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PrincipalIdeal",
 ", ",
 ButtonBox["Subrings and ideals",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subrings and ideals", "i:11"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "PrintMessage",
 ", ",
 "as an option to ProbableMorphismQ",
 ", ",
 ButtonBox["Preserving Operations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Preserving Operations", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ProbableGroupQ",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:24"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ProbableMorphismQ",
 ", ",
 ButtonBox["Preserving Operations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Preserving Operations", "i:17"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ProbableRingQ",
 ", ",
 ButtonBox["RingQ test",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"RingQ test", "i:25"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ProductOrder",
 ", ",
 "as an option to FormGroupoidFromCycles",
 ", ",
 ButtonBox["FormGroupoidFromCycles and RandomGroupoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormGroupoidFromCycles and RandomGroupoid", "i:8"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ProductOrder",
 ", ",
 "as an option to Symmetric",
 ", ",
 ButtonBox["Groups of permutations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groups of permutations", "i:16"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Products",
 ", ",
 "value for Combine option for divisor functions",
 ", ",
 ButtonBox["Divisibility",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Divisibility", "i:26"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ProperSubsetQ",
 ", ",
 ButtonBox["Working with lists",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Working with lists", "i:31"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "QuaternionGroup",
 ", ",
 ButtonBox["Other groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other groupoids", "i:25"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "QuotientGroup",
 ", ",
 ButtonBox["Quotient groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient groups", "i:26"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Quotient Groups",
 ", ",
 ButtonBox["Quotient groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient groups", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "QuotientRing",
 ", ",
 ButtonBox["Quotient Rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient Rings", "i:15"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "QuotientRing",
 ", ",
 "as applied to polynomial extensions",
 ", ",
 ButtonBox["Polynomial Quotient Rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Polynomial Quotient Rings", "i:36"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Radical",
 ", ",
 "option for DividesQ",
 ", ",
 ButtonBox["Divisibility",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Divisibility", "i:25"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RandomAssociativeQ",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:22"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RandomAssociativeQ",
 ", ",
 "as applied to addition in a Ringoid",
 ", ",
 ButtonBox["Additive properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Additive properties", "i:17"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RandomAssociativeQ",
 ", ",
 "as applied to multiplication in a Ringoid",
 ", ",
 ButtonBox["Multiplicative properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Multiplicative properties", "i:21"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RandomDistributiveQ",
 ", ",
 "as applied to Ringoids",
 ", ",
 ButtonBox["Distributive property",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Distributive property", "i:24"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RandomElement",
 ", ",
 "as applied to functions over a Ringoid",
 ", ",
 ButtonBox["Function Extensions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Function Extensions", "i:75"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RandomElement",
 ", ",
 "as applied to matrices",
 ", ",
 ButtonBox["Individual matrices",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Individual matrices", "i:53"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RandomElement",
 ", ",
 "as applied to polynomials",
 ", ",
 ButtonBox["Random polynomials",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Random polynomials", "i:25"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RandomElement",
 ", ",
 "as applied to Ringoids",
 ", ",
 ButtonBox["Ring related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Ring related functions", "i:10"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RandomElement",
 ", ",
 "as applied to Z[Sqrt[d]]",
 ", ",
 ButtonBox["Basic Zd functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Basic Zd functions", "i:22"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RandomElement",
 ", ",
 "from a Groupoid",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:1"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RandomElements",
 ", ",
 "as applied to functions over a Ringoid",
 ", ",
 ButtonBox["Function Extensions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Function Extensions", "i:75"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RandomElements",
 ", ",
 "as applied to matrices",
 ", ",
 ButtonBox["Individual matrices",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Individual matrices", "i:53"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RandomElements",
 ", ",
 "as applied to polynomials",
 ", ",
 ButtonBox["Random polynomials",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Random polynomials", "i:25"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RandomElements",
 ", ",
 "as applied to Ringoids",
 ", ",
 ButtonBox["Ring related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Ring related functions", "i:10"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RandomElements",
 ", ",
 "as applied to Z[Sqrt[d]]",
 ", ",
 ButtonBox["Basic Zd functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Basic Zd functions", "i:22"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RandomElements",
 ", ",
 "from a Groupoid",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:1"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Random Elements",
 ", ",
 "from various structures",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:3"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Random Elements",
 ", ",
 "of Ringoids",
 ", ",
 ButtonBox["Ring related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Ring related functions", "i:9"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RandomGroupoid",
 ", ",
 ButtonBox["FormGroupoidFromCycles and RandomGroupoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormGroupoidFromCycles and RandomGroupoid", "i:9"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Randomize",
 ", ",
 ButtonBox["Working with lists",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Working with lists", "i:31"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Randomize",
 ", ",
 "option for DisguiseGroupoid",
 ", ",
 ButtonBox["Disguising groups and rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Disguising groups and rings", "i:36"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RandomMatrix",
 ", ",
 ButtonBox["Individual matrices",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Individual matrices", "i:53"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RandomPermutation",
 ", ",
 ButtonBox["Introduction to Permutations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Introduction to Permutations", "i:4"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Random",
 ", ",
 "value for the Representatives option of QuotientGroup",
 ", ",
 ButtonBox["Quotient groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient groups", "i:27"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RationalRootCandidates",
 ", ",
 ButtonBox["Irreducibility of Polynomials",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Irreducibility of Polynomials", "i:41"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RationalRootTheorem",
 ", ",
 ButtonBox["Irreducibility of Polynomials",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Irreducibility of Polynomials", "i:41"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RefSym",
 ", ",
 "as an option to Dihedral",
 ", ",
 ButtonBox["Dihedral and Cyclic groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Dihedral and Cyclic groups", "i:22"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RefSym",
 ", ",
 "illustration",
 ", ",
 ButtonBox["Dihedral and Cyclic groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Dihedral and Cyclic groups", "i:37"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Ref",
 ", ",
 "value for RefSym option for Dihedral",
 ", ",
 ButtonBox["Dihedral and Cyclic groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Dihedral and Cyclic groups", "i:22"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ReorderGroupoid",
 ", ",
 ButtonBox["Structure of Groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Structure of Groupoids", "i:12"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Replacement",
 ", ",
 "as an option to random elements of a Groupoid",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:2"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Replacement",
 ", ",
 "as applied to random elements of a Ringoid",
 ", ",
 ButtonBox["Ring related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Ring related functions", "i:11"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ReportIterations",
 ", ",
 "as an option to Closure",
 ", ",
 ButtonBox["Subgroups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subgroups", "i:10"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Representatives",
 ", ",
 "as an option to QuotientGroup",
 ", ",
 ButtonBox["Quotient groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient groups", "i:27"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Representatives",
 ", ",
 "value for the Form option of QuotientGroup",
 ", ",
 ButtonBox["Quotient groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient groups", "i:27"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RightCoset",
 ", ",
 "as applied to Ringoids",
 ", ",
 ButtonBox["Quotient Rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient Rings", "i:15"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RightCoset",
 ", ",
 "of a subgroup",
 ", ",
 ButtonBox["Quotient groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient groups", "i:20"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RightCosets",
 ", ",
 "as applied to Ringoids",
 ", ",
 ButtonBox["Quotient Rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient Rings", "i:15"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RightCosets",
 ", ",
 "of a subgroup",
 ", ",
 ButtonBox["Quotient groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Quotient groups", "i:21"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RightDistributiveQ",
 ", ",
 "as applied to Ringoids",
 ", ",
 ButtonBox["Distributive property",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Distributive property", "i:24"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RightIdealQ",
 ", ",
 ButtonBox["Subrings and ideals",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subrings and ideals", "i:8"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RightIdentity",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RightInverse",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:20"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RightInvertibleQ",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:20"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RightToLeft",
 ", ",
 "value for ProductOrder option",
 ", ",
 ButtonBox["FormGroupoidFromCycles and RandomGroupoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormGroupoidFromCycles and RandomGroupoid", "i:8"}],
 ", ",
 ButtonBox["Groups of permutations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groups of permutations", "i:16"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RightToLeft",
 ", ",
 "value of DefaultOrder",
 ", ",
 ButtonBox["Global variables and options",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Global variables and options", "i:2"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Ring",
 ", ",
 "argument for SwitchStructureTo function",
 ", ",
 ButtonBox["Changing the DefaultStructure",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Changing the DefaultStructure", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RingExtension",
 ", ",
 "structure name for ring extensions",
 ", ",
 ButtonBox["Forming polynomials",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Forming polynomials", "i:92"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RingInfo",
 ", ",
 ButtonBox["RingQ test",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"RingQ test", "i:25"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Ringoid",
 ", ",
 "argument for SwitchStructureTo function",
 ", ",
 ButtonBox["Changing the DefaultStructure",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Changing the DefaultStructure", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RingoidDescription",
 ", ",
 "as an option to FormRingoid",
 ", ",
 ButtonBox["FormRingoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormRingoid", "i:4"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RingoidName",
 ", ",
 ButtonBox["Ring related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Ring related functions", "i:8"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RingoidName",
 ", ",
 "as an option to FormRingoid",
 ", ",
 ButtonBox["FormRingoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormRingoid", "i:4"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RingQ",
 ", ",
 ButtonBox["RingQ test",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"RingQ test", "i:25"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Rings",
 ", ",
 "argument for SwitchStructureTo function",
 ", ",
 ButtonBox["Changing the DefaultStructure",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Changing the DefaultStructure", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RootsOfUnity",
 ", ",
 "the family of Groupoids",
 ", ",
 ButtonBox["Other numeric groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other numeric groupoids", "i:12"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RotRef",
 ", ",
 "value for Form option for Dihedral",
 ", ",
 ButtonBox["Dihedral and Cyclic groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Dihedral and Cyclic groups", "i:22"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RotSym",
 ", ",
 "as an option to Dihedral",
 ", ",
 ButtonBox["Dihedral and Cyclic groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Dihedral and Cyclic groups", "i:22"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "RotSym",
 ", ",
 "illustration",
 ", ",
 ButtonBox["Dihedral and Cyclic groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Dihedral and Cyclic groups", "i:37"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Rot",
 ", ",
 "value for RotSym option for Dihedral",
 ", ",
 ButtonBox["Dihedral and Cyclic groups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Dihedral and Cyclic groups", "i:22"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Rules",
 ", ",
 "value for FunctionForm option for InnerAutomorphism",
 ", ",
 ButtonBox["Automorphisms",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Automorphisms", "i:23"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SamePermutationQ",
 ", ",
 ButtonBox["Other cycle-related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other cycle-related functions", "i:15"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SameSetQ",
 ", ",
 ButtonBox["Working with lists",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Working with lists", "i:31"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SamplePairs",
 ", ",
 "as an option to ProbableMorphismQ",
 ", ",
 ButtonBox["Preserving Operations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Preserving Operations", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SampleSize",
 ", ",
 "as an option to ProbableMorphismQ",
 ", ",
 ButtonBox["Preserving Operations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Preserving Operations", "i:18"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SelectBaseElementsFrom",
 ", ",
 "as an option for random matrices",
 ", ",
 ButtonBox["Individual matrices",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Individual matrices", "i:54"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SelectFrom",
 ", ",
 "as an option for random matrices",
 ", ",
 ButtonBox["Individual matrices",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Individual matrices", "i:54"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SelectFrom",
 ", ",
 "as an option to random elements of a Groupoid",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:2"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SelectFrom",
 ", ",
 "as an option with random polynomials",
 ", ",
 ButtonBox["Random polynomials",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Random polynomials", "i:26"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SelectFrom",
 ", ",
 "as applied to random element of a Ringoid",
 ", ",
 ButtonBox["Ring related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Ring related functions", "i:11"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SemiGroupQ",
 ", ",
 ButtonBox["Related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Related functions", "i:24"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "S",
 ", ",
 "equivalent to Symmetric",
 ", ",
 ButtonBox["Groups of permutations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groups of permutations", "i:14"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Sgn",
 ", ",
 ButtonBox["Built-in Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Built-in Morphoids", "i:30"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ShowBodyText",
 ", ",
 "as an option to CayleyTable",
 ", ",
 ButtonBox["Cayley tables",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cayley tables", "i:28"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ShowBodyText",
 ", ",
 "illustration",
 ", ",
 ButtonBox["Cayley tables",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cayley tables", "i:39"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ShowCircle",
 ", ",
 ButtonBox["Working with graphics",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Working with graphics", "i:33"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ShowColoredPermutation",
 ", ",
 ButtonBox["A look at some functions in LabCode",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"A look at some functions in LabCode", "i:38"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ShowFigure",
 ", ",
 ButtonBox["Working with graphics",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Working with graphics", "i:33"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ShowGroupOrders",
 ", ",
 ButtonBox["A look at some functions in LabCode",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"A look at some functions in LabCode", "i:38"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ShowKey",
 ", ",
 "as an option to CayleyTable",
 ", ",
 ButtonBox["Cayley tables",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cayley tables", "i:28"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ShowName",
 ", ",
 "as an option to CayleyTable",
 ", ",
 ButtonBox["Cayley tables",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cayley tables", "i:28"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ShowOperator",
 ", ",
 "as an option to CayleyTable",
 ", ",
 ButtonBox["Cayley tables",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cayley tables", "i:28"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ShowPermutation",
 ", ",
 ButtonBox["Working with graphics",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Working with graphics", "i:33"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ShowSidesText",
 ", ",
 "as an option to CayleyTable",
 ", ",
 ButtonBox["Cayley tables",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cayley tables", "i:28"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SizeLimit",
 ", ",
 "as an option to GenerateGroupoid",
 ", ",
 ButtonBox["GenerateGroupoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"GenerateGroupoid", "i:5"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SizeLimit",
 ", ",
 "as an option to polynomial lists",
 ", ",
 ButtonBox["Miscellaneous functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Miscellaneous functions", "i:48"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SizeLimit",
 ", ",
 "as an option to ToRingoid on matrices",
 ", ",
 ButtonBox["Matrix ringoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix ringoids", "i:67"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SizeOfMatrices",
 ", ",
 ButtonBox["Miscellaneous matrix functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Miscellaneous matrix functions", "i:72"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SL",
 ", ",
 "alternate syntax",
 ", ",
 ButtonBox["Matrix groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix groupoids", "i:71"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SL",
 ", ",
 "as a matrix sub-extension",
 ", ",
 ButtonBox["Matrix groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix groupoids", "i:70"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SL",
 ", ",
 "as a value of the MatrixType option",
 ", ",
 ButtonBox["Individual matrices",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Individual matrices", "i:55"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SLQ",
 ", ",
 ButtonBox["Individual matrices",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Individual matrices", "i:57"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Solve",
 ", ",
 "EAAM usage for polynomials",
 ", ",
 ButtonBox["Solving Equations, Evaluation",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Solving Equations, Evaluation", "i:43"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Sort",
 ", ",
 "as an option to Closure",
 ", ",
 ButtonBox["Subgroups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subgroups", "i:10"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SortGroupoid",
 ", ",
 ButtonBox["Structure of Groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Structure of Groupoids", "i:12"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SpecialLinear",
 ", ",
 ButtonBox["Matrix groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix groupoids", "i:71"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SpecialLinearGroup",
 ", ",
 ButtonBox["Matrix groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix groupoids", "i:71"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Stabilizer",
 ", ",
 ButtonBox["Stabilizers and orbits",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Stabilizers and orbits", "i:20"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Staged",
 ", ",
 "as an option to Closure",
 ", ",
 ButtonBox["Subgroups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subgroups", "i:10"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Structure",
 ", ",
 "as an option to ClosedQ",
 ", ",
 ButtonBox["The four standard functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"The four standard functions", "i:15"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Structure",
 ", ",
 "option for ZMap",
 ", ",
 ButtonBox["Built-in Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Built-in Morphoids", "i:10"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Structure",
 ", ",
 "option to Z",
 ", ",
 ButtonBox["Groupoids based on the integers mod n",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groupoids based on the integers mod n", "i:3"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 StyleBox["Indeterminate", "MR"],
 ", ",
 "as an option to GF",
 ", ",
 ButtonBox["Finite fields",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Finite fields", "i:85"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->{"StyleBox[Indeterminate, MR]", "alpha"}],

Cell[TextData[{
 "SubgroupClosure",
 ", ",
 ButtonBox["Subgroups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subgroups", "i:9"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SubgroupConjugate",
 ", ",
 ButtonBox["Other group properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other group properties", "i:9"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SubgroupGenerated",
 ", ",
 ButtonBox["Subgroups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subgroups", "i:13"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SubgroupGenerated",
 ", ",
 "Visual2 mode",
 ", ",
 ButtonBox["Subgroups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subgroups", "i:14"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SubgroupIntersection",
 ", ",
 ButtonBox["Subgroups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subgroups", "i:17"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SubgroupJoin",
 ", ",
 ButtonBox["Subgroups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subgroups", "i:17"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Subgroupoid",
 ", ",
 ButtonBox["Subgroups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subgroups", "i:5"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SubgroupProduct",
 ", ",
 ButtonBox["Subgroups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subgroups", "i:17"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SubgroupQ",
 ", ",
 ButtonBox["Subgroups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subgroups", "i:7"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SubgroupQ",
 ", ",
 "syntax explanation",
 ", ",
 ButtonBox["Subgroups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subgroups", "i:6"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SubgroupQ",
 ", ",
 "Visual2 mode",
 ", ",
 ButtonBox["Subgroups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subgroups", "i:8"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Subgroups",
 ", ",
 ButtonBox["Subgroups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subgroups", "i:15"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SubgroupUnion",
 ", ",
 ButtonBox["Subgroups",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subgroups", "i:17"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SubringQ",
 ", ",
 ButtonBox["Subrings and ideals",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subrings and ideals", "i:8"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Subrings",
 ", ",
 ButtonBox["Subrings and ideals",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Subrings and ideals", "i:7"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SubsetQ",
 ", ",
 ButtonBox["Working with lists",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Working with lists", "i:31"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SurjectiveQ",
 ", ",
 "as applied to Morphoids",
 ", ",
 ButtonBox["Surjectivity and injectivity",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Surjectivity and injectivity", "i:14"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SwitchStructureTo",
 ", ",
 ButtonBox["Changing the DefaultStructure",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Changing the DefaultStructure", "i:13"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "SymmetricGroup",
 ", ",
 "the family of Groupoids",
 ", ",
 ButtonBox["Groups of permutations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groups of permutations", "i:14"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Symmetric",
 ", ",
 "the family of Groupoids",
 ", ",
 ButtonBox["Groups of permutations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groups of permutations", "i:14"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "TableOfPowers",
 ", ",
 ButtonBox["Finite fields",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Finite fields", "i:87"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "TextCayley",
 ", ",
 ButtonBox["Cayley tables",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cayley tables", "i:40"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Textual",
 ", ",
 "value for Mode option",
 ", ",
 ButtonBox["How to use a Mode",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"How to use a Mode", "i:14"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "TheSet",
 ", ",
 "as an option to CayleyTable",
 ", ",
 ButtonBox["Cayley tables",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cayley tables", "i:28"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "TimesSymbol",
 ", ",
 ButtonBox["Ring related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Ring related functions", "i:8"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ToCycles",
 ", ",
 ButtonBox["Cycles",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cycles", "i:11"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ToFunction",
 ", ",
 "applied to Morphoids",
 ", ",
 ButtonBox["The structure of Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"The structure of Morphoids", "i:7"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ToGroupoid",
 ", ",
 "as applied to matrix extensions",
 ", ",
 ButtonBox["Matrix groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix groupoids", "i:69"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ToOrdinaryPolynomial",
 ", ",
 ButtonBox["Miscellaneous functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Miscellaneous functions", "i:46"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ToPermutation",
 ", ",
 ButtonBox["Representing permutations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Representing permutations", "i:9"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ToRingoid",
 ", ",
 "as applied to matrix extensions",
 ", ",
 ButtonBox["Matrix ringoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix ringoids", "i:67"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ToRules",
 ", ",
 "as applied to permutations",
 ", ",
 ButtonBox["Representing permutations",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Representing permutations", "i:9"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ToRules",
 ", ",
 "EAAM usage, applied to Morphoids",
 ", ",
 ButtonBox["The structure of Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"The structure of Morphoids", "i:7"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ToTranspositions",
 ", ",
 ButtonBox["Other cycle-related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other cycle-related functions", "i:17"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Transpositions",
 ", ",
 ButtonBox["Other cycle-related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other cycle-related functions", "i:16"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Trivial",
 ", ",
 "the Groupoid",
 ", ",
 ButtonBox["Other groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Other groupoids", "i:25"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "TrivialZR",
 ", ",
 "the family of Ringoids",
 ", ",
 ButtonBox["Numeric Rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Numeric Rings", "i:32"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "TwistedZ",
 ", ",
 "the family of Groupoids",
 ", ",
 ButtonBox["Groupoids based on the integers mod n",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groupoids based on the integers mod n", "i:6"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "TwistedZ",
 ", ",
 "when is it a group?",
 ", ",
 ButtonBox["Groupoids based on the integers mod n",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groupoids based on the integers mod n", "i:34"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "U",
 ", ",
 "illustration of its definition",
 ", ",
 ButtonBox["Groupoids based on the integers mod n",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groupoids based on the integers mod n", "i:33"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "UnionNoSort",
 ", ",
 ButtonBox["Working with lists",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Working with lists", "i:31"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "UnitQ",
 ", ",
 "as applied to a Ringoid",
 ", ",
 ButtonBox["Multiplicative properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Multiplicative properties", "i:21"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "UnitQ",
 ", ",
 "as applied to functions over a Ringoid",
 ", ",
 ButtonBox["Function Arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Function Arithmetic", "i:78"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "UnitQ",
 ", ",
 "as applied to matrix extensions",
 ", ",
 ButtonBox["Matrix arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix arithmetic", "i:60"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Units",
 ", ",
 ButtonBox["Multiplicative properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Multiplicative properties", "i:22"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Unity",
 ", ",
 "as applied to functions over a Ringoid",
 ", ",
 ButtonBox["Function Arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Function Arithmetic", "i:78"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Unity",
 ", ",
 "as applied to polynomial extensions",
 ", ",
 ButtonBox["Polynomial arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Polynomial arithmetic", "i:29"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Unity",
 ", ",
 "of a Ringoid",
 ", ",
 ButtonBox["Multiplicative properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Multiplicative properties", "i:21"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "UnityQ",
 ", ",
 "as applied to matrix extensions",
 ", ",
 ButtonBox["Matrix arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix arithmetic", "i:60"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "UT",
 ", ",
 "as a matrix sub-extension",
 ", ",
 ButtonBox["Matrix groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix groupoids", "i:70"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "UT",
 ", ",
 "as a value of the MatrixType option",
 ", ",
 ButtonBox["Individual matrices",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Individual matrices", "i:55"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "UTD",
 ", ",
 "as a matrix sub-extension",
 ", ",
 ButtonBox["Matrix groupoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix groupoids", "i:70"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "UTD",
 ", ",
 "as a value of the MatrixType option",
 ", ",
 ButtonBox["Individual matrices",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Individual matrices", "i:55"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "U",
 ", ",
 "the family of Groupoids",
 ", ",
 ButtonBox["Groupoids based on the integers mod n",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groupoids based on the integers mod n", "i:6"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ValuesHavingGivenNorm",
 ", ",
 ButtonBox["Norm-related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Norm-related functions", "i:29"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Variables",
 ", ",
 "EAAM usage for polynomials",
 ", ",
 ButtonBox["Extensions of Stnrd Mathematica",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Extensions of Stnrd Mathematica", "i:45"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "VarToUse",
 ", ",
 "as an option to CayleyTable",
 ", ",
 ButtonBox["Cayley tables",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cayley tables", "i:28"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Visual2",
 ", ",
 "value for Mode option",
 ", ",
 ButtonBox["How to use a Mode",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"How to use a Mode", "i:14"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "VisualizeMorphoid",
 ", ",
 ButtonBox["Visualizing Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Visualizing Morphoids", "i:25"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "VisualTextShown",
 ", ",
 ButtonBox["Global variables and options",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Global variables and options", "i:2"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Visual",
 ", ",
 "value for Mode option",
 ", ",
 ButtonBox["How to use a Mode",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"How to use a Mode", "i:14"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "WideElements",
 ", ",
 "as an option to FormGroupoid",
 ", ",
 ButtonBox["FormGroupoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormGroupoid", "i:3"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "WideElements",
 ", ",
 "as an option to FormRingoid",
 ", ",
 ButtonBox["FormRingoid",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"FormRingoid", "i:4"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "WideElements",
 ", ",
 "illustration",
 ", ",
 ButtonBox["Cayley tables",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Cayley tables", "i:29"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "WithImages",
 ", ",
 "option for InverseImages",
 ", ",
 ButtonBox["Kernel, Image, and InverseImage(s)",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Kernel, Image, and InverseImage(s)", "i:21"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "WithUnityQ",
 ", ",
 "as applied to functions over a Ringoid",
 ", ",
 ButtonBox["Function Arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Function Arithmetic", "i:78"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "WithUnityQ",
 ", ",
 "as applied to matrix extensions",
 ", ",
 ButtonBox["Matrix arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix arithmetic", "i:60"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "WithUnityQ",
 ", ",
 "as applied to polynomial extensions",
 ", ",
 ButtonBox["Polynomial arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Polynomial arithmetic", "i:29"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "WithUnityQ",
 ", ",
 "as applied to Ringoids",
 ", ",
 ButtonBox["Multiplicative properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Multiplicative properties", "i:21"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Zd",
 ", ",
 "an AbstractAlgebra package",
 ", ",
 ButtonBox["Packages in AbstractAlgebra",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Packages in AbstractAlgebra", "i:3"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ZdAssociatesQ",
 ", ",
 ButtonBox["Basic Zd functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Basic Zd functions", "i:22"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ZdCombineAssociates",
 ", ",
 ButtonBox["Divisibility",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Divisibility", "i:27"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ZdConjugate",
 ", ",
 ButtonBox["Basic Zd functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Basic Zd functions", "i:22"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ZdDivide",
 ", ",
 ButtonBox["Basic Zd functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Basic Zd functions", "i:22"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ZdDividesQ",
 ", ",
 ButtonBox["Divisibility",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Divisibility", "i:25"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ZdDivisors",
 ", ",
 ButtonBox["Divisibility",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Divisibility", "i:25"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ZdIrreducibleQ",
 ", ",
 ButtonBox["Basic Zd functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Basic Zd functions", "i:22"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ZdNorm",
 ", ",
 ButtonBox["Norm-related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Norm-related functions", "i:29"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ZdPossibleNormQ",
 ", ",
 ButtonBox["Norm-related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Norm-related functions", "i:29"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ZdPossibleNorms",
 ", ",
 ButtonBox["Norm-related functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Norm-related functions", "i:29"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ZdQ",
 ", ",
 ButtonBox["Basic Zd functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Basic Zd functions", "i:22"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ZdUnitQ",
 ", ",
 ButtonBox["Basic Zd functions",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Basic Zd functions", "i:22"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Zero",
 ", ",
 "as applied to functions over a Ringoid",
 ", ",
 ButtonBox["Function Arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Function Arithmetic", "i:78"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Zero",
 ", ",
 "as applied to matrix extensions",
 ", ",
 ButtonBox["Matrix arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix arithmetic", "i:60"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Zero",
 ", ",
 "as applied to polynomial extensions",
 ", ",
 ButtonBox["Polynomial arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Polynomial arithmetic", "i:29"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ZeroDivisorQ",
 ", ",
 ButtonBox["Multiplicative properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Multiplicative properties", "i:22"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ZeroDivisorQ",
 ", ",
 "as applied to functions over a Ringoid",
 ", ",
 ButtonBox["Function Arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Function Arithmetic", "i:78"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ZeroDivisorQ",
 ", ",
 "as applied to matrix extensions",
 ", ",
 ButtonBox["Matrix arithmetic",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Matrix arithmetic", "i:60"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ZeroDivisors",
 ", ",
 ButtonBox["Multiplicative properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Multiplicative properties", "i:22"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Zero",
 ", ",
 "of a Ringoid",
 ", ",
 ButtonBox["Additive properties",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Additive properties", "i:17"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Zeros",
 ", ",
 "of a polynomial",
 ", ",
 ButtonBox["Solving Equations, Evaluation",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Solving Equations, Evaluation", "i:43"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Z",
 ", ",
 "functions related to",
 ", ",
 ButtonBox["Groupoids based on the integers mod n",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groupoids based on the integers mod n", "i:7"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ZG",
 ", ",
 "the family of Groupoids",
 ", ",
 ButtonBox["Groupoids based on the integers mod n",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groupoids based on the integers mod n", "i:3"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "ZMap",
 ", ",
 "the family of Morphoids",
 ", ",
 ButtonBox["Built-in Morphoids",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Built-in Morphoids", "i:10"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Z[n, I]",
 ", ",
 ButtonBox["Groupoids based on the integers mod n",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groupoids based on the integers mod n", "i:5"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->{"Z[n, I]", "alpha"}],

Cell[TextData[{
 "Z[n, k]",
 ", ",
 ButtonBox["Groupoids based on the integers mod n",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groupoids based on the integers mod n", "i:5"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->{"Z[n, k]", "alpha"}],

Cell[TextData[{
 "ZR",
 ", ",
 "the family of Ringoids",
 ", ",
 ButtonBox["Groupoids based on the integers mod n",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groupoids based on the integers mod n", "i:3"}],
 ", ",
 ButtonBox["Numeric Rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Numeric Rings", "i:32"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Z",
 ", ",
 "the family of Groupoids",
 ", ",
 ButtonBox["Groupoids based on the integers mod n",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groupoids based on the integers mod n", "i:3"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Z",
 ", ",
 "the family of Ringoids",
 ", ",
 ButtonBox["Numeric Rings",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Numeric Rings", "i:32"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Z",
 ", ",
 "Variations",
 ", ",
 ButtonBox["Groupoids based on the integers mod n",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groupoids based on the integers mod n", "i:4"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"],

Cell[TextData[{
 "Zx",
 ", ",
 "the family of Groupoids",
 ", ",
 ButtonBox["Groupoids based on the integers mod n",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Groupoids based on the integers mod n", "i:6"}]
}], "Index",
 ShowCellBracket->False,
 CellTags->"alpha"]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.2 Objects listed by packages", "Subsection",
 FontFamily->"Times",
 CellTags->{"pack", "i:5"}],

Cell[TextData[{
 "Below is just a ",
 StyleBox["list",
  FontSlant->"Italic"],
 " of the names in the given package. For more details, either go to the \
preceding section  (",
 ButtonBox["6.3.1 Objects listed alphabetically",
  BaseStyle->"AddOnsLink",
  ButtonData:>{"Alphabetically", "Alphabetically"}],
 ") and click on the desired name, or go to the Master Index (in the Help \
Browser) and type in the desired name. In both cases, you will be taken to \
the portion of the documentation that provides additional information."
}], "Text",
 CellTags->{
  "pack", "Core", "FiniteFields", "Groupoids", "GroupProperties", "Joint", 
   "LabCode", "Morphisms", "RingExtensions", "Ringoids", "RingProperties", 
   "Zd"}],

Cell[CellGroupData[{

Cell["6.3.2.1 Core", "Subsubsection",
 CellTags->{"Core", "i:7", "pack"}],

Cell["\<\
Addition, Adjoin, Any, AssociativeQ, BackgroundColors, Both, \
CartesianProduct, CayleyForm, CayleyTable, ClosedQ, CloseSets, Closure, \
ComplementNoSort, Computational, DefaultStructure, Domain, DrawNgon, \
ElementQ, Elements, ElementsQ, ElementToKey, ElementToPower, Form, \
FormatElements, FormatOperator, FormGroupoid, FormGroupoidByTable, \
FormRingoid, GaussianIntegersAdditive, GaussianIntegersMultiplicative, \
GenerateGroupoid, GeneratingSet, Generators, Group, GroupIdentity, GroupInfo, \
GroupInverse, Groupoid, GroupoidDescription, GroupoidName, GroupQ, Groups, \
HasIdentityQ, HasInversesQ, HasLeftIdentityQ, HasRightIdentityQ, \
HeadingsColored, Inverses, InvertibleQ, IsAGroup, IsARing, KeyForm, \
KeyToElement, KSubsets, LeftIdentity, LeftInverse, LeftInvertibleQ, \
LeftToRight, MaxElementsToList, MonoidQ, Multiplication, NextStage, \
NonAssociatingTriples, NonIdentity, Operation, OperatorSymbol, Ordering, \
Output, PermutationInverse, PermutationQ, PlusSymbol, PreviousStage, \
ProbableGroupQ, ProperSubsetQ, RandomAssociativeQ, RandomElement, \
RandomElements, Randomize, RandomPermutation, ReorderGroupoid, Replacement, \
ReportIterations, RightIdentity, RightInverse, RightInvertibleQ, RightToLeft, \
Ring, RingInfo, Ringoid, RingoidDescription, RingoidName, Rings, SameSetQ, \
SelectFrom, SemiGroupQ, ShowBodyText, ShowCircle, ShowFigure, ShowKey, \
ShowName, ShowOperator, ShowPermutation, ShowSidesText, Size, SizeLimit, \
SortGroupoid, Staged, Structure, SubgroupClosure, SubgroupQ, SubsetQ, \
SwitchStructureTo, TextCayley, Textual, TheSet, TimesSymbol, ToPermutation, \
UnionNoSort, VarToUse, Visual, VisualTextShown, Visual2, WideElements, Z, ZG, \
ZR\
\>", "Text",
 PageWidth->WindowWidth,
 InitializationCell->False,
 ShowSpecialCharacters->False,
 CellTags->{"Core", "pack"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.2.2 FiniteFields", "Subsubsection",
 CellTags->{"FiniteFields", "i:8", "pack"}],

Cell["\<\
AdditiveToMultiplicative, ExtensionDegree, FieldIrreducible, GaloisFieldQ, \
GF, IrreduciblePolynomial, IrreduciblePolyOverZpQ, MultiplicativeToAdditive, \
PowerList, PrimitivePolynomials, TableOfPowers\
\>", "Text",
 PageWidth->WindowWidth,
 InitializationCell->False,
 ShowSpecialCharacters->False,
 CellTags->{"FiniteFields", "pack"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.2.3 Groupoids", "Subsubsection",
 CellTags->{"Groupoids", "i:9", "pack"}],

Cell["\<\
AsIJK, AsMatrices, AsSymbols, Cyclic, CyclicGroup, Dihedral, DihedralGroup, \
ESG, FirstTaker, GaussianUnits, Generator, IntegerUnits, JoinDivisors, \
Klein4, MaxTaker, MeetDivisors, MinTaker, MixedDivisors, \
PermutationComposition, QuaternionGroup, RandomGroupoid, Ref, RefSym, \
RootsOfUnity, Rot, RotRef, RotSym, Trivial, TwistedZ, U, Zx\
\>", "Text",
 PageWidth->WindowWidth,
 InitializationCell->False,
 ShowSpecialCharacters->False,
 CellTags->{"Groupoids", "pack"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.2.4 GroupProperties", "Subsubsection",
 CellTags->{"GroupProperties", "i:10", "pack"}],

Cell["\<\
Centralizer, Commutator, Commutators, CommutatorSubgroup, ConjugacyClass, \
CyclicGenerators, CyclicQ, CyclicSubgroups, ElementConjugate, EqualGroupoidQ, \
GroupCenter, GroupExponent, Normalizer, OrderOfAllElements, OrderOfElement, \
Orders, SubgroupConjugate, SubgroupIntersection, SubgroupJoin, Subgroupoid, \
SubgroupProduct, Subgroups, SubgroupUnion\
\>", "Text",
 PageWidth->WindowWidth,
 InitializationCell->False,
 ShowSpecialCharacters->False,
 CellTags->{"GroupProperties", "pack"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.2.5 Joint", "Subsubsection",
 CellTags->{"Joint", "i:11", "pack"}],

Cell["\<\
AbelianQ, Canonical, CommutativeQ, CosetLists, Cosets, CosetToList, \
DirectProduct, DirectSum, DisguiseGroupoid, DisguiseRingoid, ElementToCoset, \
FactorGroup, Index, LeftCoset, LeftCosets, NonCommutingPairs, NormalQ, NS, \
QuotientGroup, Representatives, RightCoset, RightCosets, SubgroupGenerated\
\>", "Text",
 PageWidth->WindowWidth,
 InitializationCell->False,
 ShowSpecialCharacters->False,
 CellTags->{"Joint", "pack"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.2.6 LabCode", "Subsubsection",
 CellTags->{"LabCode", "i:12", "pack"}],

Cell["\<\
CollectOrders, LG, ListOperationPreservingElements, ShowGroupOrders, ShowOne \
(plus many others designed only for the labs)\
\>", "Text",
 PageWidth->WindowWidth,
 InitializationCell->False,
 ShowSpecialCharacters->False,
 CellTags->{"LabCode", "pack"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.2.7 Matrices", "Subsubsection",
 CellTags->{"Matrices", "i:13", "pack"}],

Cell["\<\
Adjoint, AntiCommutingMatricesQ, CommutingMatricesQ, ComplexMatrixQ, \
DetAdjoint, Diag, DiagonalMatrices, DiagQ, GeneralLinear, GeneralLinearGroup, \
GL, GLQ, HermitianQ, IntegerMatrixQ, LT, LTD, Mat, MatA, MatM, MatricesOver, \
MatrixConjugate, MatrixDelete, MatrixOperation, MatrixOverQ, MatrixTrace, \
MatrixType, OrthogonalQ, RandomMatrix, RationalMatrixQ, RealMatrixQ, \
SizeOfMatrices, SkewHermitianQ, SkewSymmetricQ, SL, SLQ, SpecialLinear, \
SpecialLinearGroup, SymmetricQ, ToGroupoid, ToRingoid, UnitaryQ, UT, UTD\
\>", "Text",
 PageWidth->WindowWidth,
 InitializationCell->False,
 ShowSpecialCharacters->False,
 CellTags->{"Matrices", "pack"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.2.8 Morphisms", "Subsubsection",
 CellTags->{"Morphisms", "i:14", "pack"}],

Cell["\<\
Aut, Automorphism, AutomorphismGroup, Cautious, Codomain, ColorCodomain, \
ColorDomain, EqualMorphoidQ, Fiber, FormatFunction, FormMorphoid, \
FormMorphoidSetup, FunctionForm, HomomorphismQ, Image, InducedCanonical, \
InducedIsomorphism, InjectiveQ, Inn, InnerAutomorphism, \
InnerAutomorphismGroup, InverseImage, InverseImages, IsomorphismQ, Kernel, \
MorphismQ, Morphoid, MorphoidComposition, MorphoidFunction, MorphoidRules, \
OneToOneQ, OntoQ, PreservesQ, PrintMessage, ProbableMorphismQ, Rules, \
SamplePairs, SampleSize, Sgn, SurjectiveQ, ToFunction, VisualizeMorphoid, \
WithImages, ZMap\
\>", "Text",
 PageWidth->WindowWidth,
 InitializationCell->False,
 ShowSpecialCharacters->False,
 CellTags->{"Morphisms", "pack"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.2.9 Permutations", "Subsubsection",
 CellTags->{"Permutations", "i:15", "pack"}],

Cell["\<\
A, Alternating, AlternatingGroup, Cycle, CycleAs, DefaultOrder, \
DisjointCyclesQ, EvenPermutationQ, ExtendPermutation, FixQ, \
FormGroupoidFromCycles, FromCycles, IndexLimit, MultiplyCycles, \
MultiplyPermutations, Normalize, OddPermutationQ, Orbit, Parity, \
PermutationGroup, PermutationImage, PermutationMatrix, PermutationToPower, \
PermuteColoredSquares, ProductOrder, RandomColoredSquares, S, \
SamePermutationQ, ShowColoredPermutation, SideBySideMatrices, Stabilizer, \
Symmetric, SymmetricGroup, ToCycles, ToTranspositions\
\>", "Text",
 PageWidth->WindowWidth,
 InitializationCell->False,
 ShowSpecialCharacters->False,
 CellTags->{"Permutations", "pack"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.2.10 RingExtensions", "Subsubsection",
 CellTags->{"RingExtensions", "i:16", "pack"}],

Cell["\<\
BaseRing, EvaluationInExtension, ExtensionType, FlexibleEntering, Func, \
FuncRing, FunctionsOver, FuncToRules, IgnoreIndeterminate, Matrices, \
ModulusPolynomial, Monomial, Poly, PolynomialEvaluation, \
PolynomialsOfDegreeN, PolynomialsOver, PolynomialsUpToDegreeN, PolyQ, \
PolyRing, PolyToFunction, PowersIncrease, RingExtension, TestFunction, \
ToOrdinaryPolynomial, Zeros\
\>", "Text",
 PageWidth->WindowWidth,
 InitializationCell->False,
 ShowSpecialCharacters->False,
 CellTags->{"RingExtensions", "pack"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.2.11 Ringoids", "Subsubsection",
 CellTags->{"Ringoids", "i:17", "pack"}],

Cell["BooleanRing, FormRingoidByTable, LatticeRing, TrivialZR", "Text",
 PageWidth->WindowWidth,
 InitializationCell->False,
 ShowSpecialCharacters->False,
 CellTags->{"Ringoids", "pack"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.2.12 RingProperties", "Subsubsection",
 CellTags->{"RingProperties", "i:18", "pack"}],

Cell["\<\
AdditiveGroupoid, AGroupoid, Annihilator, CayleyTables, Characteristic, \
ClosedDiffQ, ClosedPlusQ, ClosedTimesQ, ComplexToPoint, DistributiveQ, \
EisensteinsCriterionQ, FactorRing, FieldQ, GaussianIntegerQ, HasNegativeQ, \
HasUnityQ, HasZeroQ, IdealQ, IdempotentQ, Idempotents, IntegerLatticeGrid, \
IntegralDomainQ, J, LeftDistributiveQ, LeftIdealQ, LowerDegreeOK, \
MaximalIdealQ, MGroupoid, ModpIrreducibilityQ, Monic, MultipleOfElement, \
MultiplicationTable, MultiplicativeGroupoid, MultiplicativeInverse, \
NegationOf, NilpotentDegree, NilpotentQ, Nilpotents, NonUnity, NonZero, \
NonZeroMGroupoid, PrimeIdealQ, PrincipalIdeal, ProbableRingQ, QuotientRing, \
RandomDistributiveQ, RationalRootCandidates, RationalRootTheorem, \
RightDistributiveQ, RightIdealQ, RingQ, RingSolve, SelectBaseElementsFrom, \
SubringQ, UnitQ, Units, Unity, WithUnityQ, Zero, ZeroDivisorQ, ZeroDivisors\
\>", "Text",
 PageWidth->WindowWidth,
 InitializationCell->False,
 ShowSpecialCharacters->False,
 CellTags->{"RingProperties", "pack"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.2.13 Zd", "Subsubsection",
 CellTags->{"Zd", "i:19", "pack"}],

Cell["\<\
Associates, Combine, DividesQ, DivisorsComplete, IntegerDivisors, Negations, \
NonTrivialOnly, Products, Radical, ValuesHavingGivenNorm, ZdAssociatesQ, \
ZdCombineAssociates, ZdConjugate, ZdDivide, ZdDividesQ, ZdDivisors, \
ZdIrreducibleQ, ZdNorm, ZdPossibleNormQ, ZdPossibleNorms, ZdQ, ZdUnitQ\
\>", "Text",
 PageWidth->WindowWidth,
 InitializationCell->False,
 ShowSpecialCharacters->False,
 CellTags->{"Zd", "pack"}]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
 "6.3",
 ".3 Objects extended from standard ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " "
}], "Subsection",
 FontFamily->"Times",
 CellTags->{"ext", "i:20"}],

Cell["\<\
Center, Coefficient, CoefficientList, Conjugate, D, Degree, Det, Dot, Equal, \
Exponent, GaussianIntegers, Graphics, GraphicsArray, Identity, Indeterminate, \
InterpolatingPolynomial, Inverse, MatrixPower, Mode, Order, Partition, \
Permutations, PolynomialDivision, PolynomialGCD, PolynomialLCM, \
PolynomialQuotient, PolynomialRemainder, ToRules\
\>", "Text",
 CellTags->"ext"]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.4 Usage statements alphabetically", "Subsection",
 FontFamily->"Times",
 CellTags->{"usagealpha", "i:22"}],

Cell["\<\
A::usage = \"A[n] returns the group of even permutations on the set {1,2,..n} \
under composition. See Alternating for more details.\";

AGroupoid::usage = \"AGroupoid[R] returns the additive Groupoid associated \
with the Ringoid R. This is equivalent to AdditiveGroupoid[R].\";

AbelianQ::usage = \"AbelianQ[G] returns True if the Groupoid G is Abelian \
(commutative), and False otherwise. This is equivalent to CommutativeQ[G].\";

AddPermToGroup::usage = \"AddPermToGroup[p] will add the permutation p to the \
list of alleged symmetries (which is called MySymmetryGroup). Note that p can \
be in the form of a list ({1,3,4,2}) or a list of rules ({1\[Rule]1, \
2\[Rule]3, 3\[Rule]4, 4\[Rule]2}).\";

Addition::usage = \"Addition[S] is the addition operator in the Ringoid S. If \
S is a Groupoid, Addition[S] is simply the Groupoid's operation. Given an \
extension Ext of a ring, Addition[Ext] is the addition in this extension. \
Addition is also a value for the Operation option that is used in some ring \
functions.\";

AdditiveGroupoid::usage = \"AdditiveGroupoid[R] returns the additive Groupoid \
of the ring R. A shortcut is AGroupoid[R].\";

AdditiveToMultiplicative::usage = \"AdditiveToMultiplicative[R, add] returns \
the multiplicative form of the element add, currently given in additive form, \
from the ringoid (typically a Galois field) R.\";

Adjoin::usage = \"Adjoin[list, num] returns the elements in list with num \
adjoined. If num is the nth root of rad, then the set of all 'polynomials' of \
degree less than n in the 'indeterminate' rad with coefficients from list is \
returned. If num is anything else, the function fails. Adjoin[S, num], for a \
structured set S, is equivalent to Adjoin[Elements[S], num]. Adjoin[list, \
ind, deg] returns the set of polynomials in the indeterminate ind of degree \
deg (or less) with coefficients from list. Adjoin[S, ind, deg], for a \
structured set S, is equivalent to Adjoin[Elements[S], ind, deg].\";

Adjoint::usage = \"Adjoint[A] returns Transpose[MatrixConjugate[A]], the \
transpose of the conjugate of a matrix. (For the usage of adjoint as it \
relates to determinants, see DetAdjoint.)\";

Alternating::usage = \"Alternating[n] returns the group of even permutations \
on the set {1,2,..n} under composition. There are two options for this \
function, ProductOrder and IndexLimit. Since the elements of this group are \
permutations, one can specify the order that the product is taken. See \
ProductOrder for more information, including the values that can be used. \
IndexLimit defaults to 6 and indicates the upper limit for the value of the \
index n.\";

AlternatingGroup::usage = \"AlternatingGroup[n] - see Alternating.\";

Annihilator::usage = \"Annihilator[R, S] returns the annihilator of S in R. \
This consists of all elements r in R such that r s = Zero[R] for all elements \
s in S.\";

AntiCommutingMatricesQ::usage = \"AntiCommutingMatricesQ[R, A, B] returns \
True or False depending on whether the matrices A and B over the Ringoid R \
anti-commute in the sense that A B = - B A. \
AntiCommutingMatricesQ[MatricesOver[R,{n,n}], A, B] works similarly. For \
matrices with numeric entries (over Integers, Rationals, Reals or Complex), \
AntiCommutingMatricesQ[A, B] works similarly.\";

Any::usage = \"Any is a value for the SelectFrom option for RandomElement and \
RandomElements. This value allows any element to be returned. Alternatively, \
one may use NonIdentity (or NonZero or NonUnity when working with rings).\";

AsIJK::usage = \"AsIJK is a value for the Form option for the QuaternionGroup \
function. This specifies that the quaternion group is to be represented by \
the elements {\[PlusMinus] 1, \[PlusMinus] I, \[PlusMinus] JJ, \[PlusMinus] \
KK}. (Note that K is a reserved symbol in version 3 and J is used with \
rings), with a set of relations governing these elements.\";

AsMatrices::usage = \"AsMatrices is a value for the Form option for the \
QuaternionGroup function. This specifies that the quaternion group is to be \
represented by 2-by-2 matrices. This is the default value.\";

AsSymbols::usage = \"AsSymbols is a value for the Form option for the \
QuaternionGroup function. This specifies that the quaternion group is to be \
generated by the symbols {a, b} subject to a set of relations governing these \
symbols. In this form, the elements used are given in the form of Mathematica \
strings.\";

Associates::usage = \"Associates is a value for the Combine option of \
IntegerDivisors and ZdDivisors. With this value, the divisors of n are \
grouped in pairs {a, b} such that a and b are associates.\";

AssociativeQ::usage = \"AssociativeQ[S] returns True if the structure S is \
associative, and False otherwise. When used with rings, one has the Operation \
option, which can have the value Addition, Multiplication or Both.\";

Aut::usage =\"Aut[G] is a shortcut for AutomorphismGroup[G].\";

Automorphism::usage=\"Automorphism[G, a \[Rule] b] forms the automorphism \
determined by the single rule a \[Rule] b, if a and b are both generators of \
the cyclic group G.\";

AutomorphismGroup::usage=\"AutomorphismGroup[G] returns the group of \
automorphisms of a cyclic group G.\";

BackgroundColors::usage = \"BackgroundColors is a global constant consisting \
of a string of colors from the Graphics`Colors` package that are used for \
colors in the Cayley table and other similar places. Although the colors are \
given in RGBColor format, the default list for this variable uses the \
following names of colors:\\n {Yellow, Orange, Violet, Blue, Mint, Turquoise, \
EmeraldGreen, GreenDark, Pink, BlueLight, Banana, Green, Brown, Gray, Red, \
Purple, CadmiumYellow, Maroon, Navy, Salmon, Aquamarine, Indigo, Lavender, \
Antique, Bisque, Burlywood, Eggshell, Khaki, BlueViolet, CadmiumOrange, \
CadmiumRedDeep, Cerulean, Chartreuse, Cyan, DeepPink, Magenta, OrangeRed, \
Peacock, SkyBlueDeep, TurquoiseDark, Ultramarine}\";

BaseRing::usage=\"BaseRing[R] returns the base ring of an extension or \
quotient ring. If p is a polynomial, BaseRing[p] returns the underlying base \
ring for the polynomial p.\";

BooleanRing::usage = \"BooleanRing[n] constructs the Boolean Ring consisting \
of the set of subsets of {1, 2, ..., n} with the operations symmetric \
difference and intersection. BooleanRing[B] constructs the ring with subsets \
of the list B.\";

Both::usage = \"Both is a value for the Operation option used in various ring \
functions.\";

CInf::usage = \"Special symbol used for this lab.\";

Canonical::usage = \"Canonical is a value for the Representatives option for \
the QuotientGroup (and QuotientRing) function. This value causes \
QuotientGroup to use the 'first' element in the coset.\";

CartesianProduct::usage = \"CartesianProduct[els1, els2] returns the \
Cartesian product, as a list of ordered pairs, of the two sets  els1 and \
els2. CartesianProduct[els1, els2, Partition \[Rule] True] partitions the \
ordered pairs using the Partition function, cut to the length of els2. \
CartesianProduct[ListOfLists] returns the Cartesian product of the lists of \
elements in ListOfLists.\";

Cautious::usage=\"Cautious is an option for IsomorphismQ, indicating whether \
MorphismQ (using value True) or ProbableMorphismQ (using value False) should \
be used. The default value is False.\";

CayleyForm::usage = \"CayleyForm is an option for CayleyTable (and functions \
that form Groupoids or Ringoids) to indicate whether the elements in the \
Cayley table should be displayed in InputForm, OutputForm or some other form. \
The default value is OutputForm.\";

CayleyTable::usage = \"CayleyTable[G] returns the Cayley table for the \
structure G colored with a different color for each element in G. If it is \
desired that Elements[G] be reordered, then CayleyTable[G, TheSet \[Rule] \
NewOrder] will return a new Cayley table according to the new ordering of the \
elements as found in the list NewOrder. When used with rings, the Operation \
option can be used, which can have the value Addition, Multiplication or \
Both. Other options specific to CayleyTable (with the default value given in \
parentheses) are HeadingsColored (True), ShowOperator (True), ShowName \
(True), ShowBodyText (True), ShowSidesText (True), ShowKey (True), VarToUse \
('g'), KeyForm (InputForm), and CayleyForm (InputForm). \
CayleyTable[{G1,G2,..Gn},opts] returns CayleyTable[G1,opts], \
CayleyTable[G2,opts] and so on. Multiple CayleyTables can also be obtained by \
using the following variant forms: CayleyTable[{G1,G2,..Gn}, {opts1, opts2, \
.. optsn}] (optsi applies to Gi) and CayleyTable[{{G1, opts1}, {G2, \
opts2},..{Gn, optsn}}] (optsi applies to Gi).\";

CayleyTables::usage = \"CayleyTables[R] returns the Cayley tables (in double \
array form), for the additive and multiplicative Groupoids associated with \
the Ringoid R. CayleyTables[R, Mode \[Rule] Visual] returns a graphical view \
of these tables. See CayleyTable for a description of the available \
options.\";

Center::usage = \"Center[G] returns the center of the group G. This is \
identical to GroupCenter. \\nThe standard (built-in) usage still exists: \
Center is used to specify alignment in printforms such as ColumnForm and \
TableForm.\";

Centralizer::usage = \"Centralizer[G, g] returns the centralizer of g in the \
group G. Centralizer[G, H] returns the centralizer of the subgroup H in the \
group G.\";

Characteristic::usage = \"Characteristic[R] returns the characteristic of the \
structure R.\";

CloseSets::usage = \"CloseSets[list1, list2, op] returns a list of all the \
distinct elements obtained by applying the operation op on the Cartesian \
product of list1 and list2]\";

ClosedDiffQ::usage = \"ClosedDiffQ[R, S] returns True if S is closed with \
respect to subtraction in the structure R, and False otherwise.\";

ClosedPlusQ::usage = \"ClosedPlusQ[R, S] returns True if S is closed with \
respect to addition in the structure R, and False otherwise.\";

ClosedQ::usage = \"ClosedQ[S] returns True if the set of elements in the \
structure S is closed under its operation, and False otherwise. Additionally, \
ClosedQ[S, H] determines whether H is a closed subset of the structure S. \
When used with rings, the Operation option can be used, which can have the \
value Addition, Multiplication or Both.\";

ClosedTimesQ::usage = \"ClosedTimesQ[R, S] returns True if S is closed with \
respect to multiplication in the structure R, and False otherwise.\";

Closure::usage = \"Closure[G, H] returns the subgroup of G generated by the \
elements in the set H (assuming H is a subset of G or a Groupoid whose \
elements are a subset of G). The option ReportIterations (defaulting to \
False) indicates whether the result of each iteration is also returned. The \
option Staged (defaulting to False), applicable if Mode \[Rule] Visual is \
used, indicates whether or not the graphics are shown one stage at a time or \
they are all display at once. When set to True, NextStage[Closure] returns \
the next iteration and PreviousStage[Closure] returns the previous iteration. \
(Adding an integer k as a second parameter to either NextStage or \
PreviousStage specifies how many steps forward or backwards to take.) The \
option Sort, when set to False (default), returns the elements in the order \
they are generated, while when set to True, returns the elements sorted. When \
using the Visual mode, Output \[Rule] GraphicsArray causes the graphics to be \
placed in array form, rather than being presented serially.\";

Codomain::usage = \"Codomain[f] returns the structure used in the image of \
the Morphoid f.\";

Coefficient::usage = \"Coefficient[poly, ind, n], given a polynomial over \
some ring in the indeterminate ind, returns the coefficient of ind^n. \
Coefficient[poly, n] works similarly, without the indeterminate needing to be \
specified. \\nThe standard (built-in) usage still exists: Coefficient[expr, \
form] gives the coefficient of form in the polynomial expr. Coefficient[expr, \
form, n] gives the coefficient of form^n in expr.\";

CoefficientList::usage = \"CoefficientList[poly] returns the list of \
coefficients used in the polynomial poly over some ring R. Note that these \
are returned in the order as if PowersIncrease \[Rule] RightToLeft was given. \
In other words, CoefficientList[x^2 + 2x + 3] returns {3,2,1}. \\nThe \
standard (built-in) usage still exists: CoefficientList[poly, var] gives a \
list of coefficients of powers of var in poly, starting with power 0. \
CoefficientList[poly, {var1, var2, ...}] gives a matrix of coefficients of \
the vari.\";

CollectOrders::usage = \"CollectOrders[G], when given the output of the \
function OrderOfAllElements, will organize the data in the form {p, A} where \
p is one of the orders of the elements g in the Groupoid G and A is the set \
of all elements from G with the order being p.\";

ColorCodomain::usage = \"ColorCodomain is an option for the VisualizeMorphoid \
function. By specifying ColorCodomain \[Rule] {{color1, cod1}, {color2, \
cod2},...}, the arrows to the codomain element codi will be colored colori. \
Note that these requests supersede those requests from the ColorDomain \
option, if an arrow is requested to be colored by both ColorDomain and \
ColorCodomain.\";

ColorDomain::usage = \"ColorDomain is an option for the VisualizeMorphoid \
function. By specifying ColorDomain \[Rule] {{color1, dom1}, {color2, \
dom2},...}, the arrow from domain element domi will be colored colori, unless \
superseded by a color request by the ColorCodomain option.\";

Combine::usage = \"Combine is an option name for both IntegerDivisors and \
ZdDivisors. Its default value is False, which means the divisors are not \
grouped in any fashion. Other values are Products, Associates, or \
Negations.\";

CommutativeQ::usage = \"CommutativeQ[S] returns True if the structure S is \
commutative, and False otherwise. When S is a group, this is identical to \
AbelianQ[S]. When used with rings, one has the Operation option, which can \
take on the values Addition, Multiplication or Both.\";

Commutator::usage = \"Commutator[G, x, y] returns the commutator \
xyx^(-1)y^(-1) in the Groupoid G.\";

CommutatorSubgroup::usage = \"CommutatorSubgroup[G] returns the commutator \
subgroup of the Groupoid G generated by the commutators of G.\";

Commutators::usage = \"Commutators[G] returns the complete set of commutators \
in the Groupoid G.\";

CommutingMatricesQ::usage = \"CommutingMatricesQ[R, A, B] returns True or \
False depending on whether the matrices A and B commute over the Ringoid R. \
CommutingMatricesQ[MatricesOver[R,{n,n}], A, B] works similarly. For matrices \
with numeric entries (over Integers, Rationals, Reals or Complex), \
CommutingMatricesQ[A, B] works similarly.\";

ComplementNoSort::usage = \"ComplementNoSort[eall, e1, e2, ...] gives the \
elements in eall which are not in any of the ei. This is similar to \
Complement except the returned values are NOT sorted as they are with \
Complement.\";

CompleteGroupQ::usage = \"CompleteGroupQ[] will return True or False \
depending on whether or not the list of alleged symmetries found in \
MySymmetryGroup is the complete actual symmetry group. Other messages may be \
generated as well, if incomplete or in error.\";

ComplexMatrixQ::usage = \"ComplexMatrixQ[A] returns True or False depending \
on whether the matrix A has all of its entries being complex numbers (in the \
mathematical sense - entries can be Integer, Rational, Algebraic, Real, or \
Complex).\";

ComplexToPoint::usage = \"ComplexToPoint[z] returns {Re[z], Im[z]} given any \
complex number z.\";

Computational::usage = \"Computational is the default setting for the Mode \
option for most functions. When Mode \[Rule] Computational is set, the \
function returns the desired computation with no textual or visual \
information given.\";

ConjugacyClass::usage = \"ConjugacyClass[G, h] returns the conjugacy class of \
the element h in G.\";

Conjugate::usage = \"Conjugate[G, h, x] returns the element x h x^(-1) in the \
Groupoid G. Additionally, Conjugate[G, H, x] returns the set x H x^(-1) for \
the subgroup H of the group G. \\nThe standard (built-in) usage still exists: \
Conjugate[z] gives the complex conjugate of the complex number z. \\n(Note \
that the Listable attribute has been turned off.)\";

CosetLists::usage = \"CosetLists is a value for the Form option of \
QuotientGroup and QuotientRing. With this option, the output is a list of the \
cosets in list form.\";

CosetToList::usage = \"CosetToList[G, coset] returns the coset (represented \
as a list) in the quotient group/ring corresponding to the coset represented \
in the form g + NS (or g NS).\";

Cosets::usage = \"Cosets is a value for the Form option of QuotientGroup and \
QuotientRing. This causes the elements to be written as cosets of the form \
gNS or g + NS, where NS represents the normal subgroup (or ideal for \
rings).\";

Cycle::usage = \"Cycle[e1, e2, ...] represents an object that is a cycle of a \
permutation. Cycle is also a value for the CycleAs option of the ToCycles and \
FromCycles functions.\";

CycleAs::usage = \"CycleAs is an option for ToCycles and FromCycles that \
indicates whether a cycle is given as a list or with the head Cycle. In these \
packages, the default value is Cycle; to conform with the \
DiscreteMath`Permutations` package's use, use the value List.\";

Cyclic::usage = \"Cyclic[n] returns the cyclic group of order n with the \
default generator the string 'g'. Cyclic[n, Generator \[Rule] gen] returns \
the same group but written with generator gen (which could be a string or a \
symbol with no value). Cyclic[n, k] returns the Groupoid generated by g^k.\";

CyclicGenerators::usage = \"CyclicGenerators[G] returns a list of elements \
that are generators for the cyclic group G.\";

CyclicGroup::usage = \"CyclicGroup[n] - see Cyclic.\";

CyclicQ::usage = \"CyclicQ[G] returns True if the Groupoid G is cyclic, and \
False otherwise.\";

CyclicSubgroups::usage = \"CyclicSubgroups[G] returns the list of the cyclic \
subgroups of the group G.\";

D1Prod::usage = \"Special symbol used for this lab.\";

D2Prod::usage = \"Special symbol used for this lab.\";

D::usage = \"D[n] returns the dihedral group of index n with order 2n. See \
Dihedral for more information.\\nThe standard (built-in) usage still exists: \
D[f, x] gives the partial derivative of f with respect to x. D[f, {x, n}] \
gives the nth partial derivative with respect to x. D[f, x1, x2, ...] gives a \
mixed derivative.\";

DefaultOrder::usage = \"DefaultOrder is a global variable that contains the \
order that permutations are to be multiplied. It starts out with the value \
RightToLeft, until changed by an option or directly.\";

DefaultStructure::usage = \"DefaultStructure is a global variable that has \
one of two values, Group or Ring. This value indicates what the default \
assumption is for various functions that have meanings for both groups and \
rings. For these functions, this default value can always be temporarily \
overridden by using the option Structure \[Rule] Group or Structure \[Rule] \
Ring. This variable can be changed manually or by using the function \
SwitchStructureTo.\";

Degree::usage = \"Degree[PolynomialsOver[R], p] determines the degree of the \
polynomial p when viewed as an element in the ring of polynomials over the \
Ringoid R. Degree[p] assumes p is defined in some ring of polynomials. \\nThe \
standard (built-in) usage still exists: Degree gives the number of radians in \
one degree. It has a numerical value of Pi/180.\";

Det::usage=\"Det[R, A] returns the determinant of the square matrix A over \
the Ringoid R. Det[MatricesOver[R,{n,n}],A] is equivalent to Det[R, A]. \
\\nThe standard (built-in) usage still exists: Det[m] gives the determinant \
of the square matrix m.\";

DetAdjoint::usage = \"DetAdjoint[A] returns the adjoint of a matrix A, which \
is defined as (-1)^(i+j) Det[Transpose[Bij]], where Bij is the matrix Aij \
with the ith row and jth column removed.\";

Diag::usage = \"Diag[n, R] (alternately, Diag[R, n]) returns the extension of \
invertible n-by-n diagonal matrices over the Ringoid R.\";

DiagQ::usage = \"DiagQ[R, A] returns True or False depending on whether the \
matrix A over the Ringoid R is in Diag[R, n] (where A is an n-by-n \
matrix).\";

DiagonalMatrices::usage = \"DiagonalMatrices[n, R] (alternately, \
DiagonalMatrices[R, n]) - see Diag.\";

Dihedral::usage = \"Dihedral[n] returns the dihedral group of index n with \
order 2n. By default, the generators are indicated by Rot (for the smallest \
angle of rotation) and Ref (for any reflection). D[n, Form \[Rule] \
Permutations] uses the permutations corresponding to Rot and Ref; the default \
is Form \[Rule] RotRef. D[n, RotSym \[Rule] newsy1, RefSym \[Rule] newsy2] \
uses the symbols newsy1 and newsy2 for Rot and Ref respectively. Alternate \
names for Dihedral are D and DihedralGroup.\";

DihedralGroup::usage = \"DihedralGroup[n] - see Dihedral.\";

DirectProduct::usage = \"DirectProduct[S1, S2] returns the direct product of \
the structured sets (Groupoids or Ringoids) S1 and S2. (Any number of \
arguments can be used.)\";

DirectSum::usage = \"DirectSum[S1, S2] returns the direct sum of the \
structured sets (Groupoids or Ringoids) S1 and S2. (Any number of arguments \
can be used.)\";

DisguiseGroupoid::usage = \"DisguiseGroupoid[G] returns the Groupoid G with \
the elements of G replaced with the strings 'a', 'b', etc. The purpose is to \
present a generic Groupoid without any indication of the form of the elements \
or operation. DisguiseGroupoid[G, rules] does the same except that rules is a \
list of Rules which specify how the matching should occur. Adding the option \
Randomize \[Rule] True will randomize the original elements before the rules \
are assigned; the default for this option is False.\";

DisguiseRingoid::usage=\"DisguiseRingoid[R] returns the Ringoid R with the \
elements of R replaced with the strings 'a', 'b', etc. The purpose is to \
present a generic ring without any indication of the form of the elements or \
operation. Adding the option Randomize \[Rule] True will randomize the \
original elements in the Ringoid; the default for this option is False. One \
can also add one's own mapping rules, as in DisguiseGroupoid.\";

DisjointCyclesQ::usage = \"DisjointCyclesQ[cyclist] returns True if the \
cycles in cyclist are disjoint, and False otherwise. The cycles in cyclist \
can be either in List form or using Cycle notation. Also, cyclist can be of \
any length and either given as a list or a sequence of cycles.\";

DistributiveQ::usage = \"DistributiveQ[R] returns True if the Multiplication \
is (two-sided) distributive over the Addition in the structure R, and False \
otherwise.\";

DividesQ::usage = \"DividesQ[r, s] returns True if the integer s divided by \
the integer r is an integer, and False otherwise. DividesQ[r, s, Radical \
\[Rule] d] works similarly in \[DoubleStruckCapitalZ][\\!\\(\\@d\\)], \
returning True if r | s over this ring, and False otherwise.\";

DivisorsComplete::usage = \"DivisorsComplete is an option for IntegerDivisors \
and ZdDivisors. Its default value is False. With this, only one divisor from \
each class of associates is given. For integers, when set to False, this \
returns the positive divisors. For Gaussian integers (d = -1), when set to \
False, this returns the Gaussian integers in the first quadrant. In all other \
cases, when set to False, this returns the one that is in the right \
half-plane (or first quadrant for those on the imaginary axis) when the \
number a + b \\!\\(\\@d\\) is considered the ordered pair (a, b). In \
contrast, with the value True, all the divisors are included.\";

Domain::usage = \"Domain[f] returns the structure used in the domain of the \
Morphoid f. Domain[S] returns the elements in the Groupoid or Ringoid S; this \
is equivalent to the Elements function.\";

Dot::usage=\"Dot[R, a, b] generalizes the (scalar) dot product over a Ringoid \
R and computes a.b (for vectors a and b over R) using the arithmetic of R. \
\\nThe standard (built-in) usage still exists: a.b.c or Dot[a, b, c] gives \
products of vectors, matrices and tensors.\";

DrawNgon::usage = \"DrawNgon[n] draws a regular n-gon (n > 2) with the \
vertices labeled with the integers 1 through n.\";

DropPermFromGroup::usage = \"DropPermFromGroup[p] deletes the permutation p \
from the list of alleged symmetries (which is called MySymmetryGroup). Note \
that p can be in the form of a list ({1,3,4,2}) or a list of rules \
({1\[Rule]1, 2\[Rule]3, 3\[Rule]4, 4\[Rule]2}).\";

ESG::usage = \"ESG[code] returns the group corresponding to the one given by \
'code' as used in the software package Exploring Small Groups.\";

EisensteinsCriterionQ::usage = \"EisensteinsCriterionQ[zpo\\ ly] returns True \
if Eisenstein's Criterion indicates that the polynomial zpoly, with \
coefficients from the integers, is irreducible, and False otherwise. The \
Textual mode is available.\";

ElementConjugate::usage = \"ElementConjugate[G, h, x] returns the element x h \
x^(-1) in the Groupoid G.\";

ElementQ::usage = \"ElementQ[x, S] yields True or False depending on whether \
or not x is an element of the structured set S.\";

ElementToCoset::usage = \"ElementToCoset[Q, el], assuming Q is the quotient \
group G/N and el is an element in G, this returns the coset containing el.\";

ElementToKey::usage = \"ElementToKey[G, el] returns the key value used for el \
in the Key that is made when the elements in the structure S are too wide for \
a graphical image.\";

ElementToPower::usage = \"ElementToPower[G, g, n] returns the nth power \
(multiple, in an additive groupoid) of the element g in the structure G, \
where n can be any integer).\";

Elements::usage = \"Elements[S] returns the list of elements contained in the \
structured set S (either a Groupoid or Ringoid). Elements[{S1,S2,..}] returns \
the elements in each of the structured sets.\";

ElementsQ::usage = \"ElementsQ[els, S] yields True or False depending on \
whether or not all the items in the list els are elements of the structured \
set S.\";

Equal::usage = \"Equal[PolynomialsOver[R], p, q] returns True or False \
depending on whether the polynomials p and q are equal as elements in the \
ring of polynomials over the Ringoid R. Equal[p, q] assumes that both p and q \
are well-defined in some ring of polynomials. The option IgnoreIndeterminate \
can be set to True (default) or False and determines whether the \
indeterminate used should be considered when deciding equality. \\nThe \
standard (built-in) usage still exists: lhs == rhs returns True if lhs and \
rhs are identical.\";

EqualGroupoidQ::usage = \"EqualGroupoidQ[G1, G2] returns True if G1 and G2 \
can be considered equal as Groupoids, and False otherwise.\";

EqualMorphoidQ::usage=\"EqualMorphoidQ[f, g] compares two Morphoids f and g \
and returns True if their functions are identical and are between identical \
types of structures, and False otherwise. The operations of the structures \
are not compared.\";

EvaluationInExtension::usage = \"EvaluationInExtension[E, p, q] evaluates the \
polynomial p (a polynomial over the base ring of the extension E) at q, an \
element of that extension. Note: Both p and q should both be polynomials over \
the base ring with identical indeterminates.\";

EvenPermutationQ::usage = \"EvenPermutationQ[p] returns True if p is an even \
permutation, and False otherwise.\";

Exponent::usage = \"Exponent[PolynomialsOver[R], p] determines the degree of \
the polynomial p when viewed as an element in the ring of polynomials over \
the Ringoid R. Exponent[p] assumes p is defined in some ring of polynomials. \
\\nThe standard (built-in) usage still exists: Exponent[expr, form] gives the \
maximum power with which form appears in expr. Exponent[expr, form, h] \
applies h to the set of exponents with which form appears in expr.\";

ExtendPermutation::usage = \"ExtendPermutation[p, n] takes a permutation p in \
S[m] (for m < n) and returns a permutation in S[n] using the components of p \
in the first m positions and filling out positions m+1 to n with the integers \
m+1 to n, so that p is naturally extended.\";

ExtensionDegree::usage = \"ExtensionDegree[GF[n]] gives the degree of the \
extension of GF[n]. In other words, when n is written as n = p^d for some \
prime p, d is the ExtensionDegree of GF[n].\";

ExtensionType::usage = \"ExtensionType[ext] returns the type of extension for \
this extension ring ext.\";

FactorGroup::usage = \"FactorGroup[G, N, opts] is equivalent to \
QuotientGroup[G, N, opts]; see this function for further details.\";

FactorRing::usage = \"FactorRing[R, S] is equivalent to QuotientRing[R, S]; \
see QuotientRing for details.\";

Fiber::usage=\"Fiber[f, S] is equivalent to InverseImage[f, S].\";

FieldIrreducible::usage = \"FieldIrreducible[GF[n]] returns the irreducible \
polynomial used in  establishing the Galois field GF[n].\";

FieldQ::usage = \"FieldQ[R] returns True if the Ringoid R is a field, and \
False otherwise.\";

FirstTaker::usage = \"FirstTaker[n] returns the Groupoid with elements \
{1,2,...n} and the operation that returns the first of the two inputs.\";

FixQ::usage = \"FixQ[S, p, el] returns True if the permutation p (where p \
permutes the elements of S) fixes the element el, and False otherwise. If p \
is a permutation in S[n], then FixQ[p, el] is equivalent to FixQ[Range[n], p, \
el].\";

FlexibleEntering::usage = \"FlexibleEntering is an option, taking either True \
or False, for the Poly function, which creates polynomials. When set to True \
(the default value), the function call Poly[R, x^2 - 2x + 1] is treated as \
Poly[R, x^2 + NegationOf[R, 2]x + 1]. Additionally, if R = Z[n], then the \
coefficients can be any integers and are reduced mod n before processing.\";

Form::usage = \"Form is an option when working with the dihedral group D[n]. \
By default we have Form \[Rule] RotRef. Also possible is Form \[Rule] \
Permutations. See Dihedral for more information. Form is also an option for \
QuotientGroup and QuotientRing. Form \[Rule] Cosets is the default here and \
specifies that the elements of the quotient group (or quotient ring) should \
appear in coset form. Form \[Rule] Representatives causes the quotient \
elements to be represented by a representative from the cosets. The option \
Representatives can be used to specify these representatives. Form \[Rule] \
CosetLists is yet another option, where the cosets appear as lists of \
elements. Finally, Form is also an option for QuaternionGroup; see this \
function for more information.\";

FormGroupoid::usage = \"FormGroupoid[els, op, opsym, opts] is the basic \
command for forming a Groupoid consisting of the list els governed by the \
operation op. The symbol opsym defaults to * if not specified. The available \
options for opts are WideElements, IsAGroup, Generators, GroupoidDescription, \
GroupoidName, FormatOperator, FormatElements, MaxElementsToList, KeyForm, and \
CayleyForm. See each one for more information. \\n\\nThis function, rather \
than just wrapping Groupoid around a list and an operation, is strongly \
recommended.\";

FormGroupoidByTable::usage = \"FormGroupoidByTable[els, tab, opsym, opts] is \
a command for forming a Groupoid consisting of the list els and governed by \
the operation implicit in the Cayley table tab. The symbol opsym defaults to \
* unless specified. The available options for opts are WideElements, \
IsAGroup, Generators, GroupoidDescription, GroupoidName, FormatOperator, \
FormatElements, MaxElementsToList, KeyForm, and CayleyForm. See each of these \
individually for more information.\";

FormGroupoidFromCycles::usage = \"FormGroupoidFromCycles[cl, opts] forms the \
Groupoid of permutations whose elements are (initially) written as either \
cycles or products of cycles. The option opts takes on values similar to \
FormGroupoid, as well as the option ProductOrder (since we are working with \
permutations).\";

FormMorphoid::usage = \"FormMorphoid[f, S1, S2, (opts)] is the standard means \
for creating a Morphoid. Here, S1 and S2 are Groupoids or Ringoids, and f is \
either a list of Rules, a Function, or a Symbol. In the special case where S1 \
is a cyclic Groupoid, f can consist of just one rule that sets up the \
morphism. Additionally, if S1 consists of n elements and S2 consists of m \
elements, then FormMorphoid[{p1, p2, ... pn}, S1, S2] forms the Morphoid by \
sending the first element in S1 to the element in S2 in position p1, the \
second element in S1 to the element in position p2 in S2, until finally the \
nth element goes to the element in position pn in S2. FormMorphoidSetup may \
be useful in using this method. The options opts can consist of setting the \
Mode or the value of FormatFunction (default is False), which determines if \
the function should be formatted or not.\";

FormMorphoidSetup::usage= \"FormMorphoidSetup[S1, S2] produces a graphic that \
assists in the preparation of a list of positions to use in FormMorphoid. The \
arguments S2 and S2 must be Groupoids or Ringoids.\";

FormRingoid::usage = \"FormRingoid[list, addition, multiplication, {plussym, \
multsymb}, opts] is the basic command for forming a Ringoid consisting of the \
list of elements found in list governed by the operations addition and \
multiplication. The symbol plussym defaults to + and the multsymb defaults to \
*, if not specified. The options for opts can be WideElements, IsARing, \
RingoidDescription, RingoidName, FormatOperator, FormatElements, \
MaxElementsToList, KeyForm, and CayleyForm. See each one for more \
information. Alternatively, FormRingoid[AG, MG, opts] forms the Ringoid using \
the Groupoid AG for the additive part and the Groupoid MG for the \
multiplicative part (assuming the same elements are used).\\n\\n This \
function, rather than just wrapping Ringoid around a list and the operations, \
is strongly recommended.\";

FormRingoidByTable::usage = \"FormRingoidByTable[list, additiontab, \
multiplicationtab, opts] is used for generating a Ringoid consisting of the \
elements in list and governed by the operations implicit in the Cayley tables \
additiontab and multiplicationtab. The options for opts can be WideElements, \
IsARing, RingoidDescription, RingoidName, FormatOperator, FormatElements, \
MaxElementsToList, KeyForm, and CayleyForm. See each of these individually \
for more information.\";

FormatElements::usage = \"FormatElements is an option for functions which \
form Groupoids or Ringoids, whose default value is False. When set to True, \
whenever a structured set is displayed, {-Elements-} will be displayed \
instead of the actual list of elements.\";

FormatFunction::usage = \"FormatFunction is an option for the FormMorphoid \
function that indicates whether a Morphoid\[CloseCurlyQuote]s function should \
be displayed in an abbreviated (or formatted) form. While the default value \
is False, it can also be set to True.\";

FormatOperator::usage = \"FormatOperator is an option for functions which \
form Groupoids or Ringoids, whose default value is True. When set to True, \
whenever a structured set is displayed, -Operation- (or -Addition- and \
-Multiplication- for Ringoids) will be displayed instead of the actual \
definition of the operator(s).\";

FromCycles::usage =\"FromCycles[{c1, c2,...,cn}] gives the permutation that \
corresponds to the product of the cycles c1, c2, ...cn, assuming that the \
cycles ci are disjoint. This is a modification and improvement on the \
function from the DiscreteMath`Permutations` package.\";

Func::usage=\"Func is the head for a function in a FunctionsOver \
extension.\";

FuncRing::usage=\"FuncRing is the first parameter for any function extension.\
\";

FuncToRules::usage=\"FuncToRules[f, FunctionsOver[R]] converts f to a list of \
rules.\";

FunctionForm::usage=\"FunctionForm is an option for InnerAutomorphism that \
controls whether the Morphoid is defined by Rules (default value) or by a \
function is to be created.\";

FunctionsOver::usage=\"FunctionsOver[R] returns the extension of functions on \
the Ringoid R.\";

GF::usage = \"GF[n] returns the Galois field of order n (if n = p^d for some \
prime p and positive integer d), while GF[p, d] returns the field of order \
p^d (where p is the prime modulus and d is the degree of a irreducible \
polynomial to create the field). The field takes the form of a quotient ring \
of polynomials over Z[p] mod the ideal generated by the irreducible \
polynomial, and consequently consisting of polynomials of degree less than d. \
GF[n, poly] or GF[p, d, poly] returns the finite field using the specified \
irreducible polynomial. The option Indeterminate can be used to specify the \
symbol to be used for the indeterminate.\";

GL::usage = \"GL[n, R] (alternately, GL[R, n]) returns the extension of \
invertible n-by-n matrices over the Ringoid R. For a positive integer k, \
GL[n,k] is equivalent to GL[n,Z[k]].\";

GLQ::usage = \"GLQ[R, A] returns True or False depending on whether the \
matrix A over the Ringoid R is in GL[R, n] (where A is an n-by-n matrix).\";

GaloisFieldQ::usage = \"GaloisFieldQ[R] returns True or False depending on \
whether the ring R is a Galois field and was created using the GF \
function.\";

GaussianIntegerQ::usage = \"GaussianIntegerQ[z] returns True if the complex \
number z is a Gaussian integer and false otherwise.\";

GaussianIntegers::usage = \"GaussianIntegers[n] returns the Ringoid of \
Gaussian integers mod n under ordinary complex addition and multiplication \
mod n. \\nThe standard use of this name as an option for several built-in \
functions still works and is described as follows: GaussianIntegers is an \
option for FactorInteger, PrimeQ, Factor and related functions. With \
GaussianIntegers \[Rule] True, factorization is done over the Gaussian \
integers when possible. With GaussianIntegers \[Rule] False, factorization is \
done over the integers.\";

GaussianIntegersAdditive::usage = \"GaussianIntegersAdditive[n] returns the \
additive Groupoid of Gaussian integers mod n. This is equivalent to Z[n, \
I].\";

GaussianIntegersMultiplicative::usage = \"GaussianIntegersMultiplicative[n] \
returns the multiplicative Groupoid of Gaussian integers mod n. This is \
equivalent to Zx[n, I].\";

GaussianUnits::usage = \"GaussianUnits returns the Groupoid consisting of \
{1,-1, I, -I} under ordinary complex multiplication.\";

GeneralLinear::usage = \"GeneralLinear[args] - see GL.\";

GeneralLinearGroup::usage = \"GeneralLinearGroup[args] - see GL.\";

GenerateGroupoid::usage = \"GenerateGroupoid[gens, op, opsym, opts] is a \
command for generating a Groupoid by using the generators in the list gens \
governed by the operation op. The symbol opsym defaults to * unless specified \
otherwise. The options for opts can be WideElements, IsAGroup, SizeLimit, \
Generators, GroupoidDescription, GroupoidName, FormatOperator, \
FormatElements, MaxElementsToList, KeyForm, and CayleyForm. See each of these \
individually for more information.\";

GeneratingSet::usage = \"GeneratingSet[G] gives a set of generators for \
determining G. If $Failed is returned, this indicates that a generating set \
is not yet known to Mathematica. The option Generators for FormGroupooid is \
used to specify a generating set, as is the first argument for \
GenerateGroupoid.\";

Generator::usage = \"Generator is an option for the Cyclic function, \
specifying which symbol should be used for the generator of the group.\";

Generators::usage = \"Generators is an option for functions which form \
Groupoids, whose default value is {}. Specifying Generators \[Rule] \
{g1,g2,...} indicates that these generators are known to generate this \
Groupoid.\";

GoodGroupElementsQ::usage = \"GoodGroupElementsQ[] will return True or False \
depending on whether or not the list of alleged symmetries found in \
MySymmetryGroup are all elements of the actual symmetry group.\";

Graphics::usage = \"Graphics is a value for the Output option that can be \
used when a function uses the Visual Mode. Adding the option Output \[Rule] \
Graphics will cause the graphics of the Visual mode to be the output (given \
as -Graphics-). This is a method of capturing the graphics involved in a \
computation instead of the actual computation. (Using GraphicsArray instead \
of Graphics works similarly when the output is going to be a series of \
graphics. These are then put into an array of graphics.) \\nThe standard \
(built-in) definition still exists: Graphics[primitives, options] represents \
a two-dimensional graphical image.\";

Group::usage = \"Group is a value for the Structure option that is used for \
the functions FormMorphoid, ZMap, and Z (including Z[n] and Z[n, I]). It is \
also the argument for the SwitchStructureTo function when switching from \
rings to groups.\";

GroupCenter::usage = \"GroupCenter[G] returns the center of the group G. This \
is identical to Center.\";

GroupExponent::usage = \"GroupExponent[G] returns the smallest positive \
integer n such that g^n is the identity for all elements g in the Groupoid G.\
\";

GroupIdentity::usage = \"GroupIdentity[G] returns the (two-sided) identity of \
the Groupoid G, if it exists. If there is no identity, a message indicates \
this and $Failed is returned. HasIdentityQ[G] is similar, except it only \
returns True or False regarding the existence of an identity.\";

GroupInfo::usage = \"GroupInfo[G] returns a list of information obtained \
about the Groupoid G that has been gathered thus far by calling various \
functions.\";

GroupInverse::usage = \"GroupInverse[G, g] returns the inverse of g in G, if \
it exists, and $Failed otherwise.\";

GroupQ::usage = \"GroupQ[G] returns True if G is a group, and False \
otherwise.\";

Groupoid::usage = \"Groupoid is the head for an ordered pair where the first \
component is a set of elements and the second is an operation. A Groupoid is \
one of the basic structures of these packages.\";

GroupoidDescription::usage = \"GroupoidDescription[G] yields a description, \
if available, of the Groupoid G. This can be set with the option \
GroupoidDescription when using the functions FormGroupoid or \
GenerateGroupoid. If the empty string is returned (default value), no \
description has been given.\";

GroupoidName::usage = \"GroupoidName[G] yields the name, if given, of the \
group G. This can be set with the option GroupoidName in FormGroupoid and \
GenerateGroupoid. If the empty string or TheGroup (default) is returned, no \
name has yet been given.\";

Groups::usage = \"Groups is an acceptable argument for the SwitchStructureTo \
function.\";

GroupsToConsider::usage = \"GroupsToConsider is a list of groups to consider \
for this lab.\";

HasIdentityQ::usage = \"HasIdentityQ[S] returns True or False depending on \
whether or not the (two-sided) identity (or identities for rings) of the \
structure S exists. When used with rings, the Operation option can be used, \
which can have the value Addition, Multiplication or Both. If S is a group, \
GroupIdentity[S] returns the identity, if one exists, while for rings, \
Zero[S] and Unity[S] return the additive and multiplicative identities, if \
they exist.\";

HasInversesQ::usage = \"HasInversesQ[G] returns True or False depending on \
whether all the elements in G have inverses or not. When used with rings,  \
the Operation option can be used, which can have the value Addition, \
Multiplication or Both.\";

HasLeftIdentityQ::usage = \"HasLeftIdentityQ[G] returns True or False \
depending on whether the Groupoid G has a left identity or not. If one \
exists, LeftIdentity[G] returns its value.\";

HasNegativeQ::usage = \"HasNegativeQ[R, r] returns True if r has a negative \
in the structure R, and False otherwise.\";

HasRightIdentityQ::usage = \"HasRightIdentityQ[G] returns True or False \
depending on whether the Groupoid G has a right identity or not. If one \
exists, RightIdentity[G] returns its value.\";

HasUnityQ::usage = \"HasUnityQ[R] returns True if the structure R has a \
unity, and False otherwise.\";

HasZeroQ::usage = \"HasZeroQ[R] returns True if the structure R has a zero, \
and False otherwise.\";

HeadingsColored::usage = \"HeadingsColored is an option for CayleyTable. \
Setting it to True or False determines whether the top row and left column \
are colored according to the default coloring of the elements residing in \
these positions.\";

HermitianQ::usage = \"HermitianQ[A] returns True or False depending on \
whether the matrix A is Hermitian (i.e., A = Adjoint[A]).\";

HomomorphismQ::usage = \"HomomorphismQ[f] returns True if the Morphoid f is a \
homomorphism, and False otherwise. This is equivalent to MorphismQ.\";

IdealQ::usage = \"IdealQ[S, R] returns True if the set S is an ideal of the \
structure R, and False otherwise.\";

IdempotentQ::usage = \"IdempotentQ[R, r] returns True if r is an idempotent \
in the structure R, and False otherwise.\";

Idempotents::usage = \"Idempotents[R] returns all the idempotent elements in \
the structure R.\";

Identity::usage = \"Identity[G] returns the (two-sided) identity of the \
structure G, if it exists. If there is no identity, a message indicates this. \
For groups, this is identical in functionality to GroupIdentity[G]. \
HasIdentityQ[G] is similar, except it only returns True or False regarding \
the existence. When used with rings, the Operation option can be used, which \
can have the value Addition, Multiplication or Both. This use is equivalent \
to RingIdentity. \\nThe standard (built-in) usage still exists: \
Identity[expr] gives expr (the identity operation).\";

IgnoreIndeterminate::usage = \"IgnoreIndeterminate is an option for the Equal \
command that is used when determining when two polynomials are equal. The \
default value for this option is True, which means that 4x^2 + 3x + 1 and \
4y^2 + 3y + 1 are considered equal as polynomials. One can optionally set \
this to False.\";

Image::usage = \"Image[f] returns a Groupoid or Ringoid (as appropriate) \
consisting of the image values of the Morphoid f. Additionally, Image[f, S] \
returns the images of the substructure S of the domain of f.\";

Ind::usage = \"Special symbol used for this lab.\";

Indeterminate::usage = \"Indeterminate is an option for the Poly function \
(that creates polynomials). The default value is 'x', though one can specify \
any other symbol as the indeterminate to be used in a polynomial. \\nThe \
standard (built-in) usage still exists: Indeterminate is a symbol that \
represents a numerical quantity whose magnitude cannot be determined.\";

Index::usage = \"Index[G, H] returns the index of the subgroup H in the group \
G.\";

IndexLimit::usage = \"IndexLimit is an option for some groups to enable one \
to obtain larger groups (whose index is more than the default limit on the \
index). Examples where this is used is with the Symmetric and Alternating \
groups with the default value of 6.\";

InducedCanonical::usage = \"InducedCanonical[f], given a Morphoid f: G \
\[Rule] H, returns the Morphoid g : G \[Rule] G/Ker[f].\";

InducedIsomorphism::usage = \"InducedIsomorphism[f], given a Morphoid f: G \
\[Rule] H, returns the Morphoid g : G/Kernel[f] \[Rule] Image[H].\";

InjectiveQ::usage=\"InjectiveQ[f] returns True if the Morphoid f is injective \
(one-to-one), and False otherwise.\";

Inn::usage = \"Inn[G] is identical to InnerAutomorphismGroup[G].\";

InnerAutomorphism::usage = \"InnerAutomorphism[G, g], when given an element g \
in the group G, returns the inner automorphism of G induced by g.\";

InnerAutomorphismGroup::usage=\"InnerAutomorphismGroup[G] returns the group \
of inner automorphisms of G, if G is a group.\";

IntegerDivisors::usage = \"IntegerDivisors[n, opts] returns the divisors of \
the integer n, just as the built-in function Divisors[n] does. The options \
are Combine, NonTrivialOnly and DivisorsComplete. See these for more details.\
\";

IntegerLatticeGrid::usage = \"IntegerLatticeGrid[{a, b}, {c, d}, opts] \
returns a ListPlot of an integer lattice with domain [a,b] and range [c,d]. \
Any opts given are used by ListPlot.\";

IntegerMatrixQ::usage = \"IntegerMatrixQ[A] returns True or False depending \
on whether the matrix A has all of its entries being integers.\";

IntegerUnits::usage = \"IntegerUnits returns the Groupoid consisting of {1, \
-1} under ordinary multiplication.\";

IntegralDomainQ::usage = \"IntegralDomainQ[R] returns True if the structure R \
is an integral domain, and False otherwise.\"

InterpolatingPolynomial::usage = \"InterpolatingPolynomial[R,{{x,y},...}] \
returns the interpolating polynomial of degree at most n-1 where n is the \
number of pairs in {{x,y},...}. The x coordinates must all be distinct and R \
should be a field, for example Z[p] for prime p.\\nThe standard (built-in) \
usage still exists: InterpolatingPolynomial[data, var] gives a polynomial in \
the variable var which provides an exact fit to a list of data. The data can \
have the forms {{x1, f1}, {x2, f2}, ...} or {f1, f2, ...}, where in the \
second case, the xi are taken to have values 1, 2, .... The fi can be \
replaced by {fi, dfi, ddfi, ...}, specifying derivatives at the points xi.\";

Inverse::usage = \"Inverse[G, g] returns the inverse of g in G, if it exists, \
otherwise $Failed. When used with rings,  the Operation option can be used, \
which can have the value Addition, Multiplication or Both. \\nThe standard \
(built-in) usage still exists: Inverse[m] gives the inverse of a square \
matrix m.\";

InverseImage::usage=\"InverseImage[f, S] returns the elements of the domain \
of the Morphoid f that map into elements of the list or element S (from the \
codomain). There is a Visual mode for this function.\";

InverseImages::usage = \"InverseImages[f] returns the set of inverse images. \
This is partially equivalent to InverseImage[f, Elements[Codomain[f]]] except \
the latter returns a single (unsorted) list of the inverse images while this \
function partitions them according to the elements in Codomain[f]. The option \
WithImages (defaulting to False) indicates whether the image elements should \
be included in the output. There is a Visual mode for this function.\";

Inverses::usage = \"Inverses[G] returns a list of ordered pairs of the form \
{g, h}. If g has an inverse in G, then h is that element; otherwise h is 'no \
inverse'. When used with rings,  the Operation option can be used, which can \
have the value Addition, Multiplication or Both.\";

InvertibleQ::usage = \"InvertibleQ[S, g] returns True if the (two-sided) \
inverse of g in the structure S exists, and False otherwise. When used with \
rings,  the Operation option can be used, which can have the value Addition, \
Multiplication or Both.\";

IrreduciblePolyOverZpQ::usage = \"IrreduciblePolyOverZpQ[poly, p] returns \
True or False depending on whether the polynomial poly is irreducible over \
the ring Z[p]. Note that poly can be a standard Mathematica polynomial in \
some indeterminate or it can be constructed from the Poly function in the \
RingExtensions package.\";

IrreduciblePolynomial::usage = \"IrreduciblePolynomial[ind, p, d] finds an \
irreducible polynomial in the indeterminate ind of degree d over the integers \
mod p (where p is prime). The code for this comes from the Mathematica \
package Algebra`FiniteFields`.\";

IsAGroup::usage = \"IsAGroup is an option for functions which form Groupoids, \
whose default value is False. When set to True, the Groupoid constructed will \
be assumed to be known as a group.\";

IsARing::usage = \"IsARing is an option for functions which form Ringoids, \
whose default value is False. When set to True, the Ringoid constructed will \
be assumed to be known to be a ring.\";

IsomorphismQ::usage = \"IsomorphismQ[f] returns True if the Morphoid f is an \
isomorphism (group or ring, as appropriate), and False otherwise. The option \
Cautious (defaulting to False) indicates whether MorphismQ (if True) or \
ProbableMorphismQ (if False) should be used for the testing.\";

J::usage = \"J is the symbol to represent an ideal in the quotient ring \
Z[I]/<z> for a Gaussian integer z.\";

JoinDivisors::usage = \"JoinDivisors[n] returns the Groupoid consisting of \
the divisors of n with operation LCM.\";

KSubsets::usage = \"KSubsets[L, k] returns all subsets of set L containing \
exactly k elements, ordered lexicographically. (From \
DiscreteMath`Combinatorica`.)\";

Kernel::usage = \"Kernel[f] returns the kernel of the Morphoid f, if the \
codomain has an identity element. It is not necessary that f satisfies \
MorphismQ. The object returned is a Groupoid or Ringoid (as appropriate). \
There is a Visual mode for this function.\";

KeyForm::usage = \"KeyForm is an option for CayleyTable (and functions that \
form Groupoids or Ringoids) to indicate whether the elements in the Key of \
the Cayley table should be displayed in InputForm, OutputForm or some other \
form. The default value is InputForm.\";

KeyToElement::usage = \"KeyToElement[S, key] returns the element \
corresponding to the value key found in the Key, when the elements in the \
structure S are too wide for a graphical image.\";

Klein4::usage = \"Klein4 returns the Klein-4 group (Viergruppe).\";

LG::usage = \"LG[n] is the nth groupoid found in a list called 'Lab \
Groupoids.' These are groupoids used in a variety of labs.\";

LT::usage = \"LT[n, R] (alternately, LT[R, n]) returns the extension of \
n-by-n lower triangular matrices (fully below the diagonal) over the Ringoid \
R.\";

LTD::usage = \"LTD[n, R] (alternately, LTD[R, n]) returns the extension of \
n-by-n lower triangular matrices (including the diagonal) over the Ringoid R.\
\";

Lab2::usage = \"Special symbol used for this lab.\";

Lab3::usage = \"Special symbol used for this lab.\";

Lab4::usage = \"Special symbol used for this lab.\";

LatticeRing::usage = \"LatticeRing[n] returns the Ringoid of divisors of n \
with LCM/GCD for the addition and GCD for the multiplication.\";

LeftCoset::usage = \"LeftCoset[G, H, g] returns the left coset gH (or g + H) \
when given the element g from G and the subgroup H of G. G is assumed to be \
either a Groupoid or Ringoid (for which H needs to be a subring).\";

LeftCosets::usage = \"LeftCosets[G, H] returns the set of cosets of the \
subgroup (or subring) H in the Groupoid (or Ringoid) G.\";

LeftDistributiveQ::usage = \"LeftDistributiveQ[ R] returns True if the \
Multiplication is left distributive over the Addition in the structure R, and \
False otherwise.\";

LeftIdealQ::usage = \"LeftIdealQ[S, R] returns True if the set S is a left \
ideal of the structure R, and False otherwise.\";

LeftIdentity::usage = \"LeftIdentity[G] returns the left identity of the \
Groupoid G, if one exists, or $Failed otherwise.\";

LeftInverse::usage = \"LeftInverse[G, g] returns the left inverse of g in G, \
if it exists, otherwise $Failed.\";

LeftInvertibleQ::usage = \"LeftInvertibleQ[G, g] returns True if the left \
inverse of g in G exists, and False otherwise.\";

LeftToRight::usage = \"LeftToRight is a value for the ProductOrder option of \
MultiplyPermutations and MultiplyCycles, as well for the PowersIncrease \
option for Poly (when working with polynomials over a ring). When \
ProductOrder is set to this value, then MultiplyPermutations[p1,p2] will be \
computed by taking p1 followed by p2. For the use in Poly, see \
PowersIncrease.\";

ListOperationPreservingElements::usage = \"Special symbol used for this \
lab.\";

LowerDegreeOK::usage = \"LowerDegreeOK is an option for \
RandomElement[RingExtension[PolyRing,...]] that controls whether random \
polynomials MUST have the specified degree (using the value False, the \
default value) or may have a degree less than or equal to the specified \
degree (using the value True).\";

MGroupoid::usage = \"MGroupoid[R] returns the multiplicative Groupoid \
associated with the Ringoid R. This is equivalent to \
MultiplicativeGroupoid[R].\";

Mat::usage = \"Mat[R,n] (alternatively, Mat[n, R]) returns the extension ring \
of n-by-n matrices over the Ringoid R. Mat[R, {m,n}] (or Mat[{m,n},R]) \
returns the extension ring of m-by-n matrices over R.\";

MatA::usage = \"MatA[R,{m,n}] (alternatively, MatA[{m,n}, R]) returns the \
extension of m-by-n matrices over the Ringoid R with the operation being \
addition of matrices.\";

MatM::usage = \"MatM[R,n] (alternatively, MatM[n, R]) returns the extension \
of n-by-n matrices over the Ringoid R with the operation being multiplication \
of matrices.\";

Matrices::usage = \"Matrices is a possible type of RingExtension.\";

MatricesOver::usage=\"MatricesOver[R,{m,n}] generates the ring extension of \
m-by-n matrices over R. MatricesOver[R,n] is equivalent to \
MatricesOver[R,{n,n}].\";

MatrixConjugate::usage = \"MatrixConjugate[A], where A is a matrix, returns \
the matrix with all of the entries being the complex conjugate of those that \
occur in A.\";

MatrixDelete::usage = \"MatrixDelete[A, {i, j}] returns the matrix remaining \
when the ith row and jth column of the matrix A are removed.\";

MatrixOperation::usage = \"MatrixOperation[MatricesOver[R, {m,n}]] returns \
the operation inherent in the matrix extension. Values are the same as for \
Operation (Both, Addition, or Multiplication).\";

MatrixOverQ::usage = \"MatrixOverQ[R, A] returns True or False depending on \
whether the elements of the matrix A come from the Ringoid R.\";

MatrixPower::usage = \"MatrixPower[MatricesOver[R, {n,n}], A, k] returns the \
kth power of the matrix A, as an element of the n-by-n matrices over the \
Ringoid R. MatrixPower[R, A, k] works similarly. \\nThe standard (built-in) \
usage still exists: MatrixPower[mat, n] gives the nth matrix power of mat.\";

MatrixTrace::usage = \"MatrixTrace[R, A] returns the trace of the square \
matrix A. MatrixTrace[MatricesOver[R,{n,n}], A] works similarly. For matrices \
with numeric entries (over Integers, Rationals, Reals or Complex), \
MatrixTrace[A] works similarly.\";

MatrixType::usage = \"MatrixType is the name of an option for working with \
matrix extension rings. It can have the value GL, SL, Diag, UT, LT, UTD, or \
LTD (and defaults to All).\";

MaxElementsToList::usage = \"MaxElementsToList is an option for functions \
which form Groupoids or Ringoids, whose default value is 50. This means that \
if a structured set has more than 50 elements, it will default to showing \
simply {-Elements-} instead of the actual list. Some groups/rings may have \
lower values.\";

MaxTaker::usage = \"MaxTaker[n] returns the Groupoid with elements {1,2,...n} \
and the operation that returns the maximum of the two inputs. MaxTaker[m, n] \
is similar but the elements range over [m, n].\";

MaximalIdealQ::usage = \"MaximalIdealQ[S, R] returns if the set S is a \
maximal ideal in the structure R, and False otherwise.\";

MeetDivisors::usage = \"MeetDivisors[n] returns the Groupoid consisting of \
the divisors of n with operation GCD.\";

MinTaker::usage = \"MinTaker[n] returns the Groupoid with elements {1,2,...n} \
and the operation that returns the minimum of the two inputs. MinTaker[m, n] \
is similar but the elements range over [m, n].\";

MixedDivisors::usage = \"MixedDivisors[n] returns the Groupoid consisting of \
the divisors of n with operation LCM/GCD.\";

Mode::usage = \"Mode is an option for many of the functions in these \
packages. Standard modes are Computational, Textual and Visual, and sometimes \
Visual2. See each of these individually for more information. \\nThe standard \
(built-in) definition still exists: Mode is an option to Solve and related \
functions that specifies in what sense the equations are to be solved. The \
possible settings for Mode are Generic, Modular, and Rational.\";

ModpIrreducibilityQ::usage = \"ModpIrreducibilityQ[zpoly] returns True if the \
Mod p Irreducibility Test indicates that the polynomial zpoly, with \
coefficients from the integers, is irreducible, and False otherwise. (This \
method tries the first 25 primes.) The Textual mode is available. \
ModpIrreducibilityQ[p, zpoly] tests the polynomial zpoly specifically with \
the prime p.\";

ModulusPolynomial::usage=\"ModulusPolynomial[Q] is the polynomial from which \
a quotient ring Q has been created.\";

Monic::usage = \"Monic is an option to RandomElement for Polynomial Rings. \
When set to True, the random polynomial is to be monic, having the unit for \
the leading coefficient, while False does not impose this restriction.\";

MonoidQ::usage = \"MonoidQ[G] returns True if G is a monoid (the set is \
closed under a binary operation that is associative with an identity), and \
False otherwise.\";

Monomial::usage=\"Monomial[R, c, n] returns the monomial c x^n in the ring \
extension PolynomialsOver[R]; Monomial[PolynomialsOver[R], c, n] returns the \
same.\";

MorphismQ::usage = \"MorphismQ[f] returns True if the Morphoid f is a \
homomorphism, and False otherwise. This function automatically checks to see \
if f represents a group homomorphism or a ring homomorphism according to \
whether the structures involved are groups or rings. The Visual mode can be \
used with this function. MorphismQ[f, {S1, op1}, {S2, op2}] or MorphismQ[f, \
{S1, op1, op3}, {S2, op2, op4}] are alternative usages, where f is either a \
list of Rules, a Function or a Symbol.\";

Morphoid::usage = \"Morphoid is the data structure for possible morphisms. \
This is the head of the object returned by FormMorphoid when one creates a \
morphism. This is one of the basic structures in these packages.\";

MorphoidComposition::usage=\"MorphoidComposition[g, f] forms the composition \
of f and g if the codomain of f and the domain of g are the same structured \
system. Note: This function creates a Morphoid with function g[f[#]]& and \
then converts it to rules.\";

MorphoidFunction::usage = \"MorphoidFunction[f] returns the function defining \
the Morphoid f.\";

MorphoidRules::usage = \"MorphoidRules[f] returns the list of rules defining \
the Morphoid f.\";

MultipleOfElement::usage = \"MultipleOfElement[R, r, n] returns the nth \
multiple of the element r in the structure R. In other words, r + r + ... + r \
(n times) is returned. This is the additive version of ElementToPower.\";

Multiplication::usage = \"Multiplication[R] is the multiplication in the \
Ringoid R. Given an extension Ext of a ring, Multiplication[Ext] is the \
multiplication in this extension. Multiplication is also a value for the \
Operation option that is used in some ring functions.\";

MultiplicationTable::usage = \"MultiplicationTable[R] returns the \
multiplication table of the Ringoid R. MultiplicationTable[R, Mode \[Rule] \
Visual] returns a graphical view of this table.\";

MultiplicativeGroupoid::usage = \"MultiplicativeGroupoid[R] returns the \
multiplicative Groupoid of the ring R. A shortcut is MGroupoid[R].\";

MultiplicativeInverse::usage = \"MultiplicativeInverse[R, a] returns the \
multiplicative inverse of a in the structure R, if it exists, and $Failed \
otherwise.\";

MultiplicativeToAdditive::usage = \"MultiplicativeToAdditive[R, mult] returns \
the additive form of the element mult, currently in multiplicative form, from \
the ringoid (typically a Galois field) R.\";

MultiplyCycles::usage = \"MultiplyCycles[c2, c1, n] views both cycles c1 and \
c2 as in S[n] and determines the permutation representing their product. Note \
that the order of the multiplication is from right to left (unless specified \
otherwise by ProductOrder). MultiplyCycles[c2, c1] does the same but \
determines the value for n by the equation n = Max[Join[c1, c2]]. \
MultiplyCycles[c3, c2, c1] starts from the right and multiplies the cycles as \
it moves left through c2 and c3. MultiplyCycles[cyclelist] or \
MultiplyCycles[{cyclelist}] will work on any length of list of cycles and \
finds the product, working from right to left if the option ProductOrder is \
set to RightToLeft, or from left to right if set to LeftToRight. See \
ProductOrder for details on its values.\";

MultiplyPermutations::usage = \"MultiplyPermutations[perm2, perm1], by \
default, computes the product of perm1 followed by perm2 (right to left). The \
option ProductOrder is by default set to RightToLeft, but can also be set to \
LeftToRight. Note that the permutations can be expressed as rules (eg., {1\
\[Rule]3, 2\[Rule]2,3\[Rule]1}), or lists (eg., {3,2,1}) or mixed, though the \
output will always be a list.\";

MySymmetryGroup::usage = \"MySymmetryGroup is a global variable which \
contains the accumulated list of alleged permutations representing the \
symmetries of the object given by ShowOne[Lab2]. Note that since it is a \
variable, it does not need [] following it.\";

NS::usage = \"NS is a symbol for Input and Output to represent whatever \
Normal Subgroup is in use at the time.\";

NegationOf::usage = \"NegationOf[R, r] returns the additive inverse of r in \
the structure R, if it exists, and $Failed otherwise.\";

Negations::usage = \"Negations is a value for the Combine option of \
IntegerDivisors and ZdDivisors. With this value, the divisors of n are \
grouped in pairs {a, b} such that a and b are negations.\";

NextStage::usage = \"NextStage[func] returns the next stage of an animation \
for the function func when Mode is set to Visual. NextStage[func, k] \
indicates that k steps forward should be taken (or backwards, if negative). \
The functions supporting this include Closure, SubgroupClosure, and \
QuotientRing in some cases.\";

NilpotentDegree::usage = \"NilpotentDeg ree[R, r] returns 0 if the element r \
is NOT nilpotent in the structure R; otherwise a positive integer n is \
returned, which is the least positive integer such that r^n is the zero \
element.\";

NilpotentQ::usage = \"NilpotentQ[R, r] returns True if r is a nilpotent \
element in the structure R, and False otherwise.\";

Nilpotents::usage = \"Nilpotents[R] returns all the nilpotent elements in the \
structure R.\";

NonAssociatingTriples::usage = \"NonAssociatingTriples[G] returns the triples \
of elements {a, b, c} in the Groupoid G that do not associate.\";

NonCommutingPairs::usage = \"NonCommutingPairs[G] returns the pairs of \
elements in the Groupoid G that do not commute.\";

NonIdentity::usage = \"NonIdentity is a value for the SelectFrom option for \
RandomElement and RandomElements. This allows any element to be returned \
except the identity element, if it exists. Alternatively, one may use the \
value Any. Note: for rings, this option excludes both the zero and unity (if \
they exist) and other related options are NonUnity and NonZero.\";

NonTrivialOnly::usage = \"NonTrivialOnly is an option name for both \
IntegerDivisors and ZdDivisors. Its default value is False, which means that \
trivial divisors (\[PlusMinus] 1 and \[PlusMinus] n) are included, but \
excluded if set to True.\";

NonUnity::usage = \"NonUnity is value for the SelectFrom option for the \
RandomElement function, which when having the value True specifies that the \
chosen element should not be the unity.\";

NonZero::usage = \"NonZero is value for the SelectFrom option for the \
RandomElement function, which when having the value True specifies that the \
chosen element should not be the zero.\";

NonZeroMGroupoid::usage = \"NonZeroMGroupoid[R] returns the Groupoid of \
nonzero elements of R with the Multiplication from R. If R is a field, this \
is the group of units.\";

NormalQ::usage = \"NormalQ[H, G] returns True if H is a normal subgroup of G, \
and False otherwise.\";

Normalize::usage = \"Normalize is an option for ToCycles and FromCycles that \
indicates whether a list of cycles in Cycle notation (this assumes that we \
have CycleAs \[Rule] Cycle as an option) is normalized. If the list consists \
only of cycles of length 1, it drops all of them except the one with maximal \
value; otherwise, all cycles of length one are dropped (unless needed to show \
the length of the permutation), the remaining cycles are normalized by \
rotating until the smallest entry occurs first, and then the list of cycles \
is sorted from shortest to longest.\";

NormalizeCycleList::usage = \"NormalizeCycleList[cl], given a list of cycles, \
returns a list of cycles in a canonical form. If cl consists only of cycles \
of length 1, it drops all of them except the one with maximal value; \
otherwise, all cycles of length one are dropped, the remaining cycles are \
normalized by NormalizeCycle, and then the list is sorted from shortest to \
longest.\";*)

Normalizer::usage = \"Normalizer[G, H] returns the normalizer of the subgroup \
H in G.\";

OddPermutationQ::usage = \"OddPermutationQ[p] returns True if p is an odd \
permutation, and False otherwise.\";

OneToOneQ::usage=\"OneToOneQ[f] is equivalent to InjectiveQ[f].\";

OntoQ::usage = \"OntoQ[f] is equivalent to SurjectiveQ[f].\";

Operation::usage = \"Operation[G] returns the operation used in the Groupoid \
G. Operation is also an option for various functions when working with rings; \
possible settings are Addition, Multiplication, and Both.\";

OperatorSymbol::usage = \"OperatorSymbol[G] returns the symbol used for the \
operation in the Groupoid G. FormGroupoid and GenerateGroupoid set this to be \
* by default.\";

Orbit::usage = \"Orbit[G, S, x] is the orbit of x (from S) under G. Here, G \
is a group of permutations of the set S. Orbit[S, x] assumes G is the full \
set of all permutations of S.\";

Order::usage = \"Order[G] returns the cardinality of the set of elements in \
the group G. This is identical to the function Size. Order[G, g] gives the \
order of the element g in G. This is identical to the function \
OrderOfElement. \\nThe standard (built-in) definition still exists: \
Order[expr1, expr2] gives 1 if expr1 is before expr2 in canonical order, and \
-1 if expr1 is after expr2 in canonical order. It gives 0 if expr1 is \
identical to expr2.\";

OrderOfAllElements::usage = \"OrderOfAllElements[G] returns a list of the \
orders of each element in the Groupoid G in the form {element, order}.\";

OrderOfElement::usage = \"OrderOfElement[G, g] returns the order of the \
element g in the Groupoid G.\";

Ordering::usage = \"Ordering[list] gives the permutation that puts the \
elements in list in (a canonical) order. If list is a permutation, this is \
equivalent to PermutationInverse. (This is from the \
DiscreteMath`Permutations` package.)\";

Orders::usage = \"Orders[G] returns a list of the orders of each element in \
the Groupoid G in the form {element, order}. Orders[G, list] works similarly, \
where list is a list of elements from the Groupoid G.\";

OrthogonalQ::usage = \"OrthogonalQ[R, A] returns True or False depending on \
whether the matrix A over the Ringoid R is an orthogonal matrix (i.e., the \
product of the transpose of A and A itself is the identity matrix). For \
matrices with real entries, OrthogonalQ[A] works similarly.\";

Output::usage = \"Output is an option that can be used when a Visual mode is \
used and determines the form of the output. By default, the value of the \
option is Computational, which means that the output is the normal \
computation. Alternatively, using Output \[Rule] Graphics will cause the \
graphics of the Visual mode to be the output (given as -Graphics-). This is a \
method of capturing the graphics involved in a computation instead of the \
actual computation. Additionally, in a few cases were a series of graphics \
are produced, the value GraphicsArray option can be used.\";

Parity::usage = \"Parity[perm] returns 1 if the permutation perm is an even \
permutation and -1 if odd.\";

Partition::usage = \"Partition is an option for Cartesian Product. By \
default, it is set to False. When set to True, the list is partitioned \
according to the size of the second (last) list. \\nThe standard (built-in) \
definition still exists: Partition[list, n] partitions list into \
non-overlapping sublists of length n. Partition[list, n, d] generates \
sublists with offset d. Partition[list, {n1, n2, ...}, {d1, d2, ...}] \
partitions successive levels in list into length ni sublists with offsets di.\
\";

PermutationComposition::usage = \"PermutationComposition[p2, p1] returns the \
product of permutation p1 followed by permutation p2.\";

PermutationGroup::usage = \"PermutationGroup[list] returns the permutation \
group on the elements in list. It is assumed that the length of list is less \
than 7. PermutationGroup[n] acts just as Symmetric[n].\";

PermutationImage::usage = \"PermutationImage[S, p, el] returns the image of \
the element el under the action of the permutation p, where p permutes the \
elements of S. If p is a permutation in S[n], then PermutationImage[p, el] is \
equivalent to PermutationImage[Range[n], p, el].\";

PermutationInverse::usage = \"PermutationInverse[perm] gives the permutation \
that is the inverse of perm\";

PermutationMatrix::usage = \"PermutationMatrix[p] shows a permutation in \
matrix form, where the top row consists of 1, 2, ... Length[p] and the bottom \
row consists of the corresponding images.\";

PermutationQ::usage = \"PermutationQ[e] yields True if e is a list \
representing a permutation. (This is a modified version of that found in the \
DiscreteMath`Permutations` package.)\";

PermutationToPower::usage = \"PermutationToPower[perm, n] returns the nth \
power of the permutation perm, where n is any integer. (If n < 0, this \
returns the nth power of the inverse of perm.)\";

Permutations::usage = \"Permutations is a value for the Form option when \
working with the dihedral group. See Dihedral for more information. \\nThe \
standard (built-in) definition still works: Permutations[list] generates a \
list of all possible permutations of the elements in list.\";

Permutations::usage = \"Permutations is a value for the Form option when \
working with the dihedral group. See Dihedral for more information.\\nThe \
standard (built-in) definition still works: Permutations[list] generates a \
list of all possible permutations of the elements in list.\";

PermuteColoredSquares::usage = \"PermuteColoredSquares[p] will show a row of \
randomly colored squares (as in RandomColoredSquares) and below this a row of \
squares obtained by permuting the first list using the permutation given by \
p. This function only works after RandomColoredSquares has been called. See \
ShowColoredPermutation also.\";

PlusSymbol::usage = \"PlusSymbol is an option for FormRingoid to specify the \
symbol used for addition in forming a Ringoid. The default is PlusSymbol \
\[Rule] +.\";

Poly::usage = \"Poly[R, expr, opts] creates the polynomial over the Ringoid R \
given by expr and using the options given by opts. A polynomial such as 2 + \
3x + x^3 (over some ring R) can be constructed by Poly[R, 2 + 3x + x^3], \
which, by default, would return 2 + 3x + x^3. The form x^3 + 3x + 2 could be \
returned by entering Poly[R, 2 + 3x + x^3, PowersIncrease \[Rule] \
RightToLeft], or by changing this option globally. One can also specify a \
polynomial by just using the coefficients. Thus, Poly[R, 1, 0, 3, 2] returns \
1 + 3x^2 + 2x^3, while Poly[R, 1, 0, 3, 2, PowersIncrease \[Rule] \
RightToLeft] returns x^3 + 3x + 2. When entering just the coefficients, the \
default indeterminate is 'x', but this can be changed by using the option \
Indeterminate \[Rule] var, where var is any (undefined) symbol. \
FlexibleEntering, an option taking either True or False (defaulting to True), \
can be used if one wishes to enter polynomials allowing subtraction of terms \
or allowing entering the negation of an element by using -r. It also allows \
all coefficients of the polynomial to be reduced mod n if the base ring is \
Z[n]. If RP is a ring of polynomials, Poly[RP, expr, opts] works in a similar \
fashion.\";

PolyQ::usage = \"PolyQ[p] returns True if p is a polynomial obtained by the \
Poly function in AbstractAlgebra, and False otherwise.\";

PolyRing::usage=\"PolyRing is a parameter of RingExtension.\";

PolyToFunction::usage = \"PolyToFunction[R, p] constructs the function on the \
ringoid R that is defined by the polynomial p (constructed with Poly). If R \
has no unity, then $Failed is returned.\";

PolynomialDivision::usage=\"PolynomialDivision[PolynomialsOver[R], a, b], for \
polynomials a and b in the ring of polynomials over R, returns the pair of \
polynomials {q, r} where a = b q + r with r = 0 or deg r < deg b, provided \
that the leading coefficient of b is a unit in R. PolynomialDivision[a, b] \
works similarly as long as polynomials a and b are both from the same ring of \
polynomials. \\nThe standard (built-in) usage still exists: \
PolynomialDivision[p, q, x] gives a list of the quotient and remainder \
obtained by division of the polynomials p and q in x.\";

PolynomialEvaluation::usage = \"PolynomialEvaluation[PolynomialsOver[R], p, \
alpha] evaluates the polynomial p at alpha using the operations of the \
Ringoid R. PolynomialEvaluation[p, alpha] works similarly.\";

PolynomialGCD::usage = \"PolynomialGCD[PolynomialsOver[R], p, q] returns the \
greatest common divisor of the polynomials p and q (as elements of the ring \
of polynomials over R). PolynomialGCD[p, q] works similarly as long as \
polynomials p and q are both from the same ring of polynomials. \\nThe \
standard (built-in) usage still exists: PolynomialGCD[poly1, poly2, ...] \
gives the greatest common divisor of the polynomials poly1, poly2, ... . \
PolynomialGCD[poly1, poly2, ..., Modulus\[Rule]p] gives the GCD modulo the \
prime p.\";

PolynomialLCM::usage = \"PolynomialLCM[PolynomialsOver[R], p, q] returns the \
least common multiple of the polynomials p and q (as elements of the ring of \
polynomials over R). PolynomialLCM[p, q] works similarly as long as \
polynomials p and q are both from the same ring of polynomials. \\nThe \
standard (built-in) usage still exists: PolynomialLCM[poly1, poly2, ...] \
gives the least common multiple of the polynomials poly1, poly2, ... . \
PolynomialLCM[poly1, poly2, ..., Modulus\[Rule]p] gives the LCM modulo the \
prime p.\";

PolynomialQuotient::usage = \"PolynomialQuotient[PolynomialsOver[R], p, q] \
returns the quotient when the polynomial p is divided by the polynomial q (as \
elements of the ring of polynomials over R), provided that the leading \
coefficient of q is a unit in R. PolynomialQuotient[p, q] works similarly as \
long as polynomials p and q are both from the same ring of polynomials. \
\\nThe standard (built-in) usage still exists: PolynomialQuotient[p, q, x] \
gives the quotient of p and q, treated as polynomials in x, with any \
remainder dropped.\";

PolynomialRemainder::usage = \"PolynomialRemainder[PolynomialsOver[R], p, q] \
returns the remainder when the polynomial p is divided by the polynomial q \
(as elements of the ring of polynomials over R), provided that the leading \
coefficient of q is a unit in R. PolynomialRemainder[p, q] works similarly as \
long as polynomials p and q are both from the same ring of polynomials. \
\\nThe standard (built-in) usage still exists: PolynomialRemainder[p, q, x] \
gives the remainder from dividing p by q, treated as polynomials in x.\";

PolynomialsOfDegreeN::usage = \"PolynomialsOfDegreeN[R, n, opts] returns all \
polynomials of degree n over the ring R. Since this number can increase \
rather quickly, the option SizeLimit provides a maximum for the number of \
polynomials that will be produced. The default value is 125, but this can be \
changed using the option. Unless Indeterminate \[Rule] symbol is set, the \
default indeterminate is 'x'. A related function is \
PolynomialsUpToDegreeN.\";

PolynomialsOver::usage=\"PolynomialsOver[R] generates the RingExtension of \
polynomials over R.\";

PolynomialsUpToDegreeN::usage = \"PolynomialsUpToDegreeN[R, n, opts] returns \
all polynomials of degree n or less over the ring R. Since this number can \
increase rather quickly, the option SizeLimit provides a maximum for the \
number of polynomials that will be produced. The default value is 125, but \
this can be changed using the option. Unless Indeterminate \[Rule] symbol is \
set, the default indeterminate is 'x'. A related function is \
PolynomialsOfDegreeN.\";

PowerList::usage = \"PowerList[GF[n]] is equivalent to TableOfPowers, added \
for compatibility with the Algebra`FiniteFields` package.\";

PowersIncrease::usage = \"PowersIncrease is an option that is used in \
specifying how a polynomial should be presented when called with the Poly \
function. It takes two values, RightToLeft and LeftToRight. The former \
returns a polynomial in the form 4x^2 + 3x + 1 while the latter returns 1 + \
3x + 4x^2 for the same polynomial.\";

PreservesQ::usage = \"PreservesQ[f, {a, b}] returns True if the Morphoid f \
preserves the binary operation(s) for the pair (a,b), and False otherwise. \
Alternatively, if f is either a list of Rules, a Function or a Symbol, Si is \
a set of Elements, and opi is a binary operation, then the following are also \
acceptable usages: PreservesQ[f, {S1, op1}, {S2, op2}, {a, b}], PreservesQ[f, \
{S1, op1, op3}, {S2, op2, op4}, {a, b}]. This also supports the Visual \
Mode.\";

PreviousStage::usage = \"PreviousStage[func] returns the previous stage of an \
animation for the function func when Mode is set to Visual. \
PreviousStage[func, k] indicates that k steps backwards (or forward, if \
negative) should be taken. The functions supporting this include Closure, \
SubgroupClosure, and QuotientRing in some cases.\";

PrimeIdealQ::usage = \"PrimeIdealQ[S, R] returns True if the set S is a prime \
ideal in the structure R, and False otherwise.\";

PrimitivePolynomials::usage = \"PrimitivePolynomials[GF[n]] returns the set \
of primitive polynomials in GF[n]. (Actually, GF[n] can be replaced by any \
ring R and this will return the set of elements that generate the \
multiplicative Groupoid of non-zero elements in R.)\";

PrincipalIdeal::usage = \"PrincipalIdeal[ R, r] returns the Ringoid <r> in \
the Ringoid R. This is the principal ideal generated by r in R.\";

PrintMessage::usage=\"PrintMessage is an option for the ProbableMorphismQ \
function. When set to True (the default value), it will warn the user that a \
positive result is not absolutely certain, but only probabilistic.\";

ProbableGroupQ::usage = \"ProbableGroupQ[G] returns True or False depending \
on whether the tests for a group are valid, using RandomAssociativeQ instead \
of AssociativeQ.\";

ProbableMorphismQ::usage=\"ProbableMorphismQ[f] returns True if checking \
random pairs of elements in the domain of Morphoid f indicates that f \
preserves the operation(s), and False otherwise. This is a fast, effective, \
although not foolproof, way of testing whether a Morphoid is a morphism. The \
option SampleSize controls the number of pairs tested. SamplePairs, by \
default set to Random, controls the specific pairs (by giving positions or \
indices in the domain) to be tested, if not chosen randomly.\";

ProbableRingQ::usage = \"ProbableRingQ[R] returns True if R is probably a \
ring (all properties are checked, except associativity and distributivity use \
the randomized versions), and False otherwise.\";

ProductOrder::usage = \"ProductOrder is an option for the function \
MultiplyPermutations and other functions that call this. The value of this, \
which defaults to RightToLeft, specifies the order in which the permutations \
are multiplied. Alternatively, one can specify LeftToRight.\";

Products::usage = \"Products is a value for the Combine option of \
IntegerDivisors and ZdDivisors. With this value, the divisors of n are \
grouped in pairs {a, b} such that a*b = n.\";

ProperSubsetQ::usage = \"ProperSubsetQ[A, B] returns True if A is a proper \
subset of B, and False otherwise.\";

QuaternionGroup::usage = \"QuaternionGroup[] returns the 8 element quaternion \
group. This group can be represented in various forms; the default is to \
represent it as 2-by-2 matrices. The option Form controls what form to use, \
with the default value being AsMatrices. Other values are AsIJK and \
AsSymbols.\";

QuotientGroup::usage = \"QuotientGroup[G, N] returns the quotient group \
formed by the group G and the normal subgroup N. Options for this function \
are Form and Representatives. Form can have the value Cosets (default) which \
returns the elements in coset form g + NS or g NS where NS is a symbol \
representing the Normal Subgroup. The value CosetLists returns the quotient \
group as a list of all the cosets in list form. Alternatively, one can use \
Form \[Rule] Representatives and then only the representatives of the cosets \
will be returned. The default list of representatives uses the 'smallest' \
element in the coset and is indicated by Representatives \[Rule] Canonical; \
if you wish to change this list, use Representatives \[Rule] list, where list \
is a list of one element from each coset, or use Representatives \[Rule] \
Random to have these representatives randomly chosen. This can be used also \
if one has Form \[Rule] Cosets. By default, left cosets are used.\";

QuotientRing::usage = \"QuotientRing[R, S] returns the quotient ring formed \
by the ring R and the ideal S. Options for this function are Form and \
Representatives. Form can have the value Cosets (default) which returns the \
elements in coset form g + NS or g NS where NS is a symbol representing the \
Ideal (normal subgroup). Alternatively, one can use Form \[Rule] \
Representatives and then only the representatives of the cosets will be \
returned. The default list of representatives uses the 'smallest' element in \
the coset and is indicated by Representatives \[Rule] Canonical; if you wish \
to change this list, use Representatives \[Rule] list, where list is a list \
of one element from each coset. This can be used also if one has Form \[Rule] \
Cosets. By default, left cosets are used. For a polynomial p over the base \
ring R, QuotientRing[R, p] returns the Ringoid of polynomials mod p, if R is \
a Ringoid with unity and the leading coefficient of p is a unit of R. \
QuotientRing[Z[I], z] returns the quotient ring Z[I]/<z> for a Gaussian \
integer z; this has a Visual mode. WARNING: This function may use a lot of \
memory if R is large and/or the degree of p is large. (Note: A portion of the \
code that creates the Visual mode of QuotientRing[Z[I], z] utilize several \
functions in Stan Wagon's 'Mathematica in Action' book, pages 334, 335 (in \
the first edition from Freeman).)\";

Radical::usage = \"Radical is an option for DividesQ that specifies the value \
of d when division takes place in \[DoubleStruckCapitalZ][\\!\\(\\@d\\)]. The \
value for this option needs to be a square-free integer.\";

RandomAssociativeQ::usage = \"RandomAssociativeQ[S] returns a Boolean value \
of True or False depending on whether the structure S appears to be \
associative after 50 random choices of testing a triple of elements from S. \
RandomAssociativeQ[S, n] will randomly test n times. When used with rings, \
the Operation option can be used, which can have the value Addition, \
Multiplication or Both.\";

RandomColoredSquares::usage = \"RandomColoredSquares[n] returns a row of n \
colored squares chosen randomly from a default list. Optionally, \
RandomColoredSquares[n,colors] will choose the n from the list provided in \
colors.\";

RandomDistributiveQ::usage = \"RandomDistributiveQ[R] returns True if the \
Multiplication is likely to be distributive over the Addition in structure R \
(by checking 20 triples), and False otherwise. RandomDistributive[R, n] \
checks n triples.\";

RandomElement::usage = \"RandomElement[S] returns a random element from the \
Groupoid or Ringoid (or simply the list) S. Available options are SelectFrom \
\[Rule] NonIdentity (this, the default, guarantees that the identity is not \
selected for Groupoids and neither the zero nor the unit is selected for \
Ringoids), SelectFrom \[Rule] NonUnity (which guarantees the unity is not \
selected with Ringoids), SelectFrom \[Rule] NonZero (which guarantees the \
zero is not selected with Ringoids), and SelectFrom \[Rule] Any (which \
imposes no restrictions). For polynomial extension rings, the options \
LowerDegreeOK and Monic are also available; see these for details (after \
working with rings). Additionally, one can obtain a random element from some \
specialized sets as follows: RandomElement[Z[Sqrt[p]],max] (for p square-free \
and max defaulting to 100) returns a + b Sqrt[p] with both a and b in the \
range [-max, max]. One can use p = -1 also, or use equivalently use Z[I].\";

RandomElements::usage = \"RandomElements[S, n] returns a set of n random \
elements from the Groupoid or Ringoid (or list) S. Available options are \
SelectFrom \[Rule] NonIdentity (this default guarantees that the identity is \
not selected for Groupoids and neither the zero nor the unit is selected for \
Ringoids), SelectFrom \[Rule] NonZero (which guarantees the zero is not \
selected with Ringoids), and SelectFrom \[Rule] Any (which imposes no \
restrictions). Additionally, Replacement \[Rule] True will allow an element \
to be selected more than once (while set to False will not allow this). \
Additionally, one obtain a random element from some specialized sets as \
indicated under RandomElement, by adding the final parameter indicating how \
many to choose.\";

RandomGroupoid::usage = \"RandomGroupoid[n, k] returns a random Groupoid of \
order n. If k = 1, the Cayley table is a collection of n^2 random elements \
from a list of n generic elements; if k = 2, each row is a permutation of a \
list of n generic elements; if k = 3, each column is a permutation of a list \
of n generic elements.\";

RandomMatrix::usage = \"RandomMatrix[R, n, MatrixType \[Rule] type] returns a \
random n-by-n matrix over the Ringoid R of the specified type; see MatrixType \
for the possible values.\";

RandomPermutation::usage = \"RandomPermutation[n] returns a random \
permutation of length n. (This is a modified version of that found in the \
DiscreteMath`Permutations` package.)\";

Randomize::usage = \"Randomize[list] will randomly permute the elements in \
list.\";

RationalMatrixQ::usage = \"RationalMatrixQ[A] returns True or False depending \
on whether the matrix A has all of its entries being rational numbers (in the \
mathematical sense - entries can be Integer or Rational).\";

RationalRootCandidates::usage = \"Ration alRootCandidates[poly] returns a \
list of candidates for the Rational Root Theorem, given the polynomial \
poly.\";

RationalRootTheorem::usage = \"RationalRootTheorem[poly] returns a list of \
two lists, given a polynomial poly. The first list consists of those rational \
candidates which are zeros for poly, while the second list consists of those \
rational candidates which are not zeros for poly.\";

RealMatrixQ::usage = \"RealMatrixQ[A] returns True or False depending on \
whether the matrix A has all of its entries being real numbers (in the \
mathematical sense - entries can be Integer, Rational, Algebraic, or \
Real).\";

ReduceList::usage = \"ReduceList[polyList] effectively is the equivalent to \
Union[polyList, SameTest \[Rule] Equal] where polyList is a list of \
polynomials formed using the Poly function and Equal is the function designed \
to test when two polynomials built from Poly are equal.\";

Ref::usage = \"This is the standard (default) symbol to represent a \
reflection when working with the dihedral group D[n].\";

RefSym::usage = \"When working with dihedral groups, by default we use the \
option RefSym \[Rule] Ref. This can be changed so that any other symbol is \
used to represent the reflection. See Dihedral for more information.\";

ReorderGroupoid::usage = \"ReorderGroupoid[G, neworder] takes the Groupoid G \
and forms a new Groupoid with all the properties of G using the order of the \
elements presented in neworder. (Note that mathematically the result of this \
and G are identical since groups do not have an order assumed among the \
elements. This is simply for the convenience of using the functions in these \
packages.)\";

Replacement::usage = \"Replacement is an option for RandomElement and \
RandomElements. The value True means that replacement is to be allowed while \
False if not.\";

ReportIterations::usage = \"ReportIterations is a Boolean option for Closure. \
If set to true, all of the iterations of the closure process will also be \
shown, in addition to the final result.\";

Representatives::usage = \"Representatives is a value for the Form option of \
QuotientGroup and QuotientRing. This causes the elements to be written as \
representatives of the cosets. Representatives is also an option name for \
QuotientGroup and QuotientRing. It can take values Canonical (default), \
Random, or {g1, g2,...} where the gi's are representatives from the cosets. \
The Canonical option uses the 'first' element in the coset, while the Random \
chooses them randomly.\";

RestrictList::usage = \"RestrictList[r], given a rule r given as either {i \
\[Rule] j} or as i \[Rule] j, will produce output similar to what is given in \
ShowPossiblePermsAsRules except that only those permutations containing r \
will be shown. This can be useful if you are exploring what possibilities \
exist given vertex i is to go to vertex j. RestrictList[{r1, r2,..}] is \
similar except it will take the intersection of what is obtained by \
RestrictList[r1], RestrictList[r2]...\";

RightCoset::usage = \"RightCoset[G, H, g] returns the right coset Hg (or H + \
g) when given the element g from G and the subgroup H of G.\";

RightCosets::usage = \"RightCosets[G, H] returns a list of the cosets of the \
subgroup (or subring) H in the Groupoid (or Ringoid) G.\";

RightDistributiveQ::usage = \"RightDistributiveQ[R] returns True if the \
Multiplication is right distributive over the Addition in the structure R, \
and False otherwise.\";

RightIdealQ::usage = \"RightIdealQ[S, R] returns True if the set S is a right \
ideal of the structure R, and False otherwise.\";

RightIdentity::usage = \"RightIdentity[G] returns the right identity of the \
Groupoid G, if one exists, or $Failed otherwise.\";

RightInverse::usage = \"RightInverse[G, g] returns the right inverse of g in \
G, if it exists, otherwise $Failed.\";

RightInvertibleQ::usage = \"RightInvertibleQ[G, g] returns True if the right \
inverse of g in G exists, and False otherwise.\";

RightToLeft::usage = \"RightToLeft is a value for the ProductOrder option for \
the MultiplyPermutations and MultiplyCycles functions, as well for the \
PowersIncrease option for Poly (when working with polynomials over a ring). \
When ProductOrder is set to this value, then MultiplyPermutations[p2,p1] will \
be computed by taking p1 followed by p2. For the use in Poly, see \
PowersIncrease.\";

RightToLeft::usage = \"RightToLeft is a value for the ProductOrder option of \
MultiplyPermutations and MultiplyCycles, as well for the PowersIncrease \
option for Poly (when working with polynomials over a ring). When \
ProductOrder is set to this value, then MultiplyPermutations[p2,p1] will be \
computed by taking p1 followed by p2. For the use in Poly, see \
PowersIncrease.\";

Ring::usage = \"Ring is a value for the Structure option that is used for \
several functions, including FormMorphoid, ZMap, and Z (including Z[n] and \
Z[n, I]). It is also an acceptable argument for the SwitchStructureTo \
function.\";

RingExtension::usage=\"RingExtension is the head for ring extensions.\";

RingInfo::usage = \"RingInfo[R] is a list of facts about R that are generated \
by various tests of R.\";

RingInfo::usage = \"RingInfo[R] returns a list of information obtained about \
the Ringoid R which has been gathered by calling various functions.\";

RingQ::usage = \"RingQ[R] returns True if R is a ring, and False \
otherwise.\";

RingSolve::usage = \"RingSolve[R, a, b] solves the linear equation a x == b \
in the Ringoid R, returning a list of elements that solve the equation. The \
Solve command may also be useful.\";

Ringoid::usage = \"Ringoid is the head for a triple where the first component \
is a set of elements and the second and third are the addition and \
multiplication operations. A Ringoid is one of the basic structures of these \
packages.\";

RingoidDescription::usage = \"RingoidDescription[R] returns a description, if \
given, of the ring R. This can be set with the RingoidDescription option (of \
the same name) in FormRingoid. If the empty string is returned, no \
description has been given.\";

RingoidName::usage = \"RingoidName[R] yields the name, if given, of the \
Ringoid R. This can be set with the RingoidName option (of the same name) in \
FormRingoid. If the empty string is returned (or TheRing, the default value), \
no name has been given.\";

Rings::usage = \"Rings is an acceptable name for the SwitchStructureTo \
function.\";

RootsOfUnity::usage = \"RootsOfUnity[n] returns the Groupoid consisting of \
the n complex roots of the equation z^n = 1, under multiplication.\";

Rot::usage = \"This is the standard (default) symbol used to represent the \
rotation of the smallest angle when working with the dihedral group D[n].\";

RotRef::usage = \"RotRef is a value for the Form option when working with the \
dihedral group. See Dihedral for more information.\";

RotSym::usage = \"When working with dihedral groups, by default we use the \
option RotSym \[Rule] Rot. This can be changed so that any other symbol is \
used to represent the rotation. See Dihedral for more information.\";

Rules::usage=\"Rules is a value for the FunctionForm option.\";

S::usage = \"S[n] returns the group of permutations on the set {1,2,..n} \
under composition. See Symmetric.\";

SE::usage = \"SE[n] is the nth 'Standard Example' group from a list of \
commonly used groups.\";

SL::usage = \"SL[n, R] (alternately, SL[R, n]) returns the extension of \
invertible n-by-n matrices over the Ringoid R that have determinant Unity[R]. \
For a positive integer k, SL[n,k] is equivalent to SL[n,Z[k]].\";

SLQ::usage = \"SLQ[R, A] returns True or False depending on whether the \
matrix A over the Ringoid R is in SL[R, n] (where A is an n-by-n matrix).\";

SamePermutationQ::usage = \"SamePermutationQ[cyclist1, cyclist2] returns True \
if the cycle representation for the permutation found in cyclist1 yields the \
same permutation represented by cyclist2, and False otherwise.\";

SameSetQ::usage = \"SameSetQ[list1, list2] returns True if the sets list1 and \
list2 are equal as sets, and False otherwise. Note that this tests the \
mathematical equality of two sets and so SameSetQ[{2,3,1},{1,3,2}] returns \
True while SameQ[{2,3,1},{1,3,2}] returns False.\";

SamplePairs::usage=\"SamplePairs is an option for ProbableMorphismQ, whose \
default value is Random, meaning the pairs are chosen randomly. \
Alternatively, the value Default uses a short, built-in list of pairs, one \
can give a list of pairs of indices (not elements) to test, for example: \
{{2,3},{3,5}}.\";

SampleSize::usage=\"SampleSize is an option for ProbableMorphismQ that \
specifies the number of tests to perform.\";

SelectBaseElementsFrom::usage = \"SelectBaseElementsFrom is an option for \
RandomElement and RandomElements when using extension rings. The acceptable \
values for this option are Any, NonZero, NonUnity and NonIdentity.\";

SelectFrom::usage = \"SelectFrom is an option for RandomElement and \
RandomElements. For Groups, the values are Any and NonIdentity; the former \
allows any element to be returned while the latter will not return the \
identity element, if one exists. For Ringoids, NonZero and NonUnity are also \
available values.\";

SemiGroupQ::usage = \"SemiGroupQ[G] returns True if G is a semi-group (a set \
that is closed under a binary operation that is associative), and False \
otherwise.\";

Sgn::usage = \"Sgn[G] gives the Morphoid whose domain is the group of \
permutations G and codomain is the group IntegerUnits and the function is the \
Parity function.\";

ShowBodyText::usage = \"ShowBodyText is an option for CayleyTable with \
settings True or False depending on whether the text in the body of the table \
is to be shown.\";

ShowCircle::usage = \"ShowCircle[n] creates a unit circle with n points \
labeled {0,1,..n-1} starting at (0,1). ShowCircle[n,labels] is similar except \
the set labels is used for the labeling.\";

ShowColoredPermutation::usage = \"ShowColoredPermutation[p] is similar to \
PermuteColoredSquares except that it does not require RandomColoredSquares to \
be called first.\";

ShowFigure::usage = \"ShowFigure[n, perm, sym] draws an ngon with permutation \
perm applied to the vertices and having Dihedral or Cyclic symmetry group if \
sym is D or Z respectively. ShowFigure[perm] will apply the permutation perm \
to the vertices of the figure, with the permutation in list or rule form. \
Additionally, assuming a figure has already been drawn, ShowFigure[] will \
redraw it.\";

ShowGroupOrders::usage = \"ShowGroupOrders[G] displays a ListPlot containing \
pairs {g,|g|} for all g in the Groupoid G. It also shows a bar chart \
indicating how many elements there are of each order in the Groupoid G\";

ShowKey::usage = \"ShowKey is an option for CayleyTable with settings True or \
False depending on whether a key is shown when the elements in the set are \
too wide and a key needs to be used for identification purposes.\";

ShowName::usage = \"ShowName is an option for CayleyTable with settings True \
or False depending on whether the name of the structured set is to be \
shown.\";

ShowOne::usage = \"ShowOne[Labx] shows the appropriate information needed for \
lab numbered x. Note that ShowOne[Lab2,k] returns the group k while \
ShowOne[Lab3, k] returns case k, if one needs to return to a specific group \
in Lab 2 or case in Lab 3.\";

ShowOperator::usage = \"ShowOperator is an option for CayleyTable with \
settings True or False depending on whether the symbol for the operation of \
the structured set is to be shown.\";

ShowPermutation::usage = \"ShowPermutation[perm] shows a graphics array of \
the (predetermined) n-gon (if n>2) 'before' and 'after' the permutation perm \
has been applied. The permutation can be in list form or rule form. \
ShowPermutation[n, perm, symtype] combines ShowFigure[n, IdentityPermutation, \
symtype] with ShowPermutation[perm].\";

ShowPossiblePermsAsRules::usage = \"ShowPossiblePermsAsRules[n] shows the \
complete list of all possible permutations of the integers {1,2,3,...n} where \
n must be 5 or less. If the object in question is an n-gon, then use n as the \
parameter. This differs from ShowPossiblePermutations only in the way they \
are presented - here as rules. Note that the permutations are labeled ppp[i] \
and these labels can be used to refer to the given permutation.\";

ShowPossiblePermutations::usage = \"ShowPossiblePermutations[n] shows the \
complete list of all possible permutations of the integers {1,2,3,...n} where \
n must be 5 or less. If the object in question is an n-gon, then use n as the \
parameter. Note that the permutations are labeled ppp[i] and these labels can \
be used to refer to the given permutation.\";

ShowSidesText::usage = \"ShowSidesText is an option for CayleyTable with \
settings True or False depending on whether the text in the top row and left \
column (representing the elements of the Groupoid) is to be shown.\";

SideBySideMatrices::usage = \"SideBySideMatrices[p,q] displays permutation p \
as a matrix on the left and permutation q as a matrix on the right, with some \
space in between. This simply illustrates how we begin to multiply \
matrices.\";

Size::usage = \"Size[S] returns the cardinality of the set of elements in the \
structured set S. This is identical to the function Order.\";

SizeLimit::usage = \"SizeLimit is an option for the GenerateGroupoid \
function. By default it is set to 25. When the size of the generated set \
exceeds this limit, no further generation will take place.\";

SizeOfMatrices::usage = \"SizeOfMatrices[matrixExtension] returns the \
dimensions of the matrices used in this extension ring.\";

SkewHermitianQ::usage = \"SkewHermitianQ[A] returns True or False depending \
on whether the matrix A is skew-Hermitian in the sense that A = \
-Adjoint[A].\";

SkewSymmetricQ::usage = \"SkewSymmetricQ[R, A] returns True or False \
depending on whether the matrix A is skew-symmetric in the sense that A = \
-Transpose[A]. For matrices with numeric entries (over Integers, Rationals, \
Reals or Complex), SkewSymmetricQ[A] works similarly.\";

Solve::usage = \"Solve[PolynomialsOver[R], poly == r], when given a \
polynomial poly from the ring of polynomials over the Ringoid R and an \
element r from R, solves the equation poly == r in the indeterminate x. \
(Solve[poly == r] can also be used, with the underlying ring extracted from \
poly.) Solutions are returned as a list of rules (as per normal usage). These \
solutions can be used with ReplaceAll (or its equivalent, /.) just as the \
results of the ordinary (built-in) Solve, whose functionality still works: \
\\nSolve[eqns, vars] attempts to solve an equation or set of equations for \
the variables vars. Any variable in eqns but not vars is regarded as a \
parameter. Solve[eqns] treats all variables encountered as vars above. \
Solve[eqns, vars, elims] attempts to solve the equations for vars, \
eliminating the variables elims.\";

SortGroupoid::usage = \"SortGroupoid[G] returns the Groupoid with the \
elements sorted by the Sort function. Typically, this is already the case.\";

SpecialLinear::usage = \"SpecialLinear[args] - see SL.\";

SpecialLinearGroup::usage = \"SpecialLinearGroup[args] - see SL.\";

Stabilizer::usage = \"Stabilizer[G, S, x] returns the stabilizer of the \
element x (from S) in the group G. Here, G is a group of permutations of the \
set S. Stabilizer[S, x] assumes G is the full set of all permutations of \
S.\";

Staged::usage = \"This is an option for some functions (including Closure, \
SubgroupClosure, and QuotientRing in some cases) and can be set to True if an \
animation is to be conducted manually using NextStage and PreviousStage, and \
False otherwise.\";

Structure::usage = \"Structure is an option for several functions. Using \
Structure \[Rule] Group (default when working with groups) specifies that we \
are working with a group structure, while Structure \[Rule] Ring (default in \
Rings) specifies that rings are involved. Functions that have this option are \
ZMap, FormMorphoid, and Z (and related functions).\";

SubgroupClosure::usage = \"SubgroupClosure[G, H] returns the subgroup of G \
generated by the elements in the set H (which is a subset of G). The option \
ReportIterations (defaults to False) indicates whether the result of each \
iteration is also returned. The option Staged (default to False), applicable \
if Mode \[Rule] Visual is given, indicates whether or not the graphics are \
shown one stage at a time. If set to true, NextStage[SubgroupClosure] returns \
the next iteration and PreviousStage[SubgroupClosure] returns the previous \
iteration.\";

SubgroupConjugate::usage = \"SubgroupConjugate[G, H, x] returns the set x H \
x^(-1) for the subgroup H of the Groupoid G.\";

SubgroupGenerated::usage = \"SubgroupGenerated[G, g] returns the subgroup \
generated by the element g in the group G. Options include Mode \[Rule] \
Visual2 (as well as the other modes). When using the Visual mode, Output \
\[Rule] GraphicsArray causes the graphics to be placed in array form, rather \
than being presented serially.\";

SubgroupIntersection::usage = \"SubgroupIntersection[G, H, K] returns the \
subGroupoid of G which is the intersection of subgroups H and K.\";

SubgroupJoin::usage = \"SubgroupJoin[G, H, K] returns the subGroupoid of G \
generated by the elements in the subgroups H and K.\";

SubgroupProduct::usage = \"SubgroupProduct[G, H, K] returns the subGroupoid \
(of G) HK = {hk | h in H, k in K} for subgroups H and K.\";

SubgroupQ::usage = \"SubgroupQ[H, G] returns True if H is a subgroup of the \
group G, and False otherwise. H can be in the form of a list of elements or a \
Groupoid consisting of elements from G. Options include Mode \[Rule] Visual2 \
(as well as the other modes).\";

SubgroupUnion::usage = \"SubgroupUnion[G, H, K] returns the subGroupoid of G \
which is the union of subgroups H and K.\";

Subgroupoid::usage = \"Subgroupoid[G, H] creates the Groupoid with the \
elements from the list H (assumed to be elements from G) and the operation \
from the Groupoid G. Subgroupoid[G,{H1, H2}] or Subgroupoid[{G, H1}, {G, H2}] \
can be used if there are 2 (or more) subsets H.\";

Subgroups::usage = \"Subgroups[G] returns a list of all the subgroups of the \
group G. Warning: This may take a long time for high order (non-cyclic) \
groups!\";

SubringQ::usage = \"SubringQ[S, R] returns True if S is a subring of R, and \
False otherwise. (This function tests whether S is nonempty and closed with \
respect to difference and multiplication in R.)\";

SubsetQ::usage = \"SubsetQ[A, B] returns True if A is a subset of B, and \
False otherwise.\";

SurjectiveQ::usage=\"Surjective[f] returns True if the Morphoid f is \
surjective (onto), and False otherwise.\";

SwitchStructureTo::usage = \"SwitchStructureTo[structure] sets various \
options and definitions so that the given structure is the default. \
Acceptable values are Group (or Groups or Groupoid) and Ring (or Rings or \
Ringoid).\";

Symmetric::usage = \"Symmetric[n] returns the group of permutations on the \
set {1,2,..n} under composition. There are two options for this function, \
ProductOrder and IndexLimit. Since the elements of this group are \
permutations, one can specify the order that the product is taken by using \
ProductOrder; see ProductOrder for more information, including the values \
which can be used. IndexLimit defaults to 6 and indicates the upper limit for \
the value of the index n.\";

SymmetricGroup::usage = \"SymmetricGroup[n] behaves just as the function \
Symmetric, but also has the functionality of PermutationGroup.\";

SymmetricQ::usage = \"SymmetricQ[R, A] returns True or False depending on \
whether the matrix A is symmetric.  For matrices with numeric entries (over \
Integers, Rationals, Reals or Complex), SymmetricQ[A] works similarly.\";

TableOfPowers::usage = \"TableOfPowers[GF[n]] returns a table consisting of \
first the element {0, 0} followed by pairs of the form {poly^j, r} where r is \
an element in GF[n], poly is the 'simplest' primitive polynomial for this \
ring, and j is the power to which poly needs to be raised to be equal to \
r.\"; 

TestFunction::usage = \"TestFunction[ext] returns the function for the ring \
extension ext that determines if an element is a member of the extension.\";

TestPermutationQ::usage = \"TestPermutationQ[p] tests to see if p is indeed a \
symmetry of the object given by ShowOne[Lab2]. True or False is returned. The \
permutation p can be as a simple list or as a list of rules.\";

TextCayley::usage = \"TextCayley[G] returns a simple, text-only version \
equivalent of CayleyTable[G, Mode \[Rule] Visual].\";

Textual::usage = \"Mode \[Rule] Textual is a common option for many functions \
in these packages. Generally, a written description and/or definition will be \
given to help clarify the function/concept being explored.\";

TheSet::usage = \"TheSet is an option for the CayleyTable function to be used \
to change the order that the elements appear in the construction of the \
table. TheSet \[Rule] list indicates that Elements[S] are to be arranged \
according to the order in list and then the Cayley table is constructed with \
this ordering. To change the ordering on a more permanent basis, see \
ReorderGroupoid.\";

TimesSymbol::usage = \"TimesSymbol is an option to FormRingoid to specify the \
symbol used for multiplication in forming a Ringoid. The default value is \
*.\";

ToCycles::usage =\"ToCycles[p] writes the permutation p as a list of disjoint \
cyclic permutations (i.e., cycles) whose product is p. If p is a list of \
permutations, this will return a list of cycles for each permutation. There \
are two options for ToCycles, CycleAs and Normalize. Using CycleAs \[Rule] \
List, the cycles are returned in the form returned by the ToCycles function \
in the DiscreteMath`Permutations` package (so that the permutation {2,1,4,3} \
is returned as {{2,1},{4,3}}), while CycleAs \[Rule] Cycle (default) uses \
Cycle[2,1] for {2,1} in the cycle list. If CycleAs \[Rule] Cycle is used, \
Normalize \[Rule] True (default) applies NormalizeCycleList to the list of \
cycles. See Normalize for details on how this works.\";

ToFunction::usage = \"ToFunction[rules] returns a function of the form ffx \
(where x is an integer), which is the result of converting the list of rules \
to a function. ToFunction[rules, f] specifies that the returned function is \
represented by the symbol f. ToFunction[f] converts the Morphoid based on the \
Rules definition to one based on a Function (or Symbol) definition, using a \
function of the form ffx (where x is an integer). ToFunction[f, g] specifies \
that the returned function is represented by the symbol g.\";

ToGroupoid::usage = \"ToGroupoid[extension], where extension might be GL[R,n] \
or some similar extension (such as MatricesOver[R, {m,n}, opts]), calculates \
the actual elements and forms a Groupoid when the number of elements is not \
larger than the default value of the option SizeLimit. Setting this option \
higher allows more Groupoids to be formed, but one needs to be sure there is \
sufficient memory to do so, since these Groupoids can become rather large. \
Using Size first may be a good idea, to see how many elements there are. To \
just get the list of elements, use the function Elements (which uses the same \
SizeLimit restriction).\";

ToOrdinaryPolynomial::usage = \"ToOrdinaryPolynomial[p] returns an expression \
that will be regarded as a polynomial in Mathematica's ordinary sense. Note \
that the underlying ring is lost in this transition and the new polynomial \
may or may not make sense (for ordinary Mathematica functions), depending on \
the ring.\";

ToPermutation::usage = \"ToPermutation[RuleList] returns the permutation \
determined by a list of rules. For example, {1\[Rule]2, 2\[Rule]1} becomes \
{2,1}. Similarly, {{1\[Rule]2}, {2\[Rule]1}} becomes {2,1}. ToPermutation[c, \
n] rewrites the cycle c of length <= n as a permutation of length n (or in \
S[n]). ToPermutation[c] uses the maximum value appearing in c for n.\";

ToRingoid::usage = \"ToRingoid[Mat[R, n]], if the SizeLimit permits, returns \
the Ringoid consisting of the n-by-n matrices over the Ringoid R. See \
ToGroupoid for more details.\";

ToRules::usage = \"ToRules[f, S] converts the function f with domain S to a \
list of rules of the form x \[Rule] f[x]. When it is important to check that \
the range values belong to a set T, use ToRules[f, S, T] (which returns \
$Failed if T does not contain all the images). S can be a list of values, a \
Groupoid, or a Ringoid. ToRules[f], where f is a Morphoid, converts the \
Morphoid based on a Function (or Symbol) to one based on a list of rules. \
ToRules[perm] converts any permutation (as a list) to a list of rules. For \
example, {2,1,3} becomes {1\[Rule]2, 2\[Rule]1, 3\[Rule]3}. \\nThe standard \
(built-in) usage still exists: ToRules[eqns] takes logical combinations of \
equations, in the form generated by Reduce or Roots, and converts them to a \
sequence of lists of rules where the sequence corresponds to Or and the lists \
correspond to And. {ToRules[eqns]} gives a result of the form produced by \
Solve.\";

ToTranspositions::usage = \"ToTranspositions[c] rewrites the cycle c as a \
product of transpositions. ToTranspositions[perm] rewrites the permutation \
perm as a product of transpositions.\";

Trivial::usage = \"Trivial returns the trivial Groupoid consisting of just a \
single element.\";

TrivialZR::usage = \"TrivialZR[n] returns the ring of integers mod n with mod \
n addition but a multiplication with all products being zero.\";

TwistedZ::usage = \"TwistedZ[n] returns the Groupoid with elements {0, 1, ... \
n-2} and operation Mod[#1 + #2 + #1 #2, n]&.\";

U::usage = \"U[n] returns the group of integers mod n which are relatively \
prime to n, under multiplication. These elements are also the units in the \
ring Z[n]. (In other words, these are the elements that have inverses in the \
Groupoid Zx[n].)\";

UT::usage = \"UT[n, R] (alternately, UT[R, n]) returns the extension of \
n-by-n upper triangular matrices (fully above the diagonal) over the Ringoid \
R.\";

UTD::usage = \"UTD[n, R] (alternately, UTD[R, n]) returns the extension of \
n-by-n upper triangular matrices (including the diagonal) over the Ringoid R.\
\";

UnionNoSort::usage = \"UnionNoSort[list] removes duplicates in list but does \
NOT sort list as the Union function does. UnionNoSort[list1, list2,...] \
returns a single list with all duplicates removed, but unsorted. (This also \
works with other structures besides Lists.)\";

UnitQ::usage = \"UnitQ[R, r] returns True if r is a unit in the structure R, \
and False otherwise.\";

UnitaryQ::usage = \"UnitaryQ[A] returns True or False depending on whether \
the matrix A (over the complex numbers) is an unitary matrix in the sense \
that the product of the adjoint of A and A itself is the identity matrix.\";

Units::usage = \"Units[R] returns the list of units of the structure R.\";

Unity::usage = \"Unity[R] returns the unity of R, if one exists in R, and \
$Failed otherwise.\";

ValuesHavingGivenNorm::usage = \"ValuesHavingGivenNorm[d, nrm], for negative \
d, returns the list (possibly empty) of values in Z[Sqrt[d]] that have the \
norm value of nrm. For positive d, ValuesHavingGivenNorm[d, nrm, iter] \
returns a (partial) list of values having the given norm obtained after iter \
number of iterations of an algorithm to search along the relevant hyperbola. \
The value for iter defaults to 50 if omitted. For positive d, the list is \
incomplete.\";

VarToUse::usage = \"VarToUse is an option for CayleyTable to specify the \
generic label for elements in the body of the Cayley table when the elements \
are wide and a key is used. (See ShowKey.)\";

Verbal::usage = \"Special symbol used for this lab.\";

Visual2::usage = \"Mode \[Rule] Visual2 is an option for some functions in \
these packages. Generally, some visual component will be drawn that is \
intended to further clarify the meaning of a concept/function.\";

Visual::usage = \"Mode \[Rule] Visual is a common option for many functions \
in these packages. Generally, some visual component will be drawn which is \
intended to further clarify the meaning of a concept/function.\";

VisualTextShown::usage = \"VisualTextShown is a global variable whose value \
indicates the number of times any text accompanying a graphic image should be \
shown. (If multiple graphic images are shown, the text will never be \
displayed.) For single images, the variable can be set to Infinity, to always \
display the text; n, to only show it the first n times (a particular function \
is called); or 0, to never show the text.\";

VisualizeMorphoid::usage = \"VisualizeMorphoid[f, opts] provides a \
visualization of the Morphoid f by using arrows from the domain to the \
codomain to indicate the map. Available options are ColorDomain and \
ColorCodomain, both of whose default value is {}. See these names for more \
details.\";

WideElements::usage = \"WideElements is an option for functions which form \
Groupoids or Ringoids, whose default value is False. When set to True, any \
formation of a Cayley table will set up a key, under the assumption that the \
elements are too wide to fit in the grid of the Cayley table.\";

WithImages::usage = \"WithImages is an option for the InverseImages function. \
If set to False (default), only the list of inverse images are listed, while \
if set to True, each inverse image is listed with its image element.\";

WithUnityQ::usage = \"WithUnityQ[R] returns True if the structure R has a \
unity, and False otherwise.\";

Z::usage = \"Z[n] returns the cyclic group of integers mod n under addition \
when in the context of groups or the ring of integers mod n when in the \
context of rings. The option Structure can be set to Group or Ring; by \
default, when working with groups, it is set to Group and set to Ring when \
working with rings. (See SwitchStructureTo for further information.) Note \
that ZG[args] is equivalent to Z[args, Structure \[Rule] Group], while \
ZR[args] is equivalent to Z[args, Structure \[Rule] Ring]. Z[n, k] returns \
the group (or ring) of multiples of k mod n, if k is a divisor of n. \
Additionally, Z[n, I] when working with groups (or Z[n, I, Structure \[Rule] \
Group] while working with rings) returns the additive Gaussian integers mod \
n, while Z[n, I] returns the ring of Gaussian integers mod n when working \
with rings.\";

ZG::usage = \"ZG[n] returns the group of integers mod n with the operation \
addition mod n. ZG[n, k] returns the ring of multiples of k mod n if k is a \
divisor of n. This is equivalent to Z[n, Structure \[Rule] Group].\";

ZMap::usage = \"ZMap[m, n] creates Morphoid[Mod[#, n]&, Z[m], Z[n]]. ZMap[m, \
n, g \[Rule] h] creates Morphoid[g \[Rule] h, Z[m], Z[n]], where g must be a \
generator in Z[m]. In either case, one can add the option Structure \[Rule] \
Ring to indicate that Z[m] and Z[n] should be considered rings.\";

ZR::usage = \"ZR[n] returns the ring of integers mod n with operations \
addition mod n and multiplication mod n. ZR[n, k] returns the ring of \
multiples of k mod n if k is a divisor of n. This is equivalent to Z[n, \
Structure \[Rule] Ring].\";

ZdAssociatesQ::usage = \"ZdAssociatesQ[d, a, b] returns True if a and b are \
associates over \[DoubleStruckCapitalZ][\\!\\(\\@d\\)], and False \
otherwise.\";

ZdCombineAssociates::usage = \"ZdCombineAssociates[d, lst] takes the list of \
elements lst from \[DoubleStruckCapitalZ][\\!\\(\\@d\\)] and returns a new \
list of lists, with each new list containing those elements in lst that are \
associates with each other.\";

ZdConjugate::usage = \"ZdConjugate[a + b Sqrt[d]] returns a - b \
\\!\\(\\@d\\), the conjugate in \[DoubleStruckCapitalZ][\\!\\(\\@d\\)].\";

ZdDivide::usage = \"ZdDivide[x, y] returns the quotient x/y in the form r + s \
\\!\\(\\@d\\) when x and y are both in \
\[DoubleStruckCapitalZ][\\!\\(\\@d\\)].\";

ZdDividesQ::usage = \"ZdDividesQ[d, a, b] is equivalent to DividesQ[a, b, \
Radical \[Rule] d].\";

ZdDivisors::usage = \"ZdDivisors[d, x, (opts)], when d is negative, returns \
all the divisors of the number x in \[DoubleStruckCapitalZ][\\!\\(\\@d\\)], \
possibly restricted by the options in opts. When d is positive, ZdDivisors[d, \
x, max] returns all the divisors of x (possibly modified by opts) in \
\[DoubleStruckCapitalZ][\\!\\(\\@d\\)] whose norm is less than or equal to \
the norm of the integer max. Available options are Combine, NonTrivialOnly, \
and DivisorsComplete. See them for more details.\";

ZdIrreducibleQ::usage = \"ZdIrreducibleQ[d, x], for negative d, returns True \
if x is irreducible in \[DoubleStruckCapitalZ][\\!\\(\\@d\\)], and False \
otherwise.\";

ZdNorm::usage = \"ZdNorm[x] returns the norm of x as an element in \
\[DoubleStruckCapitalZ][\\!\\(\\@d\\)] for some d, which is the value |a^2 - \
d b^2| when x = a + b \\!\\(\\@d\\).\";

ZdPossibleNormQ::usage = \"ZdPossibleNormQ[d, nrm], for negative d only, \
returns True if the value nrm can occur (i.e., it is possible) in \
\[DoubleStruckCapitalZ][\\!\\(\\@d\\)], and False otherwise.\";

ZdPossibleNorms::usage = \"ZdPossibleNorms[d, max], for negative d only, \
returns all the norms that can occur in \
\[DoubleStruckCapitalZ][\\!\\(\\@d\\)] that are less than or equal to max. \
This function has a Visual mode available.\";

ZdQ::usage = \"ZdQ[x] returns True if x can be viewed as an element in \
\[DoubleStruckCapitalZ][\\!\\(\\@d\\)] for some d, and False otherwise.\";

ZdUnitQ::usage = \"ZdUnitQ[d, x] returns True if x is a unit in \
\[DoubleStruckCapitalZ][\\!\\(\\@d\\)], and False otherwise.\"; 

Zero::usage = \"Zero[R] returns the zero of R, if one exists in R, and \
$Failed otherwise.\";

ZeroDivisorQ::usage = \"ZeroDivisorQ[R, r] returns True if r is a zero \
divisor of the structure R, and False otherwise. Since this calls \
ZeroDivisors (which generates a complete list of zero divisors), a noticeable \
delay may be noticed upon the first call for large Ringoids.\";

ZeroDivisors::usage = \"ZeroDivisors[R] returns a list of all the zero \
divisors in the structure R. If R does not have a zero (HasZeroQ[R] == \
False), a message is returned. This calculation is based on the definition \
that if nonzero r and nonzero s have the product Zero[R], then r and s are \
both zero divisors.\"; 

Zeros::usage = \"Zeros[PolynomialsOver[R], p] returns the zeros, if any, of \
the polynomial p as a polynomial with coefficients from R. In other words, if \
z is the zero of R, this returns {x : p(x) = z}. Zeros[p] is another method \
of obtaining the same result.\";

Zx::usage = \"Zx[n] returns the Groupoid of integers mod n under \
multiplication. Zx[n, k] returns the Groupoid of multiples of k mod n, if k \
is a divisor of n. Finally, Zx[n, I] returns the Groupoid of the Gaussian \
integers under mod n multiplication.\"; 

myDiv::usage = \"Special symbol used for this lab.\";

myDivisorSigma::usage = \"Special symbol used for this lab.\";

myDot::usage = \"Special symbol used for this lab.\";

myMod::usage = \"Special symbol used for this lab.\";

myPower::usage = \"Special symbol used for this lab.\";

myZees::usage = \"Special symbol used for this lab.\";

quatOp::usage = \"Special symbol used for this lab.\";

trivProd::usage = \"Special symbol used for this lab.\";

undef::usage = \"Special symbol used for this lab.\";

\
\>", "Input",
 CellTags->"usagealpha"]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.5 Usage statements by packages", "Subsection",
 FontFamily->"Times",
 CellTags->{"usagepackages", "i:23"}],

Cell[CellGroupData[{

Cell["6.3.5.1 Core", "Subsubsection",
 CellTags->{"CoreUsage", "usagepackages"}],

Cell["\<\
Addition::usage = \"Addition[S] is the addition operator in the Ringoid S. If \
S is a Groupoid, Addition[S] is simply the Groupoid's operation. Given an \
extension Ext of a ring, Addition[Ext] is the addition in this extension. \
Addition is also a value for the Operation option that is used in some ring \
functions.\";

Adjoin::usage = \"Adjoin[list, num] returns the elements in list with num \
adjoined. If num is the nth root of rad, then the set of all 'polynomials' of \
degree less than n in the 'indeterminate' rad with coefficients from list is \
returned. If num is anything else, the function fails. Adjoin[S, num], for a \
structured set S, is equivalent to Adjoin[Elements[S], num]. Adjoin[list, \
ind, deg] returns the set of polynomials in the indeterminate ind of degree \
deg (or less) with coefficients from list. Adjoin[S, ind, deg], for a \
structured set S, is equivalent to Adjoin[Elements[S], ind, deg].\";

Any::usage = \"Any is a value for the SelectFrom option for RandomElement and \
RandomElements. This value allows any element to be returned. Alternatively, \
one may use NonIdentity (or NonZero or NonUnity when working with rings).\";

AssociativeQ::usage = \"AssociativeQ[S] returns True if the structure S is \
associative, and False otherwise. When used with rings, one has the Operation \
option, which can have the value Addition, Multiplication or Both.\";

BackgroundColors::usage = \"BackgroundColors is a global constant consisting \
of a string of colors from the Graphics`Colors` package that are used for \
colors in the Cayley table and other similar places. Although the colors are \
given in RGBColor format, the default list for this variable uses the \
following names of colors:\\n {Yellow, Orange, Violet, Blue, Mint, Turquoise, \
EmeraldGreen, GreenDark, Pink, BlueLight, Banana, Green, Brown, Gray, Red, \
Purple, CadmiumYellow, Maroon, Navy, Salmon, Aquamarine, Indigo, Lavender, \
Antique, Bisque, Burlywood, Eggshell, Khaki, BlueViolet, CadmiumOrange, \
CadmiumRedDeep, Cerulean, Chartreuse, Cyan, DeepPink, Magenta, OrangeRed, \
Peacock, SkyBlueDeep, TurquoiseDark, Ultramarine}\";

Both::usage = \"Both is a value for the Operation option used in various ring \
functions.\";

CartesianProduct::usage = \"CartesianProduct[els1, els2] returns the \
Cartesian product, as a list of ordered pairs, of the two sets  els1 and \
els2. CartesianProduct[els1, els2, Partition \[Rule] True] partitions the \
ordered pairs using the Partition function, cut to the length of els2. \
CartesianProduct[ListOfLists] returns the Cartesian product of the lists of \
elements in ListOfLists.\";

CayleyForm::usage = \"CayleyForm is an option for CayleyTable (and functions \
that form Groupoids or Ringoids) to indicate whether the elements in the \
Cayley table should be displayed in InputForm, OutputForm or some other form. \
The default value is OutputForm.\";

CayleyTable::usage = \"CayleyTable[G] returns the Cayley table for the \
structure G colored with a different color for each element in G. If it is \
desired that Elements[G] be reordered, then CayleyTable[G, TheSet \[Rule] \
NewOrder] will return a new Cayley table according to the new ordering of the \
elements as found in the list NewOrder. When used with rings, the Operation \
option can be used, which can have the value Addition, Multiplication or \
Both. Other options specific to CayleyTable (with the default value given in \
parentheses) are HeadingsColored (True), ShowOperator (True), ShowName \
(True), ShowBodyText (True), ShowSidesText (True), ShowKey (True), VarToUse \
('g'), KeyForm (InputForm), and CayleyForm (InputForm). \
CayleyTable[{G1,G2,..Gn},opts] returns CayleyTable[G1,opts], \
CayleyTable[G2,opts] and so on. Multiple CayleyTables can also be obtained by \
using the following variant forms: CayleyTable[{G1,G2,..Gn}, {opts1, opts2, \
.. optsn}] (optsi applies to Gi) and CayleyTable[{{G1, opts1}, {G2, \
opts2},..{Gn, optsn}}] (optsi applies to Gi).\";

CloseSets::usage = \"CloseSets[list1, list2, op] returns a list of all the \
distinct elements obtained by applying the operation op on the Cartesian \
product of list1 and list2]\";

ClosedQ::usage = \"ClosedQ[S] returns True if the set of elements in the \
structure S is closed under its operation, and False otherwise. Additionally, \
ClosedQ[S, H] determines whether H is a closed subset of the structure S. \
When used with rings, the Operation option can be used, which can have the \
value Addition, Multiplication or Both.\";

Closure::usage = \"Closure[G, H] returns the subgroup of G generated by the \
elements in the set H (assuming H is a subset of G or a Groupoid whose \
elements are a subset of G). The option ReportIterations (defaulting to \
False) indicates whether the result of each iteration is also returned. The \
option Staged (defaulting to False), applicable if Mode \[Rule] Visual is \
used, indicates whether or not the graphics are shown one stage at a time or \
they are all display at once. When set to True, NextStage[Closure] returns \
the next iteration and PreviousStage[Closure] returns the previous iteration. \
(Adding an integer k as a second parameter to either NextStage or \
PreviousStage specifies how many steps forward or backwards to take.) The \
option Sort, when set to False (default), returns the elements in the order \
they are generated, while when set to True, returns the elements sorted. When \
using the Visual mode, Output \[Rule] GraphicsArray causes the graphics to be \
placed in array form, rather than being presented serially.\";

ComplementNoSort::usage = \"ComplementNoSort[eall, e1, e2, ...] gives the \
elements in eall which are not in any of the ei. This is similar to \
Complement except the returned values are NOT sorted as they are with \
Complement.\";

Computational::usage = \"Computational is the default setting for the Mode \
option for most functions. When Mode \[Rule] Computational is set, the \
function returns the desired computation with no textual or visual \
information given.\";

DefaultStructure::usage = \"DefaultStructure is a global variable that has \
one of two values, Group or Ring. This value indicates what the default \
assumption is for various functions that have meanings for both groups and \
rings. For these functions, this default value can always be temporarily \
overridden by using the option Structure \[Rule] Group or Structure \[Rule] \
Ring. This variable can be changed manually or by using the function \
SwitchStructureTo.\";

Domain::usage = \"Domain[f] returns the structure used in the domain of the \
Morphoid f. Domain[S] returns the elements in the Groupoid or Ringoid S; this \
is equivalent to the Elements function.\";

DrawNgon::usage = \"DrawNgon[n] draws a regular n-gon (n > 2) with the \
vertices labeled with the integers 1 through n.\";

ElementQ::usage = \"ElementQ[x, S] yields True or False depending on whether \
or not x is an element of the structured set S.\";

Elements::usage = \"Elements[S] returns the list of elements contained in the \
structured set S (either a Groupoid or Ringoid). Elements[{S1,S2,..}] returns \
the elements in each of the structured sets.\";

ElementsQ::usage = \"ElementsQ[els, S] yields True or False depending on \
whether or not all the items in the list els are elements of the structured \
set S.\";

ElementToKey::usage = \"ElementToKey[G, el] returns the key value used for el \
in the Key that is made when the elements in the structure S are too wide for \
a graphical image.\";

ElementToPower::usage = \"ElementToPower[G, g, n] returns the nth power \
(multiple, in an additive groupoid) of the element g in the structure G, \
where n can be any integer).\";

Form::usage = \"Form is an option when working with the dihedral group D[n]. \
By default we have Form \[Rule] RotRef. Also possible is Form \[Rule] \
Permutations. See Dihedral for more information. Form is also an option for \
QuotientGroup and QuotientRing. Form \[Rule] Cosets is the default here and \
specifies that the elements of the quotient group (or quotient ring) should \
appear in coset form. Form \[Rule] Representatives causes the quotient \
elements to be represented by a representative from the cosets. The option \
Representatives can be used to specify these representatives. Form \[Rule] \
CosetLists is yet another option, where the cosets appear as lists of \
elements. Finally, Form is also an option for QuaternionGroup; see this \
function for more information.\";

FormGroupoid::usage = \"FormGroupoid[els, op, opsym, opts] is the basic \
command for forming a Groupoid consisting of the list els governed by the \
operation op. The symbol opsym defaults to * if not specified. The available \
options for opts are WideElements, IsAGroup, Generators, GroupoidDescription, \
GroupoidName, FormatOperator, FormatElements, MaxElementsToList, KeyForm, and \
CayleyForm. See each one for more information. \\n\\nThis function, rather \
than just wrapping Groupoid around a list and an operation, is strongly \
recommended.\";

FormGroupoidByTable::usage = \"FormGroupoidByTable[els, tab, opsym, opts] is \
a command for forming a Groupoid consisting of the list els and governed by \
the operation implicit in the Cayley table tab. The symbol opsym defaults to \
* unless specified. The available options for opts are WideElements, \
IsAGroup, Generators, GroupoidDescription, GroupoidName, FormatOperator, \
FormatElements, MaxElementsToList, KeyForm, and CayleyForm. See each of these \
individually for more information.\";

FormRingoid::usage = \"FormRingoid[list, addition, multiplication, {plussym, \
multsymb}, opts] is the basic command for forming a Ringoid consisting of the \
list of elements found in list governed by the operations addition and \
multiplication. The symbol plussym defaults to + and the multsymb defaults to \
*, if not specified. The options for opts can be WideElements, IsARing, \
RingoidDescription, RingoidName, FormatOperator, FormatElements, \
MaxElementsToList, KeyForm, and CayleyForm. See each one for more \
information. Alternatively, FormRingoid[AG, MG, opts] forms the Ringoid using \
the Groupoid AG for the additive part and the Groupoid MG for the \
multiplicative part (assuming the same elements are used).\\n\\n This \
function, rather than just wrapping Ringoid around a list and the operations, \
is strongly recommended.\";

FormatElements::usage = \"FormatElements is an option for functions which \
form Groupoids or Ringoids, whose default value is False. When set to True, \
whenever a structured set is displayed, {-Elements-} will be displayed \
instead of the actual list of elements.\";

FormatOperator::usage = \"FormatOperator is an option for functions which \
form Groupoids or Ringoids, whose default value is True. When set to True, \
whenever a structured set is displayed, -Operation- (or -Addition- and \
-Multiplication- for Ringoids) will be displayed instead of the actual \
definition of the operator(s).\";

GaussianIntegers::usage = \"GaussianIntegers[n] returns the Ringoid of \
Gaussian integers mod n under ordinary complex addition and multiplication \
mod n. \\nThe standard use of this name as an option for several built-in \
functions still works and is described as follows: GaussianIntegers is an \
option for FactorInteger, PrimeQ, Factor and related functions. With \
GaussianIntegers \[Rule] True, factorization is done over the Gaussian \
integers when possible. With GaussianIntegers \[Rule] False, factorization is \
done over the integers.\";

GaussianIntegersAdditive::usage = \"GaussianIntegersAdditive[n] returns the \
additive Groupoid of Gaussian integers mod n. This is equivalent to Z[n, \
I].\";

GaussianIntegersMultiplicative::usage = \"GaussianIntegersMultiplicative[n] \
returns the multiplicative Groupoid of Gaussian integers mod n. This is \
equivalent to Zx[n, I].\";

GenerateGroupoid::usage = \"GenerateGroupoid[gens, op, opsym, opts] is a \
command for generating a Groupoid by using the generators in the list gens \
governed by the operation op. The symbol opsym defaults to * unless specified \
otherwise. The options for opts can be WideElements, IsAGroup, SizeLimit, \
Generators, GroupoidDescription, GroupoidName, FormatOperator, \
FormatElements, MaxElementsToList, KeyForm, and CayleyForm. See each of these \
individually for more information.\";

GeneratingSet::usage = \"GeneratingSet[G] gives a set of generators for \
determining G. If $Failed is returned, this indicates that a generating set \
is not yet known to Mathematica. The option Generators for FormGroupooid is \
used to specify a generating set, as is the first argument for \
GenerateGroupoid.\";

Generators::usage = \"Generators is an option for functions which form \
Groupoids, whose default value is {}. Specifying Generators \[Rule] \
{g1,g2,...} indicates that these generators are known to generate this \
Groupoid.\";

Graphics::usage = \"Graphics is a value for the Output option that can be \
used when a function uses the Visual Mode. Adding the option Output \[Rule] \
Graphics will cause the graphics of the Visual mode to be the output (given \
as -Graphics-). This is a method of capturing the graphics involved in a \
computation instead of the actual computation. (Using GraphicsArray instead \
of Graphics works similarly when the output is going to be a series of \
graphics. These are then put into an array of graphics.) \\nThe standard \
(built-in) definition still exists: Graphics[primitives, options] represents \
a two-dimensional graphical image.\";

Group::usage = \"Group is a value for the Structure option that is used for \
the functions FormMorphoid, ZMap, and Z (including Z[n] and Z[n, I]). It is \
also the argument for the SwitchStructureTo function when switching from \
rings to groups.\";

GroupIdentity::usage = \"GroupIdentity[G] returns the (two-sided) identity of \
the Groupoid G, if it exists. If there is no identity, a message indicates \
this and $Failed is returned. HasIdentityQ[G] is similar, except it only \
returns True or False regarding the existence of an identity.\";

GroupInfo::usage = \"GroupInfo[G] returns a list of information obtained \
about the Groupoid G that has been gathered thus far by calling various \
functions.\";

GroupInverse::usage = \"GroupInverse[G, g] returns the inverse of g in G, if \
it exists, and $Failed otherwise.\";

GroupQ::usage = \"GroupQ[G] returns True if G is a group, and False \
otherwise.\";

Groupoid::usage = \"Groupoid is the head for an ordered pair where the first \
component is a set of elements and the second is an operation. A Groupoid is \
one of the basic structures of these packages.\";

GroupoidDescription::usage = \"GroupoidDescription[G] yields a description, \
if available, of the Groupoid G. This can be set with the option \
GroupoidDescription when using the functions FormGroupoid or \
GenerateGroupoid. If the empty string is returned (default value), no \
description has been given.\";

GroupoidName::usage = \"GroupoidName[G] yields the name, if given, of the \
group G. This can be set with the option GroupoidName in FormGroupoid and \
GenerateGroupoid. If the empty string or TheGroup (default) is returned, no \
name has yet been given.\";

Groups::usage = \"Groups is an acceptable argument for the SwitchStructureTo \
function.\";

HasIdentityQ::usage = \"HasIdentityQ[S] returns True or False depending on \
whether or not the (two-sided) identity (or identities for rings) of the \
structure S exists. When used with rings, the Operation option can be used, \
which can have the value Addition, Multiplication or Both. If S is a group, \
GroupIdentity[S] returns the identity, if one exists, while for rings, \
Zero[S] and Unity[S] return the additive and multiplicative identities, if \
they exist.\";

HasInversesQ::usage = \"HasInversesQ[G] returns True or False depending on \
whether all the elements in G have inverses or not. When used with rings,  \
the Operation option can be used, which can have the value Addition, \
Multiplication or Both.\";

HasLeftIdentityQ::usage = \"HasLeftIdentityQ[G] returns True or False \
depending on whether the Groupoid G has a left identity or not. If one \
exists, LeftIdentity[G] returns its value.\";

HasRightIdentityQ::usage = \"HasRightIdentityQ[G] returns True or False \
depending on whether the Groupoid G has a right identity or not. If one \
exists, RightIdentity[G] returns its value.\";

HeadingsColored::usage = \"HeadingsColored is an option for CayleyTable. \
Setting it to True or False determines whether the top row and left column \
are colored according to the default coloring of the elements residing in \
these positions.\";

Identity::usage = \"Identity[G] returns the (two-sided) identity of the \
structure G, if it exists. If there is no identity, a message indicates this. \
For groups, this is identical in functionality to GroupIdentity[G]. \
HasIdentityQ[G] is similar, except it only returns True or False regarding \
the existence. When used with rings, the Operation option can be used, which \
can have the value Addition, Multiplication or Both. This use is equivalent \
to RingIdentity. \\nThe standard (built-in) usage still exists: \
Identity[expr] gives expr (the identity operation).\";

Inverse::usage = \"Inverse[G, g] returns the inverse of g in G, if it exists, \
otherwise $Failed. When used with rings,  the Operation option can be used, \
which can have the value Addition, Multiplication or Both. \\nThe standard \
(built-in) usage still exists: Inverse[m] gives the inverse of a square \
matrix m.\";

InvertibleQ::usage = \"InvertibleQ[S, g] returns True if the (two-sided) \
inverse of g in the structure S exists, and False otherwise. When used with \
rings,  the Operation option can be used, which can have the value Addition, \
Multiplication or Both.\";

Inverses::usage = \"Inverses[G] returns a list of ordered pairs of the form \
{g, h}. If g has an inverse in G, then h is that element; otherwise h is 'no \
inverse'. When used with rings,  the Operation option can be used, which can \
have the value Addition, Multiplication or Both.\";

IsAGroup::usage = \"IsAGroup is an option for functions which form Groupoids, \
whose default value is False. When set to True, the Groupoid constructed will \
be assumed to be known as a group.\";

IsARing::usage = \"IsARing is an option for functions which form Ringoids, \
whose default value is False. When set to True, the Ringoid constructed will \
be assumed to be known to be a ring.\";

KeyToElement::usage = \"KeyToElement[S, key] returns the element \
corresponding to the value key found in the Key, when the elements in the \
structure S are too wide for a graphical image.\";

KSubsets::usage = \"KSubsets[L, k] returns all subsets of set L containing \
exactly k elements, ordered lexicographically. (From \
DiscreteMath`Combinatorica`.)\";

KeyForm::usage = \"KeyForm is an option for CayleyTable (and functions that \
form Groupoids or Ringoids) to indicate whether the elements in the Key of \
the Cayley table should be displayed in InputForm, OutputForm or some other \
form. The default value is InputForm.\";

LeftIdentity::usage = \"LeftIdentity[G] returns the left identity of the \
Groupoid G, if one exists, or $Failed otherwise.\";

LeftInverse::usage = \"LeftInverse[G, g] returns the left inverse of g in G, \
if it exists, otherwise $Failed.\";

LeftInvertibleQ::usage = \"LeftInvertibleQ[G, g] returns True if the left \
inverse of g in G exists, and False otherwise.\";

LeftToRight::usage = \"LeftToRight is a value for the ProductOrder option of \
MultiplyPermutations and MultiplyCycles, as well for the PowersIncrease \
option for Poly (when working with polynomials over a ring). When \
ProductOrder is set to this value, then MultiplyPermutations[p1,p2] will be \
computed by taking p1 followed by p2. For the use in Poly, see \
PowersIncrease.\";

MaxElementsToList::usage = \"MaxElementsToList is an option for functions \
which form Groupoids or Ringoids, whose default value is 50. This means that \
if a structured set has more than 50 elements, it will default to showing \
simply {-Elements-} instead of the actual list. Some groups/rings may have \
lower values.\";

Mode::usage = \"Mode is an option for many of the functions in these \
packages. Standard modes are Computational, Textual and Visual, and sometimes \
Visual2. See each of these individually for more information. \\nThe standard \
(built-in) definition still exists: Mode is an option to Solve and related \
functions that specifies in what sense the equations are to be solved. The \
possible settings for Mode are Generic, Modular, and Rational.\";

MonoidQ::usage = \"MonoidQ[G] returns True if G is a monoid (the set is \
closed under a binary operation that is associative with an identity), and \
False otherwise.\";

Multiplication::usage = \"Multiplication[R] is the multiplication in the \
Ringoid R. Given an extension Ext of a ring, Multiplication[Ext] is the \
multiplication in this extension. Multiplication is also a value for the \
Operation option that is used in some ring functions.\";

NextStage::usage = \"NextStage[func] returns the next stage of an animation \
for the function func when Mode is set to Visual. NextStage[func, k] \
indicates that k steps forward should be taken (or backwards, if negative). \
The functions supporting this include Closure, SubgroupClosure, and \
QuotientRing in some cases.\";

NonAssociatingTriples::usage = \"NonAssociatingTriples[G] returns the triples \
of elements {a, b, c} in the Groupoid G that do not associate.\";

NonIdentity::usage = \"NonIdentity is a value for the SelectFrom option for \
RandomElement and RandomElements. This allows any element to be returned \
except the identity element, if it exists. Alternatively, one may use the \
value Any. Note: for rings, this option excludes both the zero and unity (if \
they exist) and other related options are NonUnity and NonZero.\";

Operation::usage = \"Operation[G] returns the operation used in the Groupoid \
G. Operation is also an option for various functions when working with rings; \
possible settings are Addition, Multiplication, and Both.\";

OperatorSymbol::usage = \"OperatorSymbol[G] returns the symbol used for the \
operation in the Groupoid G. FormGroupoid and GenerateGroupoid set this to be \
* by default.\";

Order::usage = \"Order[G] returns the cardinality of the set of elements in \
the group G. This is identical to the function Size. Order[G, g] gives the \
order of the element g in G. This is identical to the function \
OrderOfElement. \\nThe standard (built-in) definition still exists: \
Order[expr1, expr2] gives 1 if expr1 is before expr2 in canonical order, and \
-1 if expr1 is after expr2 in canonical order. It gives 0 if expr1 is \
identical to expr2.\";

Ordering::usage = \"Ordering[list] gives the permutation that puts the \
elements in list in (a canonical) order. If list is a permutation, this is \
equivalent to PermutationInverse. (This is from the \
DiscreteMath`Permutations` package.)\";

Output::usage = \"Output is an option that can be used when a Visual mode is \
used and determines the form of the output. By default, the value of the \
option is Computational, which means that the output is the normal \
computation. Alternatively, using Output \[Rule] Graphics will cause the \
graphics of the Visual mode to be the output (given as -Graphics-). This is a \
method of capturing the graphics involved in a computation instead of the \
actual computation. Additionally, in a few cases were a series of graphics \
are produced, the value GraphicsArray option can be used.\";

Partition::usage = \"Partition is an option for Cartesian Product. By \
default, it is set to False. When set to True, the list is partitioned \
according to the size of the second (last) list. \\nThe standard (built-in) \
definition still exists: Partition[list, n] partitions list into \
non-overlapping sublists of length n. Partition[list, n, d] generates \
sublists with offset d. Partition[list, {n1, n2, ...}, {d1, d2, ...}] \
partitions successive levels in list into length ni sublists with offsets di.\
\";

PermutationInverse::usage = \"PermutationInverse[perm] gives the permutation \
that is the inverse of perm\";

PermutationQ::usage = \"PermutationQ[e] yields True if e is a list \
representing a permutation. (This is a modified version of that found in the \
DiscreteMath`Permutations` package.)\";

PlusSymbol::usage = \"PlusSymbol is an option for FormRingoid to specify the \
symbol used for addition in forming a Ringoid. The default is PlusSymbol \
\[Rule] +.\";

PreviousStage::usage = \"PreviousStage[func] returns the previous stage of an \
animation for the function func when Mode is set to Visual. \
PreviousStage[func, k] indicates that k steps backwards (or forward, if \
negative) should be taken. The functions supporting this include Closure, \
SubgroupClosure, and QuotientRing in some cases.\";

ProbableGroupQ::usage = \"ProbableGroupQ[G] returns True or False depending \
on whether the tests for a group are valid, using RandomAssociativeQ instead \
of AssociativeQ.\";

ProperSubsetQ::usage = \"ProperSubsetQ[A, B] returns True if A is a proper \
subset of B, and False otherwise.\";

RandomAssociativeQ::usage = \"RandomAssociativeQ[S] returns a Boolean value \
of True or False depending on whether the structure S appears to be \
associative after 50 random choices of testing a triple of elements from S. \
RandomAssociativeQ[S, n] will randomly test n times. When used with rings, \
the Operation option can be used, which can have the value Addition, \
Multiplication or Both.\";

RandomElement::usage = \"RandomElement[S] returns a random element from the \
Groupoid or Ringoid (or simply the list) S. Available options are SelectFrom \
\[Rule] NonIdentity (this, the default, guarantees that the identity is not \
selected for Groupoids and neither the zero nor the unit is selected for \
Ringoids), SelectFrom \[Rule] NonUnity (which guarantees the unity is not \
selected with Ringoids), SelectFrom \[Rule] NonZero (which guarantees the \
zero is not selected with Ringoids), and SelectFrom \[Rule] Any (which \
imposes no restrictions). For polynomial extension rings, the options \
LowerDegreeOK and Monic are also available; see these for details (after \
working with rings). Additionally, one can obtain a random element from some \
specialized sets as follows: RandomElement[Z[Sqrt[p]],max] (for p square-free \
and max defaulting to 100) returns a + b Sqrt[p] with both a and b in the \
range [-max, max]. One can use p = -1 also, or use equivalently use Z[I].\";

RandomElements::usage = \"RandomElements[S, n] returns a set of n random \
elements from the Groupoid or Ringoid (or list) S. Available options are \
SelectFrom \[Rule] NonIdentity (this default guarantees that the identity is \
not selected for Groupoids and neither the zero nor the unit is selected for \
Ringoids), SelectFrom \[Rule] NonZero (which guarantees the zero is not \
selected with Ringoids), and SelectFrom \[Rule] Any (which imposes no \
restrictions). Additionally, Replacement \[Rule] True will allow an element \
to be selected more than once (while set to False will not allow this). \
Additionally, one obtain a random element from some specialized sets as \
indicated under RandomElement, by adding the final parameter indicating how \
many to choose.\";

RandomPermutation::usage = \"RandomPermutation[n] returns a random \
permutation of length n. (This is a modified version of that found in the \
DiscreteMath`Permutations` package.)\";

Randomize::usage = \"Randomize[list] will randomly permute the elements in \
list.\";

ReorderGroupoid::usage = \"ReorderGroupoid[G, neworder] takes the Groupoid G \
and forms a new Groupoid with all the properties of G using the order of the \
elements presented in neworder. (Note that mathematically the result of this \
and G are identical since groups do not have an order assumed among the \
elements. This is simply for the convenience of using the functions in these \
packages.)\";

Replacement::usage = \"Replacement is an option for RandomElement and \
RandomElements. The value True means that replacement is to be allowed while \
False if not.\";

ReportIterations::usage = \"ReportIterations is a Boolean option for Closure. \
If set to true, all of the iterations of the closure process will also be \
shown, in addition to the final result.\";

RightIdentity::usage = \"RightIdentity[G] returns the right identity of the \
Groupoid G, if one exists, or $Failed otherwise.\";

RightInverse::usage = \"RightInverse[G, g] returns the right inverse of g in \
G, if it exists, otherwise $Failed.\";

RightInvertibleQ::usage = \"RightInvertibleQ[G, g] returns True if the right \
inverse of g in G exists, and False otherwise.\";

RightToLeft::usage = \"RightToLeft is a value for the ProductOrder option of \
MultiplyPermutations and MultiplyCycles, as well for the PowersIncrease \
option for Poly (when working with polynomials over a ring). When \
ProductOrder is set to this value, then MultiplyPermutations[p2,p1] will be \
computed by taking p1 followed by p2. For the use in Poly, see \
PowersIncrease.\";

Ring::usage = \"Ring is a value for the Structure option that is used for \
several functions, including FormMorphoid, ZMap, and Z (including Z[n] and \
Z[n, I]). It is also an acceptable argument for the SwitchStructureTo \
function.\";

RingoidDescription::usage = \"RingoidDescription[R] returns a description, if \
given, of the ring R. This can be set with the RingoidDescription option (of \
the same name) in FormRingoid. If the empty string is returned, no \
description has been given.\";

RingInfo::usage = \"RingInfo[R] returns a list of information obtained about \
the Ringoid R which has been gathered by calling various functions.\";

Ringoid::usage = \"Ringoid is the head for a triple where the first component \
is a set of elements and the second and third are the addition and \
multiplication operations. A Ringoid is one of the basic structures of these \
packages.\";

RingoidName::usage = \"RingoidName[R] yields the name, if given, of the \
Ringoid R. This can be set with the RingoidName option (of the same name) in \
FormRingoid. If the empty string is returned (or TheRing, the default value), \
no name has been given.\";

Rings::usage = \"Rings is an acceptable name for the SwitchStructureTo \
function.\";

SameSetQ::usage = \"SameSetQ[list1, list2] returns True if the sets list1 and \
list2 are equal as sets, and False otherwise. Note that this tests the \
mathematical equality of two sets and so SameSetQ[{2,3,1},{1,3,2}] returns \
True while SameQ[{2,3,1},{1,3,2}] returns False.\";

SelectFrom::usage = \"SelectFrom is an option for RandomElement and \
RandomElements. For Groups, the values are Any and NonIdentity; the former \
allows any element to be returned while the latter will not return the \
identity element, if one exists. For Ringoids, NonZero and NonUnity are also \
available values.\";

SemiGroupQ::usage = \"SemiGroupQ[G] returns True if G is a semi-group (a set \
that is closed under a binary operation that is associative), and False \
otherwise.\";

ShowBodyText::usage = \"ShowBodyText is an option for CayleyTable with \
settings True or False depending on whether the text in the body of the table \
is to be shown.\";

ShowCircle::usage = \"ShowCircle[n] creates a unit circle with n points \
labeled {0,1,..n-1} starting at (0,1). ShowCircle[n,labels] is similar except \
the set labels is used for the labeling.\";

ShowFigure::usage = \"ShowFigure[n, perm, sym] draws an ngon with permutation \
perm applied to the vertices and having Dihedral or Cyclic symmetry group if \
sym is D or Z respectively. ShowFigure[perm] will apply the permutation perm \
to the vertices of the figure, with the permutation in list or rule form. \
Additionally, assuming a figure has already been drawn, ShowFigure[] will \
redraw it.\";

ShowKey::usage = \"ShowKey is an option for CayleyTable with settings True or \
False depending on whether a key is shown when the elements in the set are \
too wide and a key needs to be used for identification purposes.\";

ShowName::usage = \"ShowName is an option for CayleyTable with settings True \
or False depending on whether the name of the structured set is to be \
shown.\";

ShowOperator::usage = \"ShowOperator is an option for CayleyTable with \
settings True or False depending on whether the symbol for the operation of \
the structured set is to be shown.\";

ShowPermutation::usage = \"ShowPermutation[perm] shows a graphics array of \
the (predetermined) n-gon (if n>2) 'before' and 'after' the permutation perm \
has been applied. The permutation can be in list form or rule form. \
ShowPermutation[n, perm, symtype] combines ShowFigure[n, IdentityPermutation, \
symtype] with ShowPermutation[perm].\";

ShowSidesText::usage = \"ShowSidesText is an option for CayleyTable with \
settings True or False depending on whether the text in the top row and left \
column (representing the elements of the Groupoid) is to be shown.\";

Size::usage = \"Size[S] returns the cardinality of the set of elements in the \
structured set S. This is identical to the function Order.\";

SizeLimit::usage = \"SizeLimit is an option for the GenerateGroupoid \
function. By default it is set to 25. When the size of the generated set \
exceeds this limit, no further generation will take place.\";

SortGroupoid::usage = \"SortGroupoid[G] returns the Groupoid with the \
elements sorted by the Sort function. Typically, this is already the case.\";

Staged::usage = \"This is an option for some functions (including Closure, \
SubgroupClosure, and QuotientRing in some cases) and can be set to True if an \
animation is to be conducted manually using NextStage and PreviousStage, and \
False otherwise.\";

Structure::usage = \"Structure is an option for several functions. Using \
Structure \[Rule] Group (default when working with groups) specifies that we \
are working with a group structure, while Structure \[Rule] Ring (default in \
Rings) specifies that rings are involved. Functions that have this option are \
ZMap, FormMorphoid, and Z (and related functions).\";

SubgroupClosure::usage = \"SubgroupClosure[G, H] returns the subgroup of G \
generated by the elements in the set H (which is a subset of G). The option \
ReportIterations (defaults to False) indicates whether the result of each \
iteration is also returned. The option Staged (default to False), applicable \
if Mode \[Rule] Visual is given, indicates whether or not the graphics are \
shown one stage at a time. If set to true, NextStage[SubgroupClosure] returns \
the next iteration and PreviousStage[SubgroupClosure] returns the previous \
iteration.\";

SubgroupQ::usage = \"SubgroupQ[H, G] returns True if H is a subgroup of the \
group G, and False otherwise. H can be in the form of a list of elements or a \
Groupoid consisting of elements from G. Options include Mode \[Rule] Visual2 \
(as well as the other modes).\";

SubsetQ::usage = \"SubsetQ[A, B] returns True if A is a subset of B, and \
False otherwise.\";

SwitchStructureTo::usage = \"SwitchStructureTo[structure] sets various \
options and definitions so that the given structure is the default. \
Acceptable values are Group (or Groups or Groupoid) and Ring (or Rings or \
Ringoid).\";

TextCayley::usage = \"TextCayley[G] returns a simple, text-only version \
equivalent of CayleyTable[G, Mode \[Rule] Visual].\";

Textual::usage = \"Mode \[Rule] Textual is a common option for many functions \
in these packages. Generally, a written description and/or definition will be \
given to help clarify the function/concept being explored.\";

TheSet::usage = \"TheSet is an option for the CayleyTable function to be used \
to change the order that the elements appear in the construction of the \
table. TheSet \[Rule] list indicates that Elements[S] are to be arranged \
according to the order in list and then the Cayley table is constructed with \
this ordering. To change the ordering on a more permanent basis, see \
ReorderGroupoid.\";

TimesSymbol::usage = \"TimesSymbol is an option to FormRingoid to specify the \
symbol used for multiplication in forming a Ringoid. The default value is \
*.\";

ToPermutation::usage = \"ToPermutation[RuleList] returns the permutation \
determined by a list of rules. For example, {1\[Rule]2, 2\[Rule]1} becomes \
{2,1}. Similarly, {{1\[Rule]2}, {2\[Rule]1}} becomes {2,1}. ToPermutation[c, \
n] rewrites the cycle c of length <= n as a permutation of length n (or in \
S[n]). ToPermutation[c] uses the maximum value appearing in c for n.\";

ToRules::usage = \"ToRules[f, S] converts the function f with domain S to a \
list of rules of the form x \[Rule] f[x]. When it is important to check that \
the range values belong to a set T, use ToRules[f, S, T] (which returns \
$Failed if T does not contain all the images). S can be a list of values, a \
Groupoid, or a Ringoid. ToRules[f], where f is a Morphoid, converts the \
Morphoid based on a Function (or Symbol) to one based on a list of rules. \
ToRules[perm] converts any permutation (as a list) to a list of rules. For \
example, {2,1,3} becomes {1\[Rule]2, 2\[Rule]1, 3\[Rule]3}. \\nThe standard \
(built-in) usage still exists: ToRules[eqns] takes logical combinations of \
equations, in the form generated by Reduce or Roots, and converts them to a \
sequence of lists of rules where the sequence corresponds to Or and the lists \
correspond to And. {ToRules[eqns]} gives a result of the form produced by \
Solve.\";

UnionNoSort::usage = \"UnionNoSort[list] removes duplicates in list but does \
NOT sort list as the Union function does. UnionNoSort[list1, list2,...] \
returns a single list with all duplicates removed, but unsorted. (This also \
works with other structures besides Lists.)\";

VarToUse::usage = \"VarToUse is an option for CayleyTable to specify the \
generic label for elements in the body of the Cayley table when the elements \
are wide and a key is used. (See ShowKey.)\";

Visual2::usage = \"Mode \[Rule] Visual2 is an option for some functions in \
these packages. Generally, some visual component will be drawn that is \
intended to further clarify the meaning of a concept/function.\";

Visual::usage = \"Mode \[Rule] Visual is a common option for many functions \
in these packages. Generally, some visual component will be drawn which is \
intended to further clarify the meaning of a concept/function.\";

VisualTextShown::usage = \"VisualTextShown is a global variable whose value \
indicates the number of times any text accompanying a graphic image should be \
shown. (If multiple graphic images are shown, the text will never be \
displayed.) For single images, the variable can be set to Infinity, to always \
display the text; n, to only show it the first n times (a particular function \
is called); or 0, to never show the text.\";

WideElements::usage = \"WideElements is an option for functions which form \
Groupoids or Ringoids, whose default value is False. When set to True, any \
formation of a Cayley table will set up a key, under the assumption that the \
elements are too wide to fit in the grid of the Cayley table.\";

Z::usage = \"Z[n] returns the cyclic group of integers mod n under addition \
when in the context of groups or the ring of integers mod n when in the \
context of rings. The option Structure can be set to Group or Ring; by \
default, when working with groups, it is set to Group and set to Ring when \
working with rings. (See SwitchStructureTo for further information.) Note \
that ZG[args] is equivalent to Z[args, Structure \[Rule] Group], while \
ZR[args] is equivalent to Z[args, Structure \[Rule] Ring]. Z[n, k] returns \
the group (or ring) of multiples of k mod n, if k is a divisor of n. \
Additionally, Z[n, I] when working with groups (or Z[n, I, Structure \[Rule] \
Group] while working with rings) returns the additive Gaussian integers mod \
n, while Z[n, I] returns the ring of Gaussian integers mod n when working \
with rings.\";

ZG::usage = \"ZG[n] returns the group of integers mod n with the operation \
addition mod n. ZG[n, k] returns the ring of multiples of k mod n if k is a \
divisor of n. This is equivalent to Z[n, Structure \[Rule] Group].\";

ZR::usage = \"ZR[n] returns the ring of integers mod n with operations \
addition mod n and multiplication mod n. ZR[n, k] returns the ring of \
multiples of k mod n if k is a divisor of n. This is equivalent to Z[n, \
Structure \[Rule] Ring].\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True,
 CellTags->{"CoreUsage", "usagepackages"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.5.2 FiniteFields", "Subsubsection",
 CellTags->{"FiniteFieldsUsage", "usagepackages"}],

Cell["\<\
AdditiveToMultiplicative::usage = \"AdditiveToMultiplicative[R, add] returns \
the multiplicative form of the element add, currently given in additive form, \
from the ringoid (typically a Galois field) R.\";

ExtensionDegree::usage = \"ExtensionDegree[GF[n]] gives the degree of the \
extension of GF[n]. In other words, when n is written as n = p^d for some \
prime p, d is the ExtensionDegree of GF[n].\";

FieldIrreducible::usage = \"FieldIrreducible[GF[n]] returns the irreducible \
polynomial used in  establishing the Galois field GF[n].\";

GaloisFieldQ::usage = \"GaloisFieldQ[R] returns True or False depending on \
whether the ring R is a Galois field and was created using the GF \
function.\";

GF::usage = \"GF[n] returns the Galois field of order n (if n = p^d for some \
prime p and positive integer d), while GF[p, d] returns the field of order \
p^d (where p is the prime modulus and d is the degree of a irreducible \
polynomial to create the field). The field takes the form of a quotient ring \
of polynomials over Z[p] mod the ideal generated by the irreducible \
polynomial, and consequently consisting of polynomials of degree less than d. \
GF[n, poly] or GF[p, d, poly] returns the finite field using the specified \
irreducible polynomial. The option Indeterminate can be used to specify the \
symbol to be used for the indeterminate.\";

IrreduciblePolynomial::usage = \"IrreduciblePolynomial[ind, p, d] finds an \
irreducible polynomial in the indeterminate ind of degree d over the integers \
mod p (where p is prime). The code for this comes from the Mathematica \
package Algebra`FiniteFields`.\";

IrreduciblePolyOverZpQ::usage = \"IrreduciblePolyOverZpQ[poly, p] returns \
True or False depending on whether the polynomial poly is irreducible over \
the ring Z[p]. Note that poly can be a standard Mathematica polynomial in \
some indeterminate or it can be constructed from the Poly function in the \
RingExtensions package.\";

MultiplicativeToAdditive::usage = \"MultiplicativeToAdditive[R, mult] returns \
the additive form of the element mult, currently in multiplicative form, from \
the ringoid (typically a Galois field) R.\";

PowerList::usage = \"PowerList[GF[n]] is equivalent to TableOfPowers, added \
for compatibility with the Algebra`FiniteFields` package.\";

PrimitivePolynomials::usage = \"PrimitivePolynomials[GF[n]] returns the set \
of primitive polynomials in GF[n]. (Actually, GF[n] can be replaced by any \
ring R and this will return the set of elements that generate the \
multiplicative Groupoid of non-zero elements in R.)\";

TableOfPowers::usage = \"TableOfPowers[GF[n]] returns a table consisting of \
first the element {0, 0} followed by pairs of the form {poly^j, r} where r is \
an element in GF[n], poly is the 'simplest' primitive polynomial for this \
ring, and j is the power to which poly needs to be raised to be equal to \
r.\"; \
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True,
 CellTags->{"FiniteFieldsUsage", "usagepackages"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.5.3 Groupoids", "Subsubsection",
 CellTags->{"GroupoidsUsage", "usagepackages"}],

Cell["\<\
AsIJK::usage = \"AsIJK is a value for the Form option for the QuaternionGroup \
function. This specifies that the quaternion group is to be represented by \
the elements {\[PlusMinus] 1, \[PlusMinus] I, \[PlusMinus] JJ, \[PlusMinus] \
KK}. (Note that K is a reserved symbol in version 3 and J is used with \
rings), with a set of relations governing these elements.\";

AsMatrices::usage = \"AsMatrices is a value for the Form option for the \
QuaternionGroup function. This specifies that the quaternion group is to be \
represented by 2-by-2 matrices. This is the default value.\";

AsSymbols::usage = \"AsSymbols is a value for the Form option for the \
QuaternionGroup function. This specifies that the quaternion group is to be \
generated by the symbols {a, b} subject to a set of relations governing these \
symbols. In this form, the elements used are given in the form of Mathematica \
strings.\";

Cyclic::usage = \"Cyclic[n] returns the cyclic group of order n with the \
default generator the string 'g'. Cyclic[n, Generator \[Rule] gen] returns \
the same group but written with generator gen (which could be a string or a \
symbol with no value). Cyclic[n, k] returns the Groupoid generated by g^k.\";

CyclicGroup::usage = \"CyclicGroup[n] - see Cyclic.\";

D::usage = \"D[n] returns the dihedral group of index n with order 2n. See \
Dihedral for more information.\\nThe standard (built-in) usage still exists: \
D[f, x] gives the partial derivative of f with respect to x. D[f, {x, n}] \
gives the nth partial derivative with respect to x. D[f, x1, x2, ...] gives a \
mixed derivative.\";

Dihedral::usage = \"Dihedral[n] returns the dihedral group of index n with \
order 2n. By default, the generators are indicated by Rot (for the smallest \
angle of rotation) and Ref (for any reflection). D[n, Form \[Rule] \
Permutations] uses the permutations corresponding to Rot and Ref; the default \
is Form \[Rule] RotRef. D[n, RotSym \[Rule] newsy1, RefSym \[Rule] newsy2] \
uses the symbols newsy1 and newsy2 for Rot and Ref respectively. Alternate \
names for Dihedral are D and DihedralGroup.\";

DihedralGroup::usage = \"DihedralGroup[n] - see Dihedral.\";

ESG::usage = \"ESG[code] returns the group corresponding to the one given by \
'code' as used in the software package Exploring Small Groups.\";

FirstTaker::usage = \"FirstTaker[n] returns the Groupoid with elements \
{1,2,...n} and the operation that returns the first of the two inputs.\";

GaussianUnits::usage = \"GaussianUnits returns the Groupoid consisting of \
{1,-1, I, -I} under ordinary complex multiplication.\";

Generator::usage = \"Generator is an option for the Cyclic function, \
specifying which symbol should be used for the generator of the group.\";

IntegerUnits::usage = \"IntegerUnits returns the Groupoid consisting of {1, \
-1} under ordinary multiplication.\";

JoinDivisors::usage = \"JoinDivisors[n] returns the Groupoid consisting of \
the divisors of n with operation LCM.\";

Klein4::usage = \"Klein4 returns the Klein-4 group (Viergruppe).\";

MaxTaker::usage = \"MaxTaker[n] returns the Groupoid with elements {1,2,...n} \
and the operation that returns the maximum of the two inputs. MaxTaker[m, n] \
is similar but the elements range over [m, n].\";

MeetDivisors::usage = \"MeetDivisors[n] returns the Groupoid consisting of \
the divisors of n with operation GCD.\";

MinTaker::usage = \"MinTaker[n] returns the Groupoid with elements {1,2,...n} \
and the operation that returns the minimum of the two inputs. MinTaker[m, n] \
is similar but the elements range over [m, n].\";

MixedDivisors::usage = \"MixedDivisors[n] returns the Groupoid consisting of \
the divisors of n with operation LCM/GCD.\";

PermutationComposition::usage = \"PermutationComposition[p2, p1] returns the \
product of permutation p1 followed by permutation p2.\";

Permutations::usage = \"Permutations is a value for the Form option when \
working with the dihedral group. See Dihedral for more information.\\nThe \
standard (built-in) definition still works: Permutations[list] generates a \
list of all possible permutations of the elements in list.\";

QuaternionGroup::usage = \"QuaternionGroup[] returns the 8 element quaternion \
group. This group can be represented in various forms; the default is to \
represent it as 2-by-2 matrices. The option Form controls what form to use, \
with the default value being AsMatrices. Other values are AsIJK and \
AsSymbols.\";

RandomGroupoid::usage = \"RandomGroupoid[n, k] returns a random Groupoid of \
order n. If k = 1, the Cayley table is a collection of n^2 random elements \
from a list of n generic elements; if k = 2, each row is a permutation of a \
list of n generic elements; if k = 3, each column is a permutation of a list \
of n generic elements.\";

Ref::usage = \"This is the standard (default) symbol to represent a \
reflection when working with the dihedral group D[n].\";

RefSym::usage = \"When working with dihedral groups, by default we use the \
option RefSym \[Rule] Ref. This can be changed so that any other symbol is \
used to represent the reflection. See Dihedral for more information.\";

RootsOfUnity::usage = \"RootsOfUnity[n] returns the Groupoid consisting of \
the n complex roots of the equation z^n = 1, under multiplication.\";

Rot::usage = \"This is the standard (default) symbol used to represent the \
rotation of the smallest angle when working with the dihedral group D[n].\";

RotRef::usage = \"RotRef is a value for the Form option when working with the \
dihedral group. See Dihedral for more information.\";

RotSym::usage = \"When working with dihedral groups, by default we use the \
option RotSym \[Rule] Rot. This can be changed so that any other symbol is \
used to represent the rotation. See Dihedral for more information.\";

Trivial::usage = \"Trivial returns the trivial Groupoid consisting of just a \
single element.\";

TwistedZ::usage = \"TwistedZ[n] returns the Groupoid with elements {0, 1, ... \
n-2} and operation Mod[#1 + #2 + #1 #2, n]&.\";

U::usage = \"U[n] returns the group of integers mod n which are relatively \
prime to n, under multiplication. These elements are also the units in the \
ring Z[n]. (In other words, these are the elements that have inverses in the \
Groupoid Zx[n].)\";

Zx::usage = \"Zx[n] returns the Groupoid of integers mod n under \
multiplication. Zx[n, k] returns the Groupoid of multiples of k mod n, if k \
is a divisor of n. Finally, Zx[n, I] returns the Groupoid of the Gaussian \
integers under mod n multiplication.\"; \
\>", "Input",
 CellMargins->{{Inherited, -1}, {Inherited, Inherited}},
 InitializationCell->True,
 AspectRatioFixed->True,
 CellTags->{"GroupoidsUsage", "usagepackages"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.5.4 GroupProperties", "Subsubsection",
 CellTags->{"GroupPropertiesUsage", "usagepackages"}],

Cell["\<\
Center::usage = \"Center[G] returns the center of the group G. This is \
identical to GroupCenter. \\nThe standard (built-in) usage still exists: \
Center is used to specify alignment in printforms such as ColumnForm and \
TableForm.\";

Centralizer::usage = \"Centralizer[G, g] returns the centralizer of g in the \
group G. Centralizer[G, H] returns the centralizer of the subgroup H in the \
group G.\";

Commutator::usage = \"Commutator[G, x, y] returns the commutator \
xyx^(-1)y^(-1) in the Groupoid G.\";

Commutators::usage = \"Commutators[G] returns the complete set of commutators \
in the Groupoid G.\";

CommutatorSubgroup::usage = \"CommutatorSubgroup[G] returns the commutator \
subgroup of the Groupoid G generated by the commutators of G.\";

ConjugacyClass::usage = \"ConjugacyClass[G, h] returns the conjugacy class of \
the element h in G.\";

Conjugate::usage = \"Conjugate[G, h, x] returns the element x h x^(-1) in the \
Groupoid G. Additionally, Conjugate[G, H, x] returns the set x H x^(-1) for \
the subgroup H of the group G. \\nThe standard (built-in) usage still exists: \
Conjugate[z] gives the complex conjugate of the complex number z. \\n(Note \
that the Listable attribute has been turned off.)\";

CyclicGenerators::usage = \"CyclicGenerators[G] returns a list of elements \
that are generators for the cyclic group G.\";

CyclicQ::usage = \"CyclicQ[G] returns True if the Groupoid G is cyclic, and \
False otherwise.\";

CyclicSubgroups::usage = \"CyclicSubgroups[G] returns the list of the cyclic \
subgroups of the group G.\";

ElementConjugate::usage = \"ElementConjugate[G, h, x] returns the element x h \
x^(-1) in the Groupoid G.\";

EqualGroupoidQ::usage = \"EqualGroupoidQ[G1, G2] returns True if G1 and G2 \
can be considered equal as Groupoids, and False otherwise.\";

GroupCenter::usage = \"GroupCenter[G] returns the center of the group G. This \
is identical to Center.\";

GroupExponent::usage = \"GroupExponent[G] returns the smallest positive \
integer n such that g^n is the identity for all elements g in the Groupoid G.\
\";

Normalizer::usage = \"Normalizer[G, H] returns the normalizer of the subgroup \
H in G.\";

OrderOfAllElements::usage = \"OrderOfAllElements[G] returns a list of the \
orders of each element in the Groupoid G in the form {element, order}.\";

OrderOfElement::usage = \"OrderOfElement[G, g] returns the order of the \
element g in the Groupoid G.\";

Orders::usage = \"Orders[G] returns a list of the orders of each element in \
the Groupoid G in the form {element, order}. Orders[G, list] works similarly, \
where list is a list of elements from the Groupoid G.\";

SubgroupConjugate::usage = \"SubgroupConjugate[G, H, x] returns the set x H \
x^(-1) for the subgroup H of the Groupoid G.\";

SubgroupIntersection::usage = \"SubgroupIntersection[G, H, K] returns the \
subGroupoid of G which is the intersection of subgroups H and K.\";

SubgroupJoin::usage = \"SubgroupJoin[G, H, K] returns the subGroupoid of G \
generated by the elements in the subgroups H and K.\";

Subgroupoid::usage = \"Subgroupoid[G, H] creates the Groupoid with the \
elements from the list H (assumed to be elements from G) and the operation \
from the Groupoid G. Subgroupoid[G,{H1, H2}] or Subgroupoid[{G, H1}, {G, H2}] \
can be used if there are 2 (or more) subsets H.\";

SubgroupProduct::usage = \"SubgroupProduct[G, H, K] returns the subGroupoid \
(of G) HK = {hk | h in H, k in K} for subgroups H and K.\";

Subgroups::usage = \"Subgroups[G] returns a list of all the subgroups of the \
group G. Warning: This may take a long time for high order (non-cyclic) \
groups!\";

SubgroupUnion::usage = \"SubgroupUnion[G, H, K] returns the subGroupoid of G \
which is the union of subgroups H and K.\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True,
 CellTags->{"GroupPropertiesUsage", "usagepackages"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.5.5 Joint", "Subsubsection",
 CellTags->{"JointUsage", "usagepackages"}],

Cell["\<\
AbelianQ::usage = \"AbelianQ[G] returns True if the Groupoid G is Abelian \
(commutative), and False otherwise. This is equivalent to CommutativeQ[G].\";

Canonical::usage = \"Canonical is a value for the Representatives option for \
the QuotientGroup (and QuotientRing) function. This value causes \
QuotientGroup to use the 'first' element in the coset.\";

CommutativeQ::usage = \"CommutativeQ[S] returns True if the structure S is \
commutative, and False otherwise. When S is a group, this is identical to \
AbelianQ[S]. When used with rings, one has the Operation option, which can \
take on the values Addition, Multiplication or Both.\";

CosetLists::usage = \"CosetLists is a value for the Form option of \
QuotientGroup and QuotientRing. With this option, the output is a list of the \
cosets in list form.\";

CosetToList::usage = \"CosetToList[G, coset] returns the coset (represented \
as a list) in the quotient group/ring corresponding to the coset represented \
in the form g + NS (or g NS).\";

Cosets::usage = \"Cosets is a value for the Form option of QuotientGroup and \
QuotientRing. This causes the elements to be written as cosets of the form \
gNS or g + NS, where NS represents the normal subgroup (or ideal for \
rings).\";

DirectProduct::usage = \"DirectProduct[S1, S2] returns the direct product of \
the structured sets (Groupoids or Ringoids) S1 and S2. (Any number of \
arguments can be used.)\";

DirectSum::usage = \"DirectSum[S1, S2] returns the direct sum of the \
structured sets (Groupoids or Ringoids) S1 and S2. (Any number of arguments \
can be used.)\";

DisguiseGroupoid::usage = \"DisguiseGroupoid[G] returns the Groupoid G with \
the elements of G replaced with the strings 'a', 'b', etc. The purpose is to \
present a generic Groupoid without any indication of the form of the elements \
or operation. DisguiseGroupoid[G, rules] does the same except that rules is a \
list of Rules which specify how the matching should occur. Adding the option \
Randomize \[Rule] True will randomize the original elements before the rules \
are assigned; the default for this option is False.\";

DisguiseRingoid::usage=\"DisguiseRingoid[R] returns the Ringoid R with the \
elements of R replaced with the strings 'a', 'b', etc. The purpose is to \
present a generic ring without any indication of the form of the elements or \
operation. Adding the option Randomize \[Rule] True will randomize the \
original elements in the Ringoid; the default for this option is False. One \
can also add one's own mapping rules, as in DisguiseGroupoid.\";

ElementToCoset::usage = \"ElementToCoset[Q, el], assuming Q is the quotient \
group G/N and el is an element in G, this returns the coset containing el.\";

FactorGroup::usage = \"FactorGroup[G, N, opts] is equivalent to \
QuotientGroup[G, N, opts]; see this function for further details.\";

Index::usage = \"Index[G, H] returns the index of the subgroup H in the group \
G.\";

LeftCoset::usage = \"LeftCoset[G, H, g] returns the left coset gH (or g + H) \
when given the element g from G and the subgroup H of G. G is assumed to be \
either a Groupoid or Ringoid (for which H needs to be a subring).\";

LeftCosets::usage = \"LeftCosets[G, H] returns the set of cosets of the \
subgroup (or subring) H in the Groupoid (or Ringoid) G.\";

NS::usage = \"NS is a symbol for Input and Output to represent whatever \
Normal Subgroup is in use at the time.\";

NonCommutingPairs::usage = \"NonCommutingPairs[G] returns the pairs of \
elements in the Groupoid G that do not commute.\";

NormalQ::usage = \"NormalQ[H, G] returns True if H is a normal subgroup of G, \
and False otherwise.\";

QuotientGroup::usage = \"QuotientGroup[G, N] returns the quotient group \
formed by the group G and the normal subgroup N. Options for this function \
are Form and Representatives. Form can have the value Cosets (default) which \
returns the elements in coset form g + NS or g NS where NS is a symbol \
representing the Normal Subgroup. The value CosetLists returns the quotient \
group as a list of all the cosets in list form. Alternatively, one can use \
Form \[Rule] Representatives and then only the representatives of the cosets \
will be returned. The default list of representatives uses the 'smallest' \
element in the coset and is indicated by Representatives \[Rule] Canonical; \
if you wish to change this list, use Representatives \[Rule] list, where list \
is a list of one element from each coset, or use Representatives \[Rule] \
Random to have these representatives randomly chosen. This can be used also \
if one has Form \[Rule] Cosets. By default, left cosets are used.\";

Representatives::usage = \"Representatives is a value for the Form option of \
QuotientGroup and QuotientRing. This causes the elements to be written as \
representatives of the cosets. Representatives is also an option name for \
QuotientGroup and QuotientRing. It can take values Canonical (default), \
Random, or {g1, g2,...} where the gi's are representatives from the cosets. \
The Canonical option uses the 'first' element in the coset, while the Random \
chooses them randomly.\";

RightCoset::usage = \"RightCoset[G, H, g] returns the right coset Hg (or H + \
g) when given the element g from G and the subgroup H of G.\";

RightCosets::usage = \"RightCosets[G, H] returns a list of the cosets of the \
subgroup (or subring) H in the Groupoid (or Ringoid) G.\";

RightToLeft::usage = \"RightToLeft is a value for the ProductOrder option for \
the MultiplyPermutations and MultiplyCycles functions, as well for the \
PowersIncrease option for Poly (when working with polynomials over a ring). \
When ProductOrder is set to this value, then MultiplyPermutations[p2,p1] will \
be computed by taking p1 followed by p2. For the use in Poly, see \
PowersIncrease.\";

SubgroupGenerated::usage = \"SubgroupGenerated[G, g] returns the subgroup \
generated by the element g in the group G. Options include Mode \[Rule] \
Visual2 (as well as the other modes). When using the Visual mode, Output \
\[Rule] GraphicsArray causes the graphics to be placed in array form, rather \
than being presented serially.\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True,
 CellTags->{"JointUsage", "usagepackages"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.5.6 LabCode", "Subsubsection",
 CellTags->{"LabCodeUsage", "usagepackages"}],

Cell["\<\
myDiv::usage = \"Special symbol used for this lab.\";

trivProd::usage = \"Special symbol used for this lab.\";

myMod::usage = \"Special symbol used for this lab.\";

myDivisorSigma::usage = \"Special symbol used for this lab.\";

myDot::usage = \"Special symbol used for this lab.\";

myPower::usage = \"Special symbol used for this lab.\";

quatOp::usage = \"Special symbol used for this lab.\";

undef::usage = \"Special symbol used for this lab.\";

CInf::usage = \"Special symbol used for this lab.\";

Ind::usage = \"Special symbol used for this lab.\";

myZees::usage = \"Special symbol used for this lab.\";

D1Prod::usage = \"Special symbol used for this lab.\";

D2Prod::usage = \"Special symbol used for this lab.\";

LG::usage = \"LG[n] is the nth groupoid found in a list called 'Lab \
Groupoids.' These are groupoids used in a variety of labs.\";

SE::usage = \"SE[n] is the nth 'Standard Example' group from a list of \
commonly used groups.\";

Lab2::usage = \"Special symbol used for this lab.\";

AddPermToGroup::usage = \"AddPermToGroup[p] will add the permutation p to the \
list of alleged symmetries (which is called MySymmetryGroup). Note that p can \
be in the form of a list ({1,3,4,2}) or a list of rules ({1\[Rule]1, \
2\[Rule]3, 3\[Rule]4, 4\[Rule]2}).\";

DropPermFromGroup::usage = \"DropPermFromGroup[p] deletes the permutation p \
from the list of alleged symmetries (which is called MySymmetryGroup). Note \
that p can be in the form of a list ({1,3,4,2}) or a list of rules \
({1\[Rule]1, 2\[Rule]3, 3\[Rule]4, 4\[Rule]2}).\";

MySymmetryGroup::usage = \"MySymmetryGroup is a global variable which \
contains the accumulated list of alleged permutations representing the \
symmetries of the object given by ShowOne[Lab2]. Note that since it is a \
variable, it does not need [] following it.\";

TestPermutationQ::usage = \"TestPermutationQ[p] tests to see if p is indeed a \
symmetry of the object given by ShowOne[Lab2]. True or False is returned. The \
permutation p can be as a simple list or as a list of rules.\";

GoodGroupElementsQ::usage = \"GoodGroupElementsQ[] will return True or False \
depending on whether or not the list of alleged symmetries found in \
MySymmetryGroup are all elements of the actual symmetry group.\";

CompleteGroupQ::usage = \"CompleteGroupQ[] will return True or False \
depending on whether or not the list of alleged symmetries found in \
MySymmetryGroup is the complete actual symmetry group. Other messages may be \
generated as well, if incomplete or in error.\";

ReduceList::usage = \"ReduceList[polyList] effectively is the equivalent to \
Union[polyList, SameTest \[Rule] Equal] where polyList is a list of \
polynomials formed using the Poly function and Equal is the function designed \
to test when two polynomials built from Poly are equal.\";

ShowPossiblePermutations::usage = \"ShowPossiblePermutations[n] shows the \
complete list of all possible permutations of the integers {1,2,3,...n} where \
n must be 5 or less. If the object in question is an n-gon, then use n as the \
parameter. Note that the permutations are labeled ppp[i] and these labels can \
be used to refer to the given permutation.\";

ShowPossiblePermsAsRules::usage = \"ShowPossiblePermsAsRules[n] shows the \
complete list of all possible permutations of the integers {1,2,3,...n} where \
n must be 5 or less. If the object in question is an n-gon, then use n as the \
parameter. This differs from ShowPossiblePermutations only in the way they \
are presented - here as rules. Note that the permutations are labeled ppp[i] \
and these labels can be used to refer to the given permutation.\";

RestrictList::usage = \"RestrictList[r], given a rule r given as either {i \
\[Rule] j} or as i \[Rule] j, will produce output similar to what is given in \
ShowPossiblePermsAsRules except that only those permutations containing r \
will be shown. This can be useful if you are exploring what possibilities \
exist given vertex i is to go to vertex j. RestrictList[{r1, r2,..}] is \
similar except it will take the intersection of what is obtained by \
RestrictList[r1], RestrictList[r2]...\";

Lab3::usage = \"Special symbol used for this lab.\";

ShowGroupOrders::usage = \"ShowGroupOrders[G] displays a ListPlot containing \
pairs {g,|g|} for all g in the Groupoid G. It also shows a bar chart \
indicating how many elements there are of each order in the Groupoid G\";

CollectOrders::usage = \"CollectOrders[G], when given the output of the \
function OrderOfAllElements, will organize the data in the form {p, A} where \
p is one of the orders of the elements g in the Groupoid G and A is the set \
of all elements from G with the order being p.\";

GroupsToConsider::usage = \"GroupsToConsider is a list of groups to consider \
for this lab.\";

ShowOne::usage = \"ShowOne[Labx] shows the appropriate information needed for \
lab numbered x. Note that ShowOne[Lab2,k] returns the group k while \
ShowOne[Lab3, k] returns case k, if one needs to return to a specific group \
in Lab 2 or case in Lab 3.\";

Verbal::usage = \"Special symbol used for this lab.\";

Lab4::usage = \"Special symbol used for this lab.\";

ListOperationPreservingElements::usage = \"Special symbol used for this \
lab.\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True,
 CellTags->{"LabCodeUsage", "usagepackages"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.5.7 Matrices", "Subsubsection",
 CellTags->{"MatricesUsage", "usagepackages"}],

Cell["\<\
Adjoint::usage = \"Adjoint[A] returns Transpose[MatrixConjugate[A]], the \
transpose of the conjugate of a matrix. (For the usage of adjoint as it \
relates to determinants, see DetAdjoint.)\";

AntiCommutingMatricesQ::usage = \"AntiCommutingMatricesQ[R, A, B] returns \
True or False depending on whether the matrices A and B over the Ringoid R \
anti-commute in the sense that A B = - B A. \
AntiCommutingMatricesQ[MatricesOver[R,{n,n}], A, B] works similarly. For \
matrices with numeric entries (over Integers, Rationals, Reals or Complex), \
AntiCommutingMatricesQ[A, B] works similarly.\";

CommutingMatricesQ::usage = \"CommutingMatricesQ[R, A, B] returns True or \
False depending on whether the matrices A and B commute over the Ringoid R. \
CommutingMatricesQ[MatricesOver[R,{n,n}], A, B] works similarly. For matrices \
with numeric entries (over Integers, Rationals, Reals or Complex), \
CommutingMatricesQ[A, B] works similarly.\";

ComplexMatrixQ::usage = \"ComplexMatrixQ[A] returns True or False depending \
on whether the matrix A has all of its entries being complex numbers (in the \
mathematical sense - entries can be Integer, Rational, Algebraic, Real, or \
Complex).\";

Det::usage=\"Det[R, A] returns the determinant of the square matrix A over \
the Ringoid R. Det[MatricesOver[R,{n,n}],A] is equivalent to Det[R, A]. \
\\nThe standard (built-in) usage still exists: Det[m] gives the determinant \
of the square matrix m.\";

DetAdjoint::usage = \"DetAdjoint[A] returns the adjoint of a matrix A, which \
is defined as (-1)^(i+j) Det[Transpose[Bij]], where Bij is the matrix Aij \
with the ith row and jth column removed.\";

Diag::usage = \"Diag[n, R] (alternately, Diag[R, n]) returns the extension of \
invertible n-by-n diagonal matrices over the Ringoid R.\";

DiagonalMatrices::usage = \"DiagonalMatrices[n, R] (alternately, \
DiagonalMatrices[R, n]) - see Diag.\";

DiagQ::usage = \"DiagQ[R, A] returns True or False depending on whether the \
matrix A over the Ringoid R is in Diag[R, n] (where A is an n-by-n \
matrix).\";

Dot::usage=\"Dot[R, a, b] generalizes the (scalar) dot product over a Ringoid \
R and computes a.b (for vectors a and b over R) using the arithmetic of R. \
\\nThe standard (built-in) usage still exists: a.b.c or Dot[a, b, c] gives \
products of vectors, matrices and tensors.\";

GeneralLinear::usage = \"GeneralLinear[args] - see GL.\";

GeneralLinearGroup::usage = \"GeneralLinearGroup[args] - see GL.\";

GL::usage = \"GL[n, R] (alternately, GL[R, n]) returns the extension of \
invertible n-by-n matrices over the Ringoid R. For a positive integer k, \
GL[n,k] is equivalent to GL[n,Z[k]].\";

GLQ::usage = \"GLQ[R, A] returns True or False depending on whether the \
matrix A over the Ringoid R is in GL[R, n] (where A is an n-by-n matrix).\";

HermitianQ::usage = \"HermitianQ[A] returns True or False depending on \
whether the matrix A is Hermitian (i.e., A = Adjoint[A]).\";

IntegerMatrixQ::usage = \"IntegerMatrixQ[A] returns True or False depending \
on whether the matrix A has all of its entries being integers.\";

LT::usage = \"LT[n, R] (alternately, LT[R, n]) returns the extension of \
n-by-n lower triangular matrices (fully below the diagonal) over the Ringoid \
R.\";

LTD::usage = \"LTD[n, R] (alternately, LTD[R, n]) returns the extension of \
n-by-n lower triangular matrices (including the diagonal) over the Ringoid R.\
\";

MatricesOver::usage=\"MatricesOver[R,{m,n}] generates the ring extension of \
m-by-n matrices over R. MatricesOver[R,n] is equivalent to \
MatricesOver[R,{n,n}].\";

MatrixConjugate::usage = \"MatrixConjugate[A], where A is a matrix, returns \
the matrix with all of the entries being the complex conjugate of those that \
occur in A.\";

MatrixDelete::usage = \"MatrixDelete[A, {i, j}] returns the matrix remaining \
when the ith row and jth column of the matrix A are removed.\";

MatrixOverQ::usage = \"MatrixOverQ[R, A] returns True or False depending on \
whether the elements of the matrix A come from the Ringoid R.\";

MatrixOperation::usage = \"MatrixOperation[MatricesOver[R, {m,n}]] returns \
the operation inherent in the matrix extension. Values are the same as for \
Operation (Both, Addition, or Multiplication).\";

MatrixPower::usage = \"MatrixPower[MatricesOver[R, {n,n}], A, k] returns the \
kth power of the matrix A, as an element of the n-by-n matrices over the \
Ringoid R. MatrixPower[R, A, k] works similarly. \\nThe standard (built-in) \
usage still exists: MatrixPower[mat, n] gives the nth matrix power of mat.\";

MatrixTrace::usage = \"MatrixTrace[R, A] returns the trace of the square \
matrix A. MatrixTrace[MatricesOver[R,{n,n}], A] works similarly. For matrices \
with numeric entries (over Integers, Rationals, Reals or Complex), \
MatrixTrace[A] works similarly.\";

MatrixType::usage = \"MatrixType is the name of an option for working with \
matrix extension rings. It can have the value GL, SL, Diag, UT, LT, UTD, or \
LTD (and defaults to All).\";

Mat::usage = \"Mat[R,n] (alternatively, Mat[n, R]) returns the extension ring \
of n-by-n matrices over the Ringoid R. Mat[R, {m,n}] (or Mat[{m,n},R]) \
returns the extension ring of m-by-n matrices over R.\";

MatA::usage = \"MatA[R,{m,n}] (alternatively, MatA[{m,n}, R]) returns the \
extension of m-by-n matrices over the Ringoid R with the operation being \
addition of matrices.\";

MatM::usage = \"MatM[R,n] (alternatively, MatM[n, R]) returns the extension \
of n-by-n matrices over the Ringoid R with the operation being multiplication \
of matrices.\";

OrthogonalQ::usage = \"OrthogonalQ[R, A] returns True or False depending on \
whether the matrix A over the Ringoid R is an orthogonal matrix (i.e., the \
product of the transpose of A and A itself is the identity matrix). For \
matrices with real entries, OrthogonalQ[A] works similarly.\";

RandomMatrix::usage = \"RandomMatrix[R, n, MatrixType \[Rule] type] returns a \
random n-by-n matrix over the Ringoid R of the specified type; see MatrixType \
for the possible values.\";

RationalMatrixQ::usage = \"RationalMatrixQ[A] returns True or False depending \
on whether the matrix A has all of its entries being rational numbers (in the \
mathematical sense - entries can be Integer or Rational).\";

RealMatrixQ::usage = \"RealMatrixQ[A] returns True or False depending on \
whether the matrix A has all of its entries being real numbers (in the \
mathematical sense - entries can be Integer, Rational, Algebraic, or \
Real).\";

SizeOfMatrices::usage = \"SizeOfMatrices[matrixExtension] returns the \
dimensions of the matrices used in this extension ring.\";

SkewHermitianQ::usage = \"SkewHermitianQ[A] returns True or False depending \
on whether the matrix A is skew-Hermitian in the sense that A = \
-Adjoint[A].\";

SkewSymmetricQ::usage = \"SkewSymmetricQ[R, A] returns True or False \
depending on whether the matrix A is skew-symmetric in the sense that A = \
-Transpose[A]. For matrices with numeric entries (over Integers, Rationals, \
Reals or Complex), SkewSymmetricQ[A] works similarly.\";

SL::usage = \"SL[n, R] (alternately, SL[R, n]) returns the extension of \
invertible n-by-n matrices over the Ringoid R that have determinant Unity[R]. \
For a positive integer k, SL[n,k] is equivalent to SL[n,Z[k]].\";

SLQ::usage = \"SLQ[R, A] returns True or False depending on whether the \
matrix A over the Ringoid R is in SL[R, n] (where A is an n-by-n matrix).\";

SpecialLinear::usage = \"SpecialLinear[args] - see SL.\";

SpecialLinearGroup::usage = \"SpecialLinearGroup[args] - see SL.\";

SymmetricQ::usage = \"SymmetricQ[R, A] returns True or False depending on \
whether the matrix A is symmetric.  For matrices with numeric entries (over \
Integers, Rationals, Reals or Complex), SymmetricQ[A] works similarly.\";

ToGroupoid::usage = \"ToGroupoid[extension], where extension might be GL[R,n] \
or some similar extension (such as MatricesOver[R, {m,n}, opts]), calculates \
the actual elements and forms a Groupoid when the number of elements is not \
larger than the default value of the option SizeLimit. Setting this option \
higher allows more Groupoids to be formed, but one needs to be sure there is \
sufficient memory to do so, since these Groupoids can become rather large. \
Using Size first may be a good idea, to see how many elements there are. To \
just get the list of elements, use the function Elements (which uses the same \
SizeLimit restriction).\";

ToRingoid::usage = \"ToRingoid[Mat[R, n]], if the SizeLimit permits, returns \
the Ringoid consisting of the n-by-n matrices over the Ringoid R. See \
ToGroupoid for more details.\";

UnitaryQ::usage = \"UnitaryQ[A] returns True or False depending on whether \
the matrix A (over the complex numbers) is an unitary matrix in the sense \
that the product of the adjoint of A and A itself is the identity matrix.\";

UT::usage = \"UT[n, R] (alternately, UT[R, n]) returns the extension of \
n-by-n upper triangular matrices (fully above the diagonal) over the Ringoid \
R.\";

UTD::usage = \"UTD[n, R] (alternately, UTD[R, n]) returns the extension of \
n-by-n upper triangular matrices (including the diagonal) over the Ringoid R.\
\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True,
 CellTags->{"MatricesUsage", "usagepackages"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.5.8 Morphisms", "Subsubsection",
 CellTags->{"MorphismsUsage", "usagepackages"}],

Cell["\<\
Aut::usage =\"Aut[G] is a shortcut for AutomorphismGroup[G].\";

ToFunction::usage = \"ToFunction[rules] returns a function of the form ffx \
(where x is an integer), which is the result of converting the list of rules \
to a function. ToFunction[rules, f] specifies that the returned function is \
represented by the symbol f. ToFunction[f] converts the Morphoid based on the \
Rules definition to one based on a Function (or Symbol) definition, using a \
function of the form ffx (where x is an integer). ToFunction[f, g] specifies \
that the returned function is represented by the symbol g.\";

Automorphism::usage=\"Automorphism[G, a \[Rule] b] forms the automorphism \
determined by the single rule a \[Rule] b, if a and b are both generators of \
the cyclic group G.\";

AutomorphismGroup::usage=\"AutomorphismGroup[G] returns the group of \
automorphisms of a cyclic group G.\";

Cautious::usage=\"Cautious is an option for IsomorphismQ, indicating whether \
MorphismQ (using value True) or ProbableMorphismQ (using value False) should \
be used. The default value is False.\";

Codomain::usage = \"Codomain[f] returns the structure used in the image of \
the Morphoid f.\";

ColorCodomain::usage = \"ColorCodomain is an option for the VisualizeMorphoid \
function. By specifying ColorCodomain \[Rule] {{color1, cod1}, {color2, \
cod2},...}, the arrows to the codomain element codi will be colored colori. \
Note that these requests supersede those requests from the ColorDomain \
option, if an arrow is requested to be colored by both ColorDomain and \
ColorCodomain.\";

ColorDomain::usage = \"ColorDomain is an option for the VisualizeMorphoid \
function. By specifying ColorDomain \[Rule] {{color1, dom1}, {color2, \
dom2},...}, the arrow from domain element domi will be colored colori, unless \
superseded by a color request by the ColorCodomain option.\";

EqualMorphoidQ::usage=\"EqualMorphoidQ[f, g] compares two Morphoids f and g \
and returns True if their functions are identical and are between identical \
types of structures, and False otherwise. The operations of the structures \
are not compared.\";

Fiber::usage=\"Fiber[f, S] is equivalent to InverseImage[f, S].\";

FormatFunction::usage = \"FormatFunction is an option for the FormMorphoid \
function that indicates whether a Morphoid\[CloseCurlyQuote]s function should \
be displayed in an abbreviated (or formatted) form. While the default value \
is False, it can also be set to True.\";

FormMorphoid::usage = \"FormMorphoid[f, S1, S2, (opts)] is the standard means \
for creating a Morphoid. Here, S1 and S2 are Groupoids or Ringoids, and f is \
either a list of Rules, a Function, or a Symbol. In the special case where S1 \
is a cyclic Groupoid, f can consist of just one rule that sets up the \
morphism. Additionally, if S1 consists of n elements and S2 consists of m \
elements, then FormMorphoid[{p1, p2, ... pn}, S1, S2] forms the Morphoid by \
sending the first element in S1 to the element in S2 in position p1, the \
second element in S1 to the element in position p2 in S2, until finally the \
nth element goes to the element in position pn in S2. FormMorphoidSetup may \
be useful in using this method. The options opts can consist of setting the \
Mode or the value of FormatFunction (default is False), which determines if \
the function should be formatted or not.\";

FormMorphoidSetup::usage= \"FormMorphoidSetup[S1, S2] produces a graphic that \
assists in the preparation of a list of positions to use in FormMorphoid. The \
arguments S2 and S2 must be Groupoids or Ringoids.\";

FunctionForm::usage=\"FunctionForm is an option for InnerAutomorphism that \
controls whether the Morphoid is defined by Rules (default value) or by a \
function is to be created.\";

HomomorphismQ::usage = \"HomomorphismQ[f] returns True if the Morphoid f is a \
homomorphism, and False otherwise. This is equivalent to MorphismQ.\";

Image::usage = \"Image[f] returns a Groupoid or Ringoid (as appropriate) \
consisting of the image values of the Morphoid f. Additionally, Image[f, S] \
returns the images of the substructure S of the domain of f.\";

InducedCanonical::usage = \"InducedCanonical[f], given a Morphoid f: G \
\[Rule] H, returns the Morphoid g : G \[Rule] G/Ker[f].\";

InducedIsomorphism::usage = \"InducedIsomorphism[f], given a Morphoid f: G \
\[Rule] H, returns the Morphoid g : G/Kernel[f] \[Rule] Image[H].\";

InjectiveQ::usage=\"InjectiveQ[f] returns True if the Morphoid f is injective \
(one-to-one), and False otherwise.\";

Inn::usage = \"Inn[G] is identical to InnerAutomorphismGroup[G].\";

InnerAutomorphism::usage = \"InnerAutomorphism[G, g], when given an element g \
in the group G, returns the inner automorphism of G induced by g.\";

InnerAutomorphismGroup::usage=\"InnerAutomorphismGroup[G] returns the group \
of inner automorphisms of G, if G is a group.\";

InverseImage::usage=\"InverseImage[f, S] returns the elements of the domain \
of the Morphoid f that map into elements of the list or element S (from the \
codomain). There is a Visual mode for this function.\";

InverseImages::usage = \"InverseImages[f] returns the set of inverse images. \
This is partially equivalent to InverseImage[f, Elements[Codomain[f]]] except \
the latter returns a single (unsorted) list of the inverse images while this \
function partitions them according to the elements in Codomain[f]. The option \
WithImages (defaulting to False) indicates whether the image elements should \
be included in the output. There is a Visual mode for this function.\";

IsomorphismQ::usage = \"IsomorphismQ[f] returns True if the Morphoid f is an \
isomorphism (group or ring, as appropriate), and False otherwise. The option \
Cautious (defaulting to False) indicates whether MorphismQ (if True) or \
ProbableMorphismQ (if False) should be used for the testing.\";

Kernel::usage = \"Kernel[f] returns the kernel of the Morphoid f, if the \
codomain has an identity element. It is not necessary that f satisfies \
MorphismQ. The object returned is a Groupoid or Ringoid (as appropriate). \
There is a Visual mode for this function.\";

MorphismQ::usage = \"MorphismQ[f] returns True if the Morphoid f is a \
homomorphism, and False otherwise. This function automatically checks to see \
if f represents a group homomorphism or a ring homomorphism according to \
whether the structures involved are groups or rings. The Visual mode can be \
used with this function. MorphismQ[f, {S1, op1}, {S2, op2}] or MorphismQ[f, \
{S1, op1, op3}, {S2, op2, op4}] are alternative usages, where f is either a \
list of Rules, a Function or a Symbol.\";

Morphoid::usage = \"Morphoid is the data structure for possible morphisms. \
This is the head of the object returned by FormMorphoid when one creates a \
morphism. This is one of the basic structures in these packages.\";

MorphoidComposition::usage=\"MorphoidComposition[g, f] forms the composition \
of f and g if the codomain of f and the domain of g are the same structured \
system. Note: This function creates a Morphoid with function g[f[#]]& and \
then converts it to rules.\";

MorphoidFunction::usage = \"MorphoidFunction[f] returns the function defining \
the Morphoid f.\";

MorphoidRules::usage = \"MorphoidRules[f] returns the list of rules defining \
the Morphoid f.\";

OneToOneQ::usage=\"OneToOneQ[f] is equivalent to InjectiveQ[f].\";

OntoQ::usage = \"OntoQ[f] is equivalent to SurjectiveQ[f].\";

ZMap::usage = \"ZMap[m, n] creates Morphoid[Mod[#, n]&, Z[m], Z[n]]. ZMap[m, \
n, g \[Rule] h] creates Morphoid[g \[Rule] h, Z[m], Z[n]], where g must be a \
generator in Z[m]. In either case, one can add the option Structure \[Rule] \
Ring to indicate that Z[m] and Z[n] should be considered rings.\";

PreservesQ::usage = \"PreservesQ[f, {a, b}] returns True if the Morphoid f \
preserves the binary operation(s) for the pair (a,b), and False otherwise. \
Alternatively, if f is either a list of Rules, a Function or a Symbol, Si is \
a set of Elements, and opi is a binary operation, then the following are also \
acceptable usages: PreservesQ[f, {S1, op1}, {S2, op2}, {a, b}], PreservesQ[f, \
{S1, op1, op3}, {S2, op2, op4}, {a, b}]. This also supports the Visual \
Mode.\";

PrintMessage::usage=\"PrintMessage is an option for the ProbableMorphismQ \
function. When set to True (the default value), it will warn the user that a \
positive result is not absolutely certain, but only probabilistic.\";

ProbableMorphismQ::usage=\"ProbableMorphismQ[f] returns True if checking \
random pairs of elements in the domain of Morphoid f indicates that f \
preserves the operation(s), and False otherwise. This is a fast, effective, \
although not foolproof, way of testing whether a Morphoid is a morphism. The \
option SampleSize controls the number of pairs tested. SamplePairs, by \
default set to Random, controls the specific pairs (by giving positions or \
indices in the domain) to be tested, if not chosen randomly.\";

Rules::usage=\"Rules is a value for the FunctionForm option.\";

SamplePairs::usage=\"SamplePairs is an option for ProbableMorphismQ, whose \
default value is Random, meaning the pairs are chosen randomly. \
Alternatively, the value Default uses a short, built-in list of pairs, one \
can give a list of pairs of indices (not elements) to test, for example: \
{{2,3},{3,5}}.\";

SampleSize::usage=\"SampleSize is an option for ProbableMorphismQ that \
specifies the number of tests to perform.\";

Sgn::usage = \"Sgn[G] gives the Morphoid whose domain is the group of \
permutations G and codomain is the group IntegerUnits and the function is the \
Parity function.\";

SurjectiveQ::usage=\"Surjective[f] returns True if the Morphoid f is \
surjective (onto), and False otherwise.\";

VisualizeMorphoid::usage = \"VisualizeMorphoid[f, opts] provides a \
visualization of the Morphoid f by using arrows from the domain to the \
codomain to indicate the map. Available options are ColorDomain and \
ColorCodomain, both of whose default value is {}. See these names for more \
details.\";

WithImages::usage = \"WithImages is an option for the InverseImages function. \
If set to False (default), only the list of inverse images are listed, while \
if set to True, each inverse image is listed with its image element.\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True,
 CellTags->{"MorphismsUsage", "usagepackages"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.5.9 Permutations", "Subsubsection",
 CellTags->{"PermutationsUsage", "usagepackages"}],

Cell["\<\
A::usage = \"A[n] returns the group of even permutations on the set {1,2,..n} \
under composition. See Alternating for more details.\";

Alternating::usage = \"Alternating[n] returns the group of even permutations \
on the set {1,2,..n} under composition. There are two options for this \
function, ProductOrder and IndexLimit. Since the elements of this group are \
permutations, one can specify the order that the product is taken. See \
ProductOrder for more information, including the values that can be used. \
IndexLimit defaults to 6 and indicates the upper limit for the value of the \
index n.\";

AlternatingGroup::usage = \"AlternatingGroup[n] - see Alternating.\";

Cycle::usage = \"Cycle[e1, e2, ...] represents an object that is a cycle of a \
permutation. Cycle is also a value for the CycleAs option of the ToCycles and \
FromCycles functions.\";

CycleAs::usage = \"CycleAs is an option for ToCycles and FromCycles that \
indicates whether a cycle is given as a list or with the head Cycle. In these \
packages, the default value is Cycle; to conform with the \
DiscreteMath`Permutations` package's use, use the value List.\";

(*CycleQ::usage = \"CycleQ[c] returns True if c is a cycle, and False \
otherwise. To be a cycle, c must have Head Cycle and have one or more \
arguments that are distinct positive integers.\";*)

DefaultOrder::usage = \"DefaultOrder is a global variable that contains the \
order that permutations are to be multiplied. It starts out with the value \
RightToLeft, until changed by an option or directly.\";

DisjointCyclesQ::usage = \"DisjointCyclesQ[cyclist] returns True if the \
cycles in cyclist are disjoint, and False otherwise. The cycles in cyclist \
can be either in List form or using Cycle notation. Also, cyclist can be of \
any length and either given as a list or a sequence of cycles.\";

EvenPermutationQ::usage = \"EvenPermutationQ[p] returns True if p is an even \
permutation, and False otherwise.\";

ExtendPermutation::usage = \"ExtendPermutation[p, n] takes a permutation p in \
S[m] (for m < n) and returns a permutation in S[n] using the components of p \
in the first m positions and filling out positions m+1 to n with the integers \
m+1 to n, so that p is naturally extended.\";

FixQ::usage = \"FixQ[S, p, el] returns True if the permutation p (where p \
permutes the elements of S) fixes the element el, and False otherwise. If p \
is a permutation in S[n], then FixQ[p, el] is equivalent to FixQ[Range[n], p, \
el].\";

FormGroupoidFromCycles::usage = \"FormGroupoidFromCycles[cl, opts] forms the \
Groupoid of permutations whose elements are (initially) written as either \
cycles or products of cycles. The option opts takes on values similar to \
FormGroupoid, as well as the option ProductOrder (since we are working with \
permutations).\";

FromCycles::usage =\"FromCycles[{c1, c2,...,cn}] gives the permutation that \
corresponds to the product of the cycles c1, c2, ...cn, assuming that the \
cycles ci are disjoint. This is a modification and improvement on the \
function from the DiscreteMath`Permutations` package.\";

IndexLimit::usage = \"IndexLimit is an option for some groups to enable one \
to obtain larger groups (whose index is more than the default limit on the \
index). Examples where this is used is with the Symmetric and Alternating \
groups with the default value of 6.\";

(*ListToCycle::usage = \"ListToCycle[{a1, a2, ...}] converts {a1, a2, ...} \
into Cycle[a1, a2, ...].\";*)

MultiplyCycles::usage = \"MultiplyCycles[c2, c1, n] views both cycles c1 and \
c2 as in S[n] and determines the permutation representing their product. Note \
that the order of the multiplication is from right to left (unless specified \
otherwise by ProductOrder). MultiplyCycles[c2, c1] does the same but \
determines the value for n by the equation n = Max[Join[c1, c2]]. \
MultiplyCycles[c3, c2, c1] starts from the right and multiplies the cycles as \
it moves left through c2 and c3. MultiplyCycles[cyclelist] or \
MultiplyCycles[{cyclelist}] will work on any length of list of cycles and \
finds the product, working from right to left if the option ProductOrder is \
set to RightToLeft, or from left to right if set to LeftToRight. See \
ProductOrder for details on its values.\";

MultiplyPermutations::usage = \"MultiplyPermutations[perm2, perm1], by \
default, computes the product of perm1 followed by perm2 (right to left). The \
option ProductOrder is by default set to RightToLeft, but can also be set to \
LeftToRight. Note that the permutations can be expressed as rules (eg., {1\
\[Rule]3, 2\[Rule]2,3\[Rule]1}), or lists (eg., {3,2,1}) or mixed, though the \
output will always be a list.\";

Normalize::usage = \"Normalize is an option for ToCycles and FromCycles that \
indicates whether a list of cycles in Cycle notation (this assumes that we \
have CycleAs \[Rule] Cycle as an option) is normalized. If the list consists \
only of cycles of length 1, it drops all of them except the one with maximal \
value; otherwise, all cycles of length one are dropped (unless needed to show \
the length of the permutation), the remaining cycles are normalized by \
rotating until the smallest entry occurs first, and then the list of cycles \
is sorted from shortest to longest.\";

(*NormalizeCycle::usage = \"NormalizeCycle[c] returns the Cycle c in the \
canonical form where the elements are rotated until the smallest entry occurs \
first.\";

NormalizeCycleList::usage = \"NormalizeCycleList[cl], given a list of cycles, \
returns a list of cycles in a canonical form. If cl consists only of cycles \
of length 1, it drops all of them except the one with maximal value; \
otherwise, all cycles of length one are dropped, the remaining cycles are \
normalized by NormalizeCycle, and then the list is sorted from shortest to \
longest.\";*)

OddPermutationQ::usage = \"OddPermutationQ[p] returns True if p is an odd \
permutation, and False otherwise.\";

Orbit::usage = \"Orbit[G, S, x] is the orbit of x (from S) under G. Here, G \
is a group of permutations of the set S. Orbit[S, x] assumes G is the full \
set of all permutations of S.\";

Parity::usage = \"Parity[perm] returns 1 if the permutation perm is an even \
permutation and -1 if odd.\";

PermutationGroup::usage = \"PermutationGroup[list] returns the permutation \
group on the elements in list. It is assumed that the length of list is less \
than 7. PermutationGroup[n] acts just as Symmetric[n].\";

PermutationImage::usage = \"PermutationImage[S, p, el] returns the image of \
the element el under the action of the permutation p, where p permutes the \
elements of S. If p is a permutation in S[n], then PermutationImage[p, el] is \
equivalent to PermutationImage[Range[n], p, el].\";

PermutationMatrix::usage = \"PermutationMatrix[p] shows a permutation in \
matrix form, where the top row consists of 1, 2, ... Length[p] and the bottom \
row consists of the corresponding images.\";

Permutations::usage = \"Permutations is a value for the Form option when \
working with the dihedral group. See Dihedral for more information. \\nThe \
standard (built-in) definition still works: Permutations[list] generates a \
list of all possible permutations of the elements in list.\";

PermutationToPower::usage = \"PermutationToPower[perm, n] returns the nth \
power of the permutation perm, where n is any integer. (If n < 0, this \
returns the nth power of the inverse of perm.)\";

PermuteColoredSquares::usage = \"PermuteColoredSquares[p] will show a row of \
randomly colored squares (as in RandomColoredSquares) and below this a row of \
squares obtained by permuting the first list using the permutation given by \
p. This function only works after RandomColoredSquares has been called. See \
ShowColoredPermutation also.\";

ProductOrder::usage = \"ProductOrder is an option for the function \
MultiplyPermutations and other functions that call this. The value of this, \
which defaults to RightToLeft, specifies the order in which the permutations \
are multiplied. Alternatively, one can specify LeftToRight.\";

RandomColoredSquares::usage = \"RandomColoredSquares[n] returns a row of n \
colored squares chosen randomly from a default list. Optionally, \
RandomColoredSquares[n,colors] will choose the n from the list provided in \
colors.\";

S::usage = \"S[n] returns the group of permutations on the set {1,2,..n} \
under composition. See Symmetric.\";

SamePermutationQ::usage = \"SamePermutationQ[cyclist1, cyclist2] returns True \
if the cycle representation for the permutation found in cyclist1 yields the \
same permutation represented by cyclist2, and False otherwise.\";

ShowColoredPermutation::usage = \"ShowColoredPermutation[p] is similar to \
PermuteColoredSquares except that it does not require RandomColoredSquares to \
be called first.\";

SideBySideMatrices::usage = \"SideBySideMatrices[p,q] displays permutation p \
as a matrix on the left and permutation q as a matrix on the right, with some \
space in between. This simply illustrates how we begin to multiply \
matrices.\";

Stabilizer::usage = \"Stabilizer[G, S, x] returns the stabilizer of the \
element x (from S) in the group G. Here, G is a group of permutations of the \
set S. Stabilizer[S, x] assumes G is the full set of all permutations of \
S.\";

Symmetric::usage = \"Symmetric[n] returns the group of permutations on the \
set {1,2,..n} under composition. There are two options for this function, \
ProductOrder and IndexLimit. Since the elements of this group are \
permutations, one can specify the order that the product is taken by using \
ProductOrder; see ProductOrder for more information, including the values \
which can be used. IndexLimit defaults to 6 and indicates the upper limit for \
the value of the index n.\";

SymmetricGroup::usage = \"SymmetricGroup[n] behaves just as the function \
Symmetric, but also has the functionality of PermutationGroup.\";

ToCycles::usage =\"ToCycles[p] writes the permutation p as a list of disjoint \
cyclic permutations (i.e., cycles) whose product is p. If p is a list of \
permutations, this will return a list of cycles for each permutation. There \
are two options for ToCycles, CycleAs and Normalize. Using CycleAs \[Rule] \
List, the cycles are returned in the form returned by the ToCycles function \
in the DiscreteMath`Permutations` package (so that the permutation {2,1,4,3} \
is returned as {{2,1},{4,3}}), while CycleAs \[Rule] Cycle (default) uses \
Cycle[2,1] for {2,1} in the cycle list. If CycleAs \[Rule] Cycle is used, \
Normalize \[Rule] True (default) applies NormalizeCycleList to the list of \
cycles. See Normalize for details on how this works.\";

ToTranspositions::usage = \"ToTranspositions[c] rewrites the cycle c as a \
product of transpositions. ToTranspositions[perm] rewrites the permutation \
perm as a product of transpositions.\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True,
 CellTags->{"PermutationsUsage", "usagepackages"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.5.10 RingExtensions", "Subsubsection",
 CellTags->{"RingExtensionsUsage", "usagepackages"}],

Cell["\<\
BaseRing::usage=\"BaseRing[R] returns the base ring of an extension or \
quotient ring. If p is a polynomial, BaseRing[p] returns the underlying base \
ring for the polynomial p.\";

Coefficient::usage = \"Coefficient[poly, ind, n], given a polynomial over \
some ring in the indeterminate ind, returns the coefficient of ind^n. \
Coefficient[poly, n] works similarly, without the indeterminate needing to be \
specified. \\nThe standard (built-in) usage still exists: Coefficient[expr, \
form] gives the coefficient of form in the polynomial expr. Coefficient[expr, \
form, n] gives the coefficient of form^n in expr.\";

CoefficientList::usage = \"CoefficientList[poly] returns the list of \
coefficients used in the polynomial poly over some ring R. Note that these \
are returned in the order as if PowersIncrease \[Rule] RightToLeft was given. \
In other words, CoefficientList[x^2 + 2x + 3] returns {3,2,1}. \\nThe \
standard (built-in) usage still exists: CoefficientList[poly, var] gives a \
list of coefficients of powers of var in poly, starting with power 0. \
CoefficientList[poly, {var1, var2, ...}] gives a matrix of coefficients of \
the vari.\";

Degree::usage = \"Degree[PolynomialsOver[R], p] determines the degree of the \
polynomial p when viewed as an element in the ring of polynomials over the \
Ringoid R. Degree[p] assumes p is defined in some ring of polynomials. \\nThe \
standard (built-in) usage still exists: Degree gives the number of radians in \
one degree. It has a numerical value of Pi/180.\";

EvaluationInExtension::usage = \"EvaluationInExtension[E, p, q] evaluates the \
polynomial p (a polynomial over the base ring of the extension E) at q, an \
element of that extension. Note: Both p and q should both be polynomials over \
the base ring with identical indeterminates.\";

Equal::usage = \"Equal[PolynomialsOver[R], p, q] returns True or False \
depending on whether the polynomials p and q are equal as elements in the \
ring of polynomials over the Ringoid R. Equal[p, q] assumes that both p and q \
are well-defined in some ring of polynomials. The option IgnoreIndeterminate \
can be set to True (default) or False and determines whether the \
indeterminate used should be considered when deciding equality. \\nThe \
standard (built-in) usage still exists: lhs == rhs returns True if lhs and \
rhs are identical.\";

Exponent::usage = \"Exponent[PolynomialsOver[R], p] determines the degree of \
the polynomial p when viewed as an element in the ring of polynomials over \
the Ringoid R. Exponent[p] assumes p is defined in some ring of polynomials. \
\\nThe standard (built-in) usage still exists: Exponent[expr, form] gives the \
maximum power with which form appears in expr. Exponent[expr, form, h] \
applies h to the set of exponents with which form appears in expr.\";

(*ExtensionEvaluation::usage = \"ExtensionEvaluation[E, q], given E as the \
quotient ring of F over the irreducible polynomial p, evaluates the induced \
coset polynomial equivalent to p at the element q in E. The function \
InducedCosetPolynomialFunction is related.\";*)

ExtensionType::usage = \"ExtensionType[ext] returns the type of extension for \
this extension ring ext.\";

FlexibleEntering::usage = \"FlexibleEntering is an option, taking either True \
or False, for the Poly function, which creates polynomials. When set to True \
(the default value), the function call Poly[R, x^2 - 2x + 1] is treated as \
Poly[R, x^2 + NegationOf[R, 2]x + 1]. Additionally, if R = Z[n], then the \
coefficients can be any integers and are reduced mod n before processing.\";

Func::usage=\"Func is the head for a function in a FunctionsOver \
extension.\";

FuncRing::usage=\"FuncRing is the first parameter for any function extension.\
\";

FunctionsOver::usage=\"FunctionsOver[R] returns the extension of functions on \
the Ringoid R.\";

FuncToRules::usage=\"FuncToRules[f, FunctionsOver[R]] converts f to a list of \
rules.\";

IgnoreIndeterminate::usage = \"IgnoreIndeterminate is an option for the Equal \
command that is used when determining when two polynomials are equal. The \
default value for this option is True, which means that 4x^2 + 3x + 1 and \
4y^2 + 3y + 1 are considered equal as polynomials. One can optionally set \
this to False.\";

Indeterminate::usage = \"Indeterminate is an option for the Poly function \
(that creates polynomials). The default value is 'x', though one can specify \
any other symbol as the indeterminate to be used in a polynomial. \\nThe \
standard (built-in) usage still exists: Indeterminate is a symbol that \
represents a numerical quantity whose magnitude cannot be determined.\";

(*InducedCosetPolynomialFunction::usage = \
\"InducedCosetPolynomialFunction[E], given E as the quotient ring of F over \
the irreducible polynomial p, returns (as a function) the coset polynomial \
equivalent to p. In other words, the function that is returned represents the \
polynomial function induced from p by replacing the coefficients (from F) of \
p with the corresponding (coset) polynomials from E and replacing the \
addition and multiplication of F from within p to the multiplication and \
addition within E.\";*)

Matrices::usage = \"Matrices is a possible type of RingExtension.\";

ModulusPolynomial::usage=\"ModulusPolynomial[Q] is the polynomial from which \
a quotient ring Q has been created.\";

Monomial::usage=\"Monomial[R, c, n] returns the monomial c x^n in the ring \
extension PolynomialsOver[R]; Monomial[PolynomialsOver[R], c, n] returns the \
same.\";

Poly::usage = \"Poly[R, expr, opts] creates the polynomial over the Ringoid R \
given by expr and using the options given by opts. A polynomial such as 2 + \
3x + x^3 (over some ring R) can be constructed by Poly[R, 2 + 3x + x^3], \
which, by default, would return 2 + 3x + x^3. The form x^3 + 3x + 2 could be \
returned by entering Poly[R, 2 + 3x + x^3, PowersIncrease \[Rule] \
RightToLeft], or by changing this option globally. One can also specify a \
polynomial by just using the coefficients. Thus, Poly[R, 1, 0, 3, 2] returns \
1 + 3x^2 + 2x^3, while Poly[R, 1, 0, 3, 2, PowersIncrease \[Rule] \
RightToLeft] returns x^3 + 3x + 2. When entering just the coefficients, the \
default indeterminate is 'x', but this can be changed by using the option \
Indeterminate \[Rule] var, where var is any (undefined) symbol. \
FlexibleEntering, an option taking either True or False (defaulting to True), \
can be used if one wishes to enter polynomials allowing subtraction of terms \
or allowing entering the negation of an element by using -r. It also allows \
all coefficients of the polynomial to be reduced mod n if the base ring is \
Z[n]. If RP is a ring of polynomials, Poly[RP, expr, opts] works in a similar \
fashion.\";

PolynomialDivision::usage=\"PolynomialDivision[PolynomialsOver[R], a, b], for \
polynomials a and b in the ring of polynomials over R, returns the pair of \
polynomials {q, r} where a = b q + r with r = 0 or deg r < deg b, provided \
that the leading coefficient of b is a unit in R. PolynomialDivision[a, b] \
works similarly as long as polynomials a and b are both from the same ring of \
polynomials. \\nThe standard (built-in) usage still exists: \
PolynomialDivision[p, q, x] gives a list of the quotient and remainder \
obtained by division of the polynomials p and q in x.\";

PolynomialEvaluation::usage = \"PolynomialEvaluation[PolynomialsOver[R], p, \
alpha] evaluates the polynomial p at alpha using the operations of the \
Ringoid R. PolynomialEvaluation[p, alpha] works similarly.\";

PolynomialGCD::usage = \"PolynomialGCD[PolynomialsOver[R], p, q] returns the \
greatest common divisor of the polynomials p and q (as elements of the ring \
of polynomials over R). PolynomialGCD[p, q] works similarly as long as \
polynomials p and q are both from the same ring of polynomials. \\nThe \
standard (built-in) usage still exists: PolynomialGCD[poly1, poly2, ...] \
gives the greatest common divisor of the polynomials poly1, poly2, ... . \
PolynomialGCD[poly1, poly2, ..., Modulus\[Rule]p] gives the GCD modulo the \
prime p.\";

PolynomialLCM::usage = \"PolynomialLCM[PolynomialsOver[R], p, q] returns the \
least common multiple of the polynomials p and q (as elements of the ring of \
polynomials over R). PolynomialLCM[p, q] works similarly as long as \
polynomials p and q are both from the same ring of polynomials. \\nThe \
standard (built-in) usage still exists: PolynomialLCM[poly1, poly2, ...] \
gives the least common multiple of the polynomials poly1, poly2, ... . \
PolynomialLCM[poly1, poly2, ..., Modulus\[Rule]p] gives the LCM modulo the \
prime p.\";

PolynomialQuotient::usage = \"PolynomialQuotient[PolynomialsOver[R], p, q] \
returns the quotient when the polynomial p is divided by the polynomial q (as \
elements of the ring of polynomials over R), provided that the leading \
coefficient of q is a unit in R. PolynomialQuotient[p, q] works similarly as \
long as polynomials p and q are both from the same ring of polynomials. \
\\nThe standard (built-in) usage still exists: PolynomialQuotient[p, q, x] \
gives the quotient of p and q, treated as polynomials in x, with any \
remainder dropped.\";

PolynomialRemainder::usage = \"PolynomialRemainder[PolynomialsOver[R], p, q] \
returns the remainder when the polynomial p is divided by the polynomial q \
(as elements of the ring of polynomials over R), provided that the leading \
coefficient of q is a unit in R. PolynomialRemainder[p, q] works similarly as \
long as polynomials p and q are both from the same ring of polynomials. \
\\nThe standard (built-in) usage still exists: PolynomialRemainder[p, q, x] \
gives the remainder from dividing p by q, treated as polynomials in x.\";

PolynomialsOfDegreeN::usage = \"PolynomialsOfDegreeN[R, n, opts] returns all \
polynomials of degree n over the ring R. Since this number can increase \
rather quickly, the option SizeLimit provides a maximum for the number of \
polynomials that will be produced. The default value is 125, but this can be \
changed using the option. Unless Indeterminate \[Rule] symbol is set, the \
default indeterminate is 'x'. A related function is \
PolynomialsUpToDegreeN.\";

PolynomialsOver::usage=\"PolynomialsOver[R] generates the RingExtension of \
polynomials over R.\";

PolynomialsUpToDegreeN::usage = \"PolynomialsUpToDegreeN[R, n, opts] returns \
all polynomials of degree n or less over the ring R. Since this number can \
increase rather quickly, the option SizeLimit provides a maximum for the \
number of polynomials that will be produced. The default value is 125, but \
this can be changed using the option. Unless Indeterminate \[Rule] symbol is \
set, the default indeterminate is 'x'. A related function is \
PolynomialsOfDegreeN.\";

PolyQ::usage = \"PolyQ[p] returns True if p is a polynomial obtained by the \
Poly function in AbstractAlgebra, and False otherwise.\";

PolyRing::usage=\"PolyRing is a parameter of RingExtension.\";

PolyToFunction::usage = \"PolyToFunction[R, p] constructs the function on the \
ringoid R that is defined by the polynomial p (constructed with Poly). If R \
has no unity, then $Failed is returned.\";

PowersIncrease::usage = \"PowersIncrease is an option that is used in \
specifying how a polynomial should be presented when called with the Poly \
function. It takes two values, RightToLeft and LeftToRight. The former \
returns a polynomial in the form 4x^2 + 3x + 1 while the latter returns 1 + \
3x + 4x^2 for the same polynomial.\";

RingExtension::usage=\"RingExtension is the head for ring extensions.\";

Solve::usage = \"Solve[PolynomialsOver[R], poly == r], when given a \
polynomial poly from the ring of polynomials over the Ringoid R and an \
element r from R, solves the equation poly == r in the indeterminate x. \
(Solve[poly == r] can also be used, with the underlying ring extracted from \
poly.) Solutions are returned as a list of rules (as per normal usage). These \
solutions can be used with ReplaceAll (or its equivalent, /.) just as the \
results of the ordinary (built-in) Solve, whose functionality still works: \
\\nSolve[eqns, vars] attempts to solve an equation or set of equations for \
the variables vars. Any variable in eqns but not vars is regarded as a \
parameter. Solve[eqns] treats all variables encountered as vars above. \
Solve[eqns, vars, elims] attempts to solve the equations for vars, \
eliminating the variables elims.\";

TestFunction::usage = \"TestFunction[ext] returns the function for the ring \
extension ext that determines if an element is a member of the extension.\";

ToOrdinaryPolynomial::usage = \"ToOrdinaryPolynomial[p] returns an expression \
that will be regarded as a polynomial in Mathematica's ordinary sense. Note \
that the underlying ring is lost in this transition and the new polynomial \
may or may not make sense (for ordinary Mathematica functions), depending on \
the ring.\";

Zeros::usage = \"Zeros[PolynomialsOver[R], p] returns the zeros, if any, of \
the polynomial p as a polynomial with coefficients from R. In other words, if \
z is the zero of R, this returns {x : p(x) = z}. Zeros[p] is another method \
of obtaining the same result.\";\
\>", "Input",
 CellMargins->{{Inherited, 41}, {Inherited, Inherited}},
 InitializationCell->True,
 AspectRatioFixed->True,
 CellTags->{"RingExtensionsUsage", "usagepackages"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.5.11 Ringoids", "Subsubsection",
 CellTags->{"RingoidsUsage", "usagepackages"}],

Cell["\<\
BooleanRing::usage = \"BooleanRing[n] constructs the Boolean Ring consisting \
of the set of subsets of {1, 2, ..., n} with the operations symmetric \
difference and intersection. BooleanRing[B] constructs the ring with subsets \
of the list B.\";

FormRingoidByTable::usage = \"FormRingoidByTable[list, additiontab, \
multiplicationtab, opts] is used for generating a Ringoid consisting of the \
elements in list and governed by the operations implicit in the Cayley tables \
additiontab and multiplicationtab. The options for opts can be WideElements, \
IsARing, RingoidDescription, RingoidName, FormatOperator, FormatElements, \
MaxElementsToList, KeyForm, and CayleyForm. See each of these individually \
for more information.\";

LatticeRing::usage = \"LatticeRing[n] returns the Ringoid of divisors of n \
with LCM/GCD for the addition and GCD for the multiplication.\";

TrivialZR::usage = \"TrivialZR[n] returns the ring of integers mod n with mod \
n addition but a multiplication with all products being zero.\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True,
 CellTags->{"RingoidsUsage", "usagepackages"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.5.12 RingProperties", "Subsubsection",
 CellTags->{"RingPropertiesUsage", "usagepackages"}],

Cell["\<\
AdditiveGroupoid::usage = \"AdditiveGroupoid[R] returns the additive Groupoid \
of the ring R. A shortcut is AGroupoid[R].\";

AGroupoid::usage = \"AGroupoid[R] returns the additive Groupoid associated \
with the Ringoid R. This is equivalent to AdditiveGroupoid[R].\";

Annihilator::usage = \"Annihilator[R, S] returns the annihilator of S in R. \
This consists of all elements r in R such that r s = Zero[R] for all elements \
s in S.\";

CayleyTables::usage = \"CayleyTables[R] returns the Cayley tables (in double \
array form), for the additive and multiplicative Groupoids associated with \
the Ringoid R. CayleyTables[R, Mode \[Rule] Visual] returns a graphical view \
of these tables. See CayleyTable for a description of the available \
options.\";

Characteristic::usage = \"Characteristic[R] returns the characteristic of the \
structure R.\";

ClosedDiffQ::usage = \"ClosedDiffQ[R, S] returns True if S is closed with \
respect to subtraction in the structure R, and False otherwise.\";

ClosedPlusQ::usage = \"ClosedPlusQ[R, S] returns True if S is closed with \
respect to addition in the structure R, and False otherwise.\";

ClosedTimesQ::usage = \"ClosedTimesQ[R, S] returns True if S is closed with \
respect to multiplication in the structure R, and False otherwise.\";

ComplexToPoint::usage = \"ComplexToPoint[z] returns {Re[z], Im[z]} given any \
complex number z.\";

DistributiveQ::usage = \"DistributiveQ[R] returns True if the Multiplication \
is (two-sided) distributive over the Addition in the structure R, and False \
otherwise.\";

EisensteinsCriterionQ::usage = \"EisensteinsCriterionQ[zpo\\ ly] returns True \
if Eisenstein's Criterion indicates that the polynomial zpoly, with \
coefficients from the integers, is irreducible, and False otherwise. The \
Textual mode is available.\";

FactorRing::usage = \"FactorRing[R, S] is equivalent to QuotientRing[R, S]; \
see QuotientRing for details.\";

FieldQ::usage = \"FieldQ[R] returns True if the Ringoid R is a field, and \
False otherwise.\";

GaussianIntegerQ::usage = \"GaussianIntegerQ[z] returns True if the complex \
number z is a Gaussian integer and false otherwise.\";

HasNegativeQ::usage = \"HasNegativeQ[R, r] returns True if r has a negative \
in the structure R, and False otherwise.\";

HasUnityQ::usage = \"HasUnityQ[R] returns True if the structure R has a \
unity, and False otherwise.\";

HasZeroQ::usage = \"HasZeroQ[R] returns True if the structure R has a zero, \
and False otherwise.\";

IdealQ::usage = \"IdealQ[S, R] returns True if the set S is an ideal of the \
structure R, and False otherwise.\";

IdempotentQ::usage = \"IdempotentQ[R, r] returns True if r is an idempotent \
in the structure R, and False otherwise.\";

Idempotents::usage = \"Idempotents[R] returns all the idempotent elements in \
the structure R.\";

IntegerLatticeGrid::usage = \"IntegerLatticeGrid[{a, b}, {c, d}, opts] \
returns a ListPlot of an integer lattice with domain [a,b] and range [c,d]. \
Any opts given are used by ListPlot.\";

IntegralDomainQ::usage = \"IntegralDomainQ[R] returns True if the structure R \
is an integral domain, and False otherwise.\"

InterpolatingPolynomial::usage = \"InterpolatingPolynomial[R,{{x,y},...}] \
returns the interpolating polynomial of degree at most n-1 where n is the \
number of pairs in {{x,y},...}. The x coordinates must all be distinct and R \
should be a field, for example Z[p] for prime p.\\nThe standard (built-in) \
usage still exists: InterpolatingPolynomial[data, var] gives a polynomial in \
the variable var which provides an exact fit to a list of data. The data can \
have the forms {{x1, f1}, {x2, f2}, ...} or {f1, f2, ...}, where in the \
second case, the xi are taken to have values 1, 2, .... The fi can be \
replaced by {fi, dfi, ddfi, ...}, specifying derivatives at the points xi.\";

J::usage = \"J is the symbol to represent an ideal in the quotient ring \
Z[I]/<z> for a Gaussian integer z.\";

LeftIdealQ::usage = \"LeftIdealQ[S, R] returns True if the set S is a left \
ideal of the structure R, and False otherwise.\";

LeftDistributiveQ::usage = \"LeftDistributiveQ[ R] returns True if the \
Multiplication is left distributive over the Addition in the structure R, and \
False otherwise.\";

LowerDegreeOK::usage = \"LowerDegreeOK is an option for \
RandomElement[RingExtension[PolyRing,...]] that controls whether random \
polynomials MUST have the specified degree (using the value False, the \
default value) or may have a degree less than or equal to the specified \
degree (using the value True).\";

MaximalIdealQ::usage = \"MaximalIdealQ[S, R] returns if the set S is a \
maximal ideal in the structure R, and False otherwise.\";

MGroupoid::usage = \"MGroupoid[R] returns the multiplicative Groupoid \
associated with the Ringoid R. This is equivalent to \
MultiplicativeGroupoid[R].\";

ModpIrreducibilityQ::usage = \"ModpIrreducibilityQ[zpoly] returns True if the \
Mod p Irreducibility Test indicates that the polynomial zpoly, with \
coefficients from the integers, is irreducible, and False otherwise. (This \
method tries the first 25 primes.) The Textual mode is available. \
ModpIrreducibilityQ[p, zpoly] tests the polynomial zpoly specifically with \
the prime p.\";

Monic::usage = \"Monic is an option to RandomElement for Polynomial Rings. \
When set to True, the random polynomial is to be monic, having the unit for \
the leading coefficient, while False does not impose this restriction.\";

MultipleOfElement::usage = \"MultipleOfElement[R, r, n] returns the nth \
multiple of the element r in the structure R. In other words, r + r + ... + r \
(n times) is returned. This is the additive version of ElementToPower.\";

MultiplicationTable::usage = \"MultiplicationTable[R] returns the \
multiplication table of the Ringoid R. MultiplicationTable[R, Mode \[Rule] \
Visual] returns a graphical view of this table.\";

MultiplicativeGroupoid::usage = \"MultiplicativeGroupoid[R] returns the \
multiplicative Groupoid of the ring R. A shortcut is MGroupoid[R].\";

MultiplicativeInverse::usage = \"MultiplicativeInverse[R, a] returns the \
multiplicative inverse of a in the structure R, if it exists, and $Failed \
otherwise.\";

NegationOf::usage = \"NegationOf[R, r] returns the additive inverse of r in \
the structure R, if it exists, and $Failed otherwise.\";

NilpotentDegree::usage = \"NilpotentDeg ree[R, r] returns 0 if the element r \
is NOT nilpotent in the structure R; otherwise a positive integer n is \
returned, which is the least positive integer such that r^n is the zero \
element.\";

NilpotentQ::usage = \"NilpotentQ[R, r] returns True if r is a nilpotent \
element in the structure R, and False otherwise.\";

Nilpotents::usage = \"Nilpotents[R] returns all the nilpotent elements in the \
structure R.\";

NonUnity::usage = \"NonUnity is value for the SelectFrom option for the \
RandomElement function, which when having the value True specifies that the \
chosen element should not be the unity.\";

NonZero::usage = \"NonZero is value for the SelectFrom option for the \
RandomElement function, which when having the value True specifies that the \
chosen element should not be the zero.\";

NonZeroMGroupoid::usage = \"NonZeroMGroupoid[R] returns the Groupoid of \
nonzero elements of R with the Multiplication from R. If R is a field, this \
is the group of units.\";

PrimeIdealQ::usage = \"PrimeIdealQ[S, R] returns True if the set S is a prime \
ideal in the structure R, and False otherwise.\";

PrincipalIdeal::usage = \"PrincipalIdeal[ R, r] returns the Ringoid <r> in \
the Ringoid R. This is the principal ideal generated by r in R.\";

ProbableRingQ::usage = \"ProbableRingQ[R] returns True if R is probably a \
ring (all properties are checked, except associativity and distributivity use \
the randomized versions), and False otherwise.\";

QuotientRing::usage = \"QuotientRing[R, S] returns the quotient ring formed \
by the ring R and the ideal S. Options for this function are Form and \
Representatives. Form can have the value Cosets (default) which returns the \
elements in coset form g + NS or g NS where NS is a symbol representing the \
Ideal (normal subgroup). Alternatively, one can use Form \[Rule] \
Representatives and then only the representatives of the cosets will be \
returned. The default list of representatives uses the 'smallest' element in \
the coset and is indicated by Representatives \[Rule] Canonical; if you wish \
to change this list, use Representatives \[Rule] list, where list is a list \
of one element from each coset. This can be used also if one has Form \[Rule] \
Cosets. By default, left cosets are used. For a polynomial p over the base \
ring R, QuotientRing[R, p] returns the Ringoid of polynomials mod p, if R is \
a Ringoid with unity and the leading coefficient of p is a unit of R. \
QuotientRing[Z[I], z] returns the quotient ring Z[I]/<z> for a Gaussian \
integer z; this has a Visual mode. WARNING: This function may use a lot of \
memory if R is large and/or the degree of p is large. (Note: A portion of the \
code that creates the Visual mode of QuotientRing[Z[I], z] utilize several \
functions in Stan Wagon's 'Mathematica in Action' book, pages 334, 335 (in \
the first edition from Freeman).)\";

RandomDistributiveQ::usage = \"RandomDistributiveQ[R] returns True if the \
Multiplication is likely to be distributive over the Addition in structure R \
(by checking 20 triples), and False otherwise. RandomDistributive[R, n] \
checks n triples.\";

RationalRootCandidates::usage = \"Ration alRootCandidates[poly] returns a \
list of candidates for the Rational Root Theorem, given the polynomial \
poly.\";

RationalRootTheorem::usage = \"RationalRootTheorem[poly] returns a list of \
two lists, given a polynomial poly. The first list consists of those rational \
candidates which are zeros for poly, while the second list consists of those \
rational candidates which are not zeros for poly.\";

RightDistributiveQ::usage = \"RightDistributiveQ[R] returns True if the \
Multiplication is right distributive over the Addition in the structure R, \
and False otherwise.\";

RightIdealQ::usage = \"RightIdealQ[S, R] returns True if the set S is a right \
ideal of the structure R, and False otherwise.\";

RingInfo::usage = \"RingInfo[R] is a list of facts about R that are generated \
by various tests of R.\";

RingQ::usage = \"RingQ[R] returns True if R is a ring, and False \
otherwise.\";

RingSolve::usage = \"RingSolve[R, a, b] solves the linear equation a x == b \
in the Ringoid R, returning a list of elements that solve the equation. The \
Solve command may also be useful.\";

SelectBaseElementsFrom::usage = \"SelectBaseElementsFrom is an option for \
RandomElement and RandomElements when using extension rings. The acceptable \
values for this option are Any, NonZero, NonUnity and NonIdentity.\";

SubringQ::usage = \"SubringQ[S, R] returns True if S is a subring of R, and \
False otherwise. (This function tests whether S is nonempty and closed with \
respect to difference and multiplication in R.)\";

UnitQ::usage = \"UnitQ[R, r] returns True if r is a unit in the structure R, \
and False otherwise.\";

Units::usage = \"Units[R] returns the list of units of the structure R.\";

Unity::usage = \"Unity[R] returns the unity of R, if one exists in R, and \
$Failed otherwise.\";

WithUnityQ::usage = \"WithUnityQ[R] returns True if the structure R has a \
unity, and False otherwise.\";

Zero::usage = \"Zero[R] returns the zero of R, if one exists in R, and \
$Failed otherwise.\";

ZeroDivisorQ::usage = \"ZeroDivisorQ[R, r] returns True if r is a zero \
divisor of the structure R, and False otherwise. Since this calls \
ZeroDivisors (which generates a complete list of zero divisors), a noticeable \
delay may be noticed upon the first call for large Ringoids.\";

ZeroDivisors::usage = \"ZeroDivisors[R] returns a list of all the zero \
divisors in the structure R. If R does not have a zero (HasZeroQ[R] == \
False), a message is returned. This calculation is based on the definition \
that if nonzero r and nonzero s have the product Zero[R], then r and s are \
both zero divisors.\"; \
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True,
 CellTags->{"RingPropertiesUsage", "usagepackages"}]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.5.13 Zd", "Subsubsection",
 CellTags->{"ZdUsage", "usagepackages"}],

Cell["\<\
Associates::usage = \"Associates is a value for the Combine option of \
IntegerDivisors and ZdDivisors. With this value, the divisors of n are \
grouped in pairs {a, b} such that a and b are associates.\";

Combine::usage = \"Combine is an option name for both IntegerDivisors and \
ZdDivisors. Its default value is False, which means the divisors are not \
grouped in any fashion. Other values are Products, Associates, or \
Negations.\";

DividesQ::usage = \"DividesQ[r, s] returns True if the integer s divided by \
the integer r is an integer, and False otherwise. DividesQ[r, s, Radical \
\[Rule] d] works similarly in \[DoubleStruckCapitalZ][\\!\\(\\@d\\)], \
returning True if r | s over this ring, and False otherwise.\";

DivisorsComplete::usage = \"DivisorsComplete is an option for IntegerDivisors \
and ZdDivisors. Its default value is False. With this, only one divisor from \
each class of associates is given. For integers, when set to False, this \
returns the positive divisors. For Gaussian integers (d = -1), when set to \
False, this returns the Gaussian integers in the first quadrant. In all other \
cases, when set to False, this returns the one that is in the right \
half-plane (or first quadrant for those on the imaginary axis) when the \
number a + b \\!\\(\\@d\\) is considered the ordered pair (a, b). In \
contrast, with the value True, all the divisors are included.\";

IntegerDivisors::usage = \"IntegerDivisors[n, opts] returns the divisors of \
the integer n, just as the built-in function Divisors[n] does. The options \
are Combine, NonTrivialOnly and DivisorsComplete. See these for more details.\
\";

Negations::usage = \"Negations is a value for the Combine option of \
IntegerDivisors and ZdDivisors. With this value, the divisors of n are \
grouped in pairs {a, b} such that a and b are negations.\";

NonTrivialOnly::usage = \"NonTrivialOnly is an option name for both \
IntegerDivisors and ZdDivisors. Its default value is False, which means that \
trivial divisors (\[PlusMinus] 1 and \[PlusMinus] n) are included, but \
excluded if set to True.\";

Products::usage = \"Products is a value for the Combine option of \
IntegerDivisors and ZdDivisors. With this value, the divisors of n are \
grouped in pairs {a, b} such that a*b = n.\";

Radical::usage = \"Radical is an option for DividesQ that specifies the value \
of d when division takes place in \[DoubleStruckCapitalZ][\\!\\(\\@d\\)]. The \
value for this option needs to be a square-free integer.\";

ValuesHavingGivenNorm::usage = \"ValuesHavingGivenNorm[d, nrm], for negative \
d, returns the list (possibly empty) of values in Z[Sqrt[d]] that have the \
norm value of nrm. For positive d, ValuesHavingGivenNorm[d, nrm, iter] \
returns a (partial) list of values having the given norm obtained after iter \
number of iterations of an algorithm to search along the relevant hyperbola. \
The value for iter defaults to 50 if omitted. For positive d, the list is \
incomplete.\";

ZdAssociatesQ::usage = \"ZdAssociatesQ[d, a, b] returns True if a and b are \
associates over \[DoubleStruckCapitalZ][\\!\\(\\@d\\)], and False \
otherwise.\";

ZdCombineAssociates::usage = \"ZdCombineAssociates[d, lst] takes the list of \
elements lst from \[DoubleStruckCapitalZ][\\!\\(\\@d\\)] and returns a new \
list of lists, with each new list containing those elements in lst that are \
associates with each other.\";

ZdConjugate::usage = \"ZdConjugate[a + b Sqrt[d]] returns a - b \
\\!\\(\\@d\\), the conjugate in \[DoubleStruckCapitalZ][\\!\\(\\@d\\)].\";

ZdDivide::usage = \"ZdDivide[x, y] returns the quotient x/y in the form r + s \
\\!\\(\\@d\\) when x and y are both in \
\[DoubleStruckCapitalZ][\\!\\(\\@d\\)].\";

ZdDividesQ::usage = \"ZdDividesQ[d, a, b] is equivalent to DividesQ[a, b, \
Radical \[Rule] d].\";

ZdDivisors::usage = \"ZdDivisors[d, x, (opts)], when d is negative, returns \
all the divisors of the number x in \[DoubleStruckCapitalZ][\\!\\(\\@d\\)], \
possibly restricted by the options in opts. When d is positive, ZdDivisors[d, \
x, max] returns all the divisors of x (possibly modified by opts) in \
\[DoubleStruckCapitalZ][\\!\\(\\@d\\)] whose norm is less than or equal to \
the norm of the integer max. Available options are Combine, NonTrivialOnly, \
and DivisorsComplete. See them for more details.\";

ZdIrreducibleQ::usage = \"ZdIrreducibleQ[d, x], for negative d, returns True \
if x is irreducible in \[DoubleStruckCapitalZ][\\!\\(\\@d\\)], and False \
otherwise.\";

ZdNorm::usage = \"ZdNorm[x] returns the norm of x as an element in \
\[DoubleStruckCapitalZ][\\!\\(\\@d\\)] for some d, which is the value |a^2 - \
d b^2| when x = a + b \\!\\(\\@d\\).\";

ZdPossibleNorms::usage = \"ZdPossibleNorms[d, max], for negative d only, \
returns all the norms that can occur in \
\[DoubleStruckCapitalZ][\\!\\(\\@d\\)] that are less than or equal to max. \
This function has a Visual mode available.\";

ZdPossibleNormQ::usage = \"ZdPossibleNormQ[d, nrm], for negative d only, \
returns True if the value nrm can occur (i.e., it is possible) in \
\[DoubleStruckCapitalZ][\\!\\(\\@d\\)], and False otherwise.\";

ZdQ::usage = \"ZdQ[x] returns True if x can be viewed as an element in \
\[DoubleStruckCapitalZ][\\!\\(\\@d\\)] for some d, and False otherwise.\";

ZdUnitQ::usage = \"ZdUnitQ[d, x] returns True if x is a unit in \
\[DoubleStruckCapitalZ][\\!\\(\\@d\\)], and False otherwise.\"; \
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True,
 CellTags->{"ZdUsage", "usagepackages"}]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.3.6 Error messages", "Subsection",
 FontFamily->"Times",
 CellTags->"errormessages"],

Cell["\<\
Adjoin::fail = \"The expression `1` needs be an nth root of some number for \
this function to work.\";

Automorphism::badrule=\"The rule provided does not uniquely define an \
automorphism on `1`. The rule must map a generator to a generator.\";

Automorphism::nosup=\"Automorphism only supports cyclic groups at this \
time.\";

AutomorphismGroup::nosup=\"AutomorphismGroup only supports cyclic groups at \
this time.\";

Characteristic::fail = \"This Ringoid either is not a ring or does not have a \
unity, and so it does not make sense to find its characteristic.\";

Coefficient::ind = \"Since `1` uses the indeterminate `2`, `3` shouldn't be \
specified as the indeterminate. Mention of the indeterminate is optional; it \
can be omitted.\";

Conjugate::fail = \"For ElementConjugate, both `1` and `2` need to be \
elements of the group, while for SubgroupConjugate `1` needs to be a subgroup \
and `2` an element.\";

CosetToList::illformed = \"The coset `1` is ill-formed.\";

Cycle::disjoint = \"The cycles in the list `1` need to be disjoint to use \
this function.\";

DirectProduct::ArgErr=\"Direct Product called with incorrect arguments.\";

Dot::DimErr=\"Dimensions of parameters to Dot fail to match.\";

FormMorphoid::badpos=\"Invalid list of positions.\";

FormMorphoid::badstruc = \"In creating a Morphoid between two structures A \
and B, these structures must be both Groupoids or both Ringoids.\";

FormRingoid::diffels = \"In forming a Ringoid in this fashion, the list of \
elements in the first Groupoid, `1`, must match those in the second Groupoid, \
`2`.\";

FormRingoid::size = \"The index for this structure needs to be less than `1`, \
which `2` is not.\";

FuncToRules::invalid=\"The length of the Func object does not match the size \
of the base ring.\";

GF::badindex = \"The index for GF needs to be a power of a prime, which `1` \
is not.\";

GF::bases = \"The polynomial `1` was given over the base ring `2`, while it \
should be over the base ring Z[`3`].\";

GF::deg = \"To form a Galois field GF[`1`^`2`], the polynomial `3` must be of \
degree `2`, but this has degree `4`.\";

GF::irr = \"The polynomial `1` needs to be irreducible over Z[`2`].\";

GF::notdef = \"First define a field by using the GF function.\";

GF::poly = \"The expression `1` needs to be a polynomial in the indeterminate \
`2`.\";

GF::var = \"The polynomial `1` and indeterminate `2` do not match.\";

GenerateGroupoid::size = \"The size of the set generated thus far exceeds the \
current value of `1` given by the option SizeLimit. (The elements generated \
thus far are shown below.)\";

GenerateGroupoid::size = \"The size of the set generated thus far exceeds the \
current value of `1` given by the option SizeLimit. (The elements generated \
thus far are shown below.)\";

Generator::string = \"This function requires the generator to be a string or \
an undefined symbol. Your symbol `1` is not a string.\";

Group::fail = \"The Groupoid `1` fails at least one of the tests for being a \
group, which is needed for this function.\";

Group::noord = \"The element `1` in the Groupoid `2` does not have an \
order.\";

Group::notcyclic = \"The group `1` is not a cyclic group.\";

Group::notnorm = \"`1` is not a normal subgroup of `2`.\";

Group::size = \"Are you sure you want `1`? This group has `2` elements in it. \
By default, the index must be less than or equal to `3`. If you wish to \
increase it, add the option 'IndexLimit \[Rule] k' to this function, where k \
is the new desired maximum for the index.\";

Groupoid::fail = \"In applying this function, it has to act on a Groupoid. \
Check to be sure `1` has been properly formed using FormGroupoid or \
GenerateGroupoid (or equivalent).\";

Groupoid::fail = \"In applying this function, it has to act on a Groupoid. \
Check to be sure `1` has been properly formed using FormGroupoid or \
GenerateGroupoid (or other acceptable means).\";

Groupoid::modd = \"The integer `1` does not divide the modulus `2`.\";

Groupoid::reorderfail = \"The elements `2` cannot be used to reorder the \
elements in `1` since they are not the same list.\";

IdealQ::fail = \"The Ringoid needs to be commutative and with a unity.\";

Identity::fail = \"`1` does not have an identity.\";

Identity::lfail = \"`1` does not have a left identity.\";

Identity::lmultiple = \"`1` has the following left identities: `2`.\";

Identity::nonsquare = \"To have an Identity matrix, one needs to consider \
square matrices.\";

Identity::rfail = \"`1` does not have a right identity.\";

Identity::rmultiple = \"`1` has the following right identities: `2`.\";

InnerAutomorphism::noinv=\"InnerAutomorphism is not defined; group element \
`1` does not have an inverse.\";

InnerAutomorphismGroup::nogroup=\"`1` is not a group, which is necessary for \
this function.\";

Inverse::fail = \"`1` does not have an inverse in `2`.\";

Inverse::noId = \"`1` does not have an identity, so the notion of inverse \
does not make sense.\";

IrreduciblePolyOverZpQ::prime = \"The polynomial needs to be over a prime \
index, not `1`.\";

IrreduciblePolynomial::badindex = \"Bad input: the second parameter, `1`, for \
IrreduciblePolynomial needs to be a prime and the third, `2`, needs to be a \
positive integer.\";

IsomorphismQ::notHom = \"The Morphoid is not a homomorphism, so it is not \
possible to be an isomorphism.\";

Kernel::noid=\"Kernel is undefined; the codomain `1` does not have an \
identity\";

Klein4::warning = \"The elements e, a, b, c are considered strings and thus \
need to have double quotes around them when being used.\";

List::lngth = \"The two lists are not of the same length.\";

MemberQ::elmnt = \"`1` is not an element of `2`.\";

MemberQ::elmnts = \"At least one of `1` is not an element of `2`.\";

MemberQ::elsbst = \"`1` is neither an element nor a subset of `2`.\";

MemberQ::sbgrp = \"`1` is not a subgroup of `2`.\";

Mode::notavail = \"The function `1` does not support the `2` mode.\";

Mode::novis = \"This function does not support the Visual mode.\";

ModpIrreducibilityQ::baddeg = \"Using the prime number `1`, the degree of the \
reduced polynomial does not match the degree of the original. This is \
necessary.\";

ModpIrreducibilityQ::badpoly = \"The expression `1` is an ill-formed \
polynomial.\";

Morphoid::badarg=\"Invalid argument(s) to `1`.\";

Morphoid::dff = \"The number of elements in `1` is not the same as in `2`, so \
it cannot be an isomorphism.\";

Morphoid::domain = \"The list of rules `1` needs to have exactly one instance \
of the elements of the domain `2` occurring on the left-hand side of the \
rules before we can have a Morphoid.\";

Morphoid::fail = \"The function or rules `1` need to carry the elements of \
`2` to `3` before we can have a Morphoid.\";

Morphoid::notonto=\"Since the Morphoid is not onto, it can not be an \
isomorphism.\";

Morphoid::npres=\"This Morphoid does not preserve the operation(s) for at \
least one pair of elements.\";

Morphoid::range = \"The values on the right-hand side of each rule in `1` \
need to form a subset of the codomain `2` before we can have a Morphoid.\";

MorphoidComposition::notdef2=\"The composition is not defined because the \
first Morphoid is based on `1` while the second is based on `2`, which are \
not the same.\";

MorphoidComposition::notdef=\"The composition is not defined because the \
image of the first map is `1` while the domain of the second map is `2`, \
which are not the same.\";

Multiplication::fail = \"A `1` by `2` matrix can not be multiplied by a `3` \
by `4` matrix.\";

Operation::fail = \"The operation of the substructure(s) does not match that \
of the parent structure.\";

PermutationQ::diffels = \"`1` is not a permutation of `2` since they do not \
have the same elements.\";

PermutationQ::difflen = \"`1` is not a permutation of `2` since they do not \
have the same length.\";

PermutationQ::duplicates = \"A permutation can not have elements listed twice \
as `1` does.\";

PermutationQ::fail = \"`1` is not a permutation.\";

PermutationQ::length = \"The permutation `1` should have exactly the `2` \
elements from 1 to `2` in some order. If `1` is actually a cycle and you are \
trying to use it as a permutation, convert it by using the ToPermutation \
function.\";

PermutationQ::missing = \"A permutation on `1` must be a list containing all \
of the integers from 1 to `2`. `3` is missing some values.\";

PermutationQ::notrule = \"The list `1` needs to have every element either in \
the form a \[Rule] b or {a \[Rule] b} in order to represent a permutation by \
using rules.\";

Poly::badInd = \"The indeterminate chosen for this polynomial, `1`, can not \
be used. (Perhaps it is a symbol with an assigned value.) The symbol 'x' will \
be the indeterminate used.\";

Poly::bragrm = \"To perform operations on polynomials, one must use the same \
base ring for both polynomials.\";

Poly::extagrm = \"To perform operations on polynomials, one must use the same \
base ring for the polynomials as for the specified base ring in the \
extension.\";

Poly::mixvars = \"In your polynomial `1`, you should be using only a single \
variable (such as x), but the variables `2` were used.\";

PolynomialDivision::undef=\"Since the leading coefficient, `1`, is not a unit \
in `2`, division is undefined.\";

PolynomialGCD::undefined= \"The result of PolynomialGCD is undefined because \
the base is not a ring or there is an undefined division.\";

PolynomialsOfDegreeN::toobig =\"Using degree `1`, there would be about `2` \
polynomials, which is larger than the current limit of `3`. You can override \
this limit by using the option SizeLimit \[Rule] `2`.\";

ProbableMorphismQ::warning = \"The ProbableMorphismQ function is being used; \
'True' results are only probable, not certain.\";

QuaternionGroup::JJKK = \"(Note that KK is used because K is a reserved \
symbol since version 3 of Mathematica and JJ is used because J is reserved as \
a generic name for an ideal.)\";

QuotientGroup::NS = \"This quotient group uses NS to represent the normal \
subgroup `1` that you specified. Use CosetToList to convert this coset \
representation to a list of elements.\";

QuotientGroup::badrep = \"Your choice of `1` for representatives is a bad \
representation. Make sure you have only one from each coset.\";

QuotientGroup::replngth = \"Your choice of representatives is not of the \
correct length. There should be `1` elements.\";

QuotientRing::J = \"This quotient ring uses J to represent the principal \
ideal generated by `1`.\";

QuotientRing::NS = \"This quotient ring uses NS to represent the ideal \
(normal subgroup) `1` that you specified. Use CosetToList to convert this \
coset representation to a list of the elements.\";

QuotientRing::badz = \"For this function, the parameter z must be a Gaussian \
integer other than 1, -1, I, -I, which `1` is not.\";

QuotientRing::notideal = \"The set `1` is not an ideal of the Ringoid `2`.\";

QuotientRing::toobig=\"The requested quotient ring is likely to be too large. \
The SizeLimit option can be reset to a higher value.\";

Random::notype = \"`1` is not an acceptable value for MatrixType.\";

Random::toomany = \"After 500 attempts, a random matrix meeting these \
conditions was not found.\";

RandomElement::fail = \"When trying to comply with the option SelectFrom \
\[Rule] `1`, this Ringoid does not have enough elements to still choose a \
random element.\";

RandomElement::gfail = \"Trying to comply with the option SelectFrom \
\[CapitalAE] `1`, this Groupoid does not have enough elements to still choose \
a random element.\";

RandomElement::sqrfree = \"The index to the Z function must be square-free to \
work here.\";

RandomElements::toomany = \"You can't ask for `1` random elements when there \
are only `2` available.\";

RandomElements::toomanyk = \"You can not obtain `1` random elements from this \
structure using the given options.\";

RandomElements::toomanyni = \"You can't ask for `1` non-identity random \
elements when there are only `2` to start with and you don't want the \
identity.\";

Ring::fail = \"The structure `1` fails to be a ring.\";

Ring::subringfail = \"The set `1` fails to be a subring of the ring.\";

RingExtension::NoInverse=\"There is no multiplicative inverse in the \
extension ring because of the lack of a multiplicative inverse in the base \
ring.\";

RingExtension::NoNegat=\"There is no negation in extension ring because of \
the lack of a negation in the base ring.\";

RingExtension::NoUnity = \"The extension ring does not have a unity because \
the base ring does not have a unity (or possibly a zero).\";

RingExtension::NoZero =\"The extension ring does not have a zero because the \
base ring does not have a zero.\";

RingExtension::NotBaseElement = \"The element `1` is not in the base ring.\";

Ringoid::NotUnit=\"`1` is not a unit of `2`\";

Rule::form = \"The list of rules is ill-formed. Each integer from 1 to `1` \
should appear exactly once before and after each \[CapitalAE].\";

SizeLimit::toobig = \"With the present restriction on SizeLimit, there are \
too many elements to form a Groupoid that determines all of the elements.\";

Structure::nosup=\"`1` does not support structures of type `2`.\";

TheSet::error = \"Some of the elements in `1` do not belong to the set of \
elements of this Groupoid. Default value for TheSet, Elements[G], will be \
used.\";

UnitQ::nounity=\"The ring does not have a unity; no units are possible.\";

ZMap::relpr = \"In forming ZMap[`1`, `2`, `3` \[Rule] `4`], the element `3` \
must be a generator in Z[`1`].\";

ZdNorm::int = \"The number `1` cannot be used as a value for the parameter d \
for this function, since it needs to be an integer.\";

ZdNorm::one = \"The number 1 cannot be used as a value for the parameter d \
for this function.\";

ZdNorm::sqfree = \"The number `1` is not square-free, as is required for this \
function.\";

ZeroDivisors::NA = \"The Ringoid does not have a zero and so the notion of \
zero divisors does not make sense.\";\
\>", "Input",
 CellTags->"errormessages"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["6.4 Appendix B - Lab 0", "Section",
 FontFamily->"Times",
 FontSize->18,
 CellTags->{"Lab0", "i:21"}],

Cell[TextData[{
 "As an introduction to using ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ", we have included Lab 0 Getting Started with ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ". In addition to providing a jump start to using ",
 StyleBox["Mathematica,",
  FontSlant->"Italic"],
 " it introduces working with the integers mod ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]]],
 " and also a brief discussion on the gcd and the lcm of two integers. This \
notebook can be found in the Lab0 directory of the ",
 StyleBox["AbstractAlgebra",
  FontFamily->"Courier"],
 " directory or it can be viewed either from ",
 ButtonBox["inside the browser",
  BaseStyle->"AddOnsLink",
  ButtonData:>{
   "Lab0 (Intro to Mathematica)-In Browser", 
    "Lab0 (Intro to Mathematica)-In Browser"}],
 " or from ",
 ButtonBox["outside of the browser",
  BaseStyle->"AddOnsLink",
  ButtonData:>{
   "Lab0 (Intro to Mathematica)-Stand Alone", 
    "Lab0 (Intro to Mathematica)-Stand Alone"}],
 "."
}], "Text",
 CellTags->"Lab0"]
}, Open  ]]
}, Open  ]]
},
AutoGeneratedPackage->None,
ScreenStyleEnvironment->"AllBrackets",
WindowToolbars->{"RulerBar", "EditBar"},
WindowSize->{711, 547},
WindowMargins->{{4, Automatic}, {Automatic, 33}},
ShowGroupOpener->True,
TaggingRules:>{
 "NextIndexingNumber" -> 24, 
  "IndexEntries" -> {{"i:1", "Installation instructions"}, {
    "i:3", "Bibliography"}, {"i:3", "References"}, {
    "i:1", "AbstractAlgebra", "Installation instructions"}, {
    "i:10", "GroupProperties", "list of objects in package"}, {
    "i:11", "Joint", "list of objects in package"}, {
    "i:12", "LabCode", "list of objects in package"}, {
    "i:13", "Matrices", "list of objects in package"}, {
    "i:14", "Morphisms", "list of objects in package"}, {
    "i:15", "Permutations", "list of objects in package"}, {
    "i:16", "RingExtensions", "list of objects in package"}, {
    "i:17", "Ringoids", "list of objects in package"}, {
    "i:18", "RingProperties", "list of objects in package"}, {
    "i:19", "Zd", "list of objects in package"}, {
    "i:20", "AbstractAlgebra", {"Objects extended from standard ", 
      StyleBox["Mathematica", FontSlant -> "Italic"], " "}}, {
    "i:21", "Lab 0", {"Getting Started with ", 
      StyleBox["Mathematica", FontSlant -> "Italic"]}}, {
    "i:22", "AbstractAlgebra", "usage statements listed alphabetically"}, {
    "i:23", "AbstractAlgebra", "usage statements listed by packages"}, {
    "i:4", "AbstractAlgebra", "objects listed alphabetically"}, {
    "i:4", "Objects in AbstractAlgebra", "Alphabetically"}, {
    "i:5", "AbstractAlgebra", "objects by packages"}, {
    "i:5", "Objects in AbstractAlgebra", "by packages"}, {
    "i:7", "Core", "list of objects in package"}, {
    "i:8", "FiniteFields", "list of objects in package"}, {
    "i:9", "Groupoids", "list of objects in package"}}},
ShowCellTags->True,
MacintoshSystemPageSetup -> \
"00<0004/0B`000002mT8o?mooh<<HPUi0fL5:0?l0080004/0B`000000]P2:001\n\
0000I00000400`<300000BL?00400@0000000000000006P801T1T00000000000\n\
00000000000000000000000000000000",
FrontEndVersion->"6.0 for Mac OS X x86 (32-bit) (June 19, 2007)",
StyleDefinitions->"Manual.nb"
]
(* End of Notebook Content *)

(* Internal cache information *)
(*CellTagsOutline
CellTagsIndex->{
 "i:1"->{
  Cell[1563, 64, 131, 3, 76, "Section",
   CellTags->{"i:1", "install2w"}]},
 "install2w"->{
  Cell[1563, 64, 131, 3, 76, "Section",
   CellTags->{"i:1", "install2w"}],
  Cell[1719, 71, 99, 2, 64, "Subsection",
   CellTags->"install2w"],
  Cell[1821, 75, 647, 19, 68, "Text",
   CellTags->"install2w"],
  Cell[2471, 96, 702, 15, 98, "Text",
   CellTags->"install2w"]},
 "install2o"->{
  Cell[3210, 116, 107, 2, 64, "Subsection",
   CellTags->"install2o"],
  Cell[3320, 120, 579, 17, 68, "Text",
   CellTags->"install2o"],
  Cell[3902, 139, 333, 10, 53, "Text",
   CellTags->"install2o"]},
 "install3"->{
  Cell[4272, 154, 94, 2, 68, "Subsection",
   CellTags->"install3"],
  Cell[4369, 158, 773, 18, 106, "Text",
   CellTags->"install3"],
  Cell[5145, 178, 302, 8, 59, "Text",
   CellTags->"install3"],
  Cell[5450, 188, 599, 15, 112, "Text",
   CellTags->"install3"],
  Cell[6052, 205, 864, 28, 335, "Text",
   CellTags->"install3"],
  Cell[6919, 235, 1253, 26, 211, "Text",
   CellTags->"install3"],
  Cell[8175, 263, 1363, 33, 197, "Text",
   CellTags->"install3"]},
 "installFromWeb"->{
  Cell[9575, 301, 83, 1, 68, "Subsection",
   CellTags->"installFromWeb"],
  Cell[9661, 304, 2039, 49, 291, "Text",
   CellTags->"installFromWeb"],
  Cell[11703, 355, 896, 17, 421, "Text",
   CellTags->"installFromWeb"]},
 "i:3"->{
  Cell[12648, 378, 122, 3, 81, "Section",
   CellTags->{"i:3", "MathematicaRefs"}]},
 "MathematicaRefs"->{
  Cell[12648, 378, 122, 3, 81, "Section",
   CellTags->{"i:3", "MathematicaRefs"}],
  Cell[12773, 383, 307, 8, 51, "Text",
   CellTags->"MathematicaRefs"],
  Cell[13083, 393, 271, 10, 35, "Text",
   CellTags->"MathematicaRefs"],
  Cell[13357, 405, 251, 7, 51, "Text",
   CellTags->"MathematicaRefs"],
  Cell[13611, 414, 249, 7, 51, "Text",
   CellTags->"MathematicaRefs"],
  Cell[13863, 423, 223, 7, 35, "Text",
   CellTags->"MathematicaRefs"],
  Cell[14089, 432, 243, 7, 35, "Text",
   CellTags->"MathematicaRefs"],
  Cell[14335, 441, 244, 7, 51, "Text",
   CellTags->"MathematicaRefs"],
  Cell[14582, 450, 309, 8, 51, "Text",
   CellTags->"MathematicaRefs"],
  Cell[14894, 460, 233, 7, 35, "Text",
   CellTags->"MathematicaRefs"],
  Cell[15130, 469, 241, 7, 35, "Text",
   CellTags->"MathematicaRefs"],
  Cell[15374, 478, 220, 7, 35, "Text",
   CellTags->"MathematicaRefs"],
  Cell[15597, 487, 214, 7, 35, "Text",
   CellTags->"MathematicaRefs"],
  Cell[15814, 496, 244, 7, 23, "Text",
   CellTags->"MathematicaRefs"],
  Cell[16061, 505, 228, 7, 23, "Text",
   CellTags->"MathematicaRefs"],
  Cell[16292, 514, 287, 9, 39, "Text",
   CellTags->"MathematicaRefs"],
  Cell[16582, 525, 247, 9, 23, "Text",
   CellTags->"MathematicaRefs"],
  Cell[16832, 536, 252, 8, 39, "Text",
   CellTags->"MathematicaRefs"]},
 "alpha"->{
  Cell[17245, 555, 108, 2, 56, "Subsection",
   CellTags->{"alpha", "i:4"}],
  Cell[17356, 559, 206, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[17565, 569, 247, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[17815, 581, 251, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[18069, 593, 231, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[18303, 605, 243, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[18549, 617, 216, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[18768, 629, 243, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[19014, 641, 217, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[19234, 651, 205, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[19442, 661, 217, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[19662, 673, 210, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[19875, 683, 243, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[20121, 695, 216, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[20340, 705, 250, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[20593, 717, 245, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[20841, 729, 204, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[21048, 739, 213, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[21264, 749, 265, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[21532, 761, 233, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[21768, 773, 243, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[22014, 785, 248, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[22265, 797, 247, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[22515, 809, 253, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[22771, 821, 252, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[23026, 833, 270, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[23299, 845, 223, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[23525, 857, 223, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[23751, 869, 247, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[24001, 881, 235, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[24239, 893, 184, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[24426, 903, 193, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[24622, 913, 198, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[24823, 923, 194, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[25020, 933, 226, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[25249, 943, 247, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[25499, 955, 243, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[25745, 967, 222, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[25970, 979, 239, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[26212, 991, 229, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[26444, 1001, 259, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[26706, 1013, 207, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[26916, 1023, 240, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[27159, 1035, 230, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[27392, 1047, 228, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[27623, 1059, 225, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[27851, 1071, 211, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[28065, 1083, 192, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[28260, 1093, 239, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[28502, 1105, 230, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[28735, 1117, 225, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[28963, 1129, 226, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[29192, 1141, 204, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[29399, 1151, 209, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[29611, 1161, 241, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[29855, 1173, 202, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[30060, 1183, 202, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[30265, 1193, 241, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[30509, 1205, 248, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[30760, 1217, 265, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[31028, 1229, 232, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[31263, 1241, 260, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[31526, 1253, 203, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[31732, 1263, 200, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[31935, 1273, 179, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[32117, 1283, 239, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[32359, 1295, 266, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[32628, 1307, 270, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[32901, 1319, 238, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[33142, 1329, 255, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[33400, 1341, 253, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[33656, 1353, 234, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[33893, 1365, 252, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[34148, 1377, 245, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[34396, 1389, 270, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[34669, 1401, 233, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[34905, 1413, 234, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[35142, 1425, 216, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[35361, 1435, 207, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[35571, 1445, 187, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[35761, 1455, 235, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[35999, 1467, 212, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[36214, 1477, 232, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[36449, 1489, 207, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[36659, 1499, 249, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[36911, 1511, 245, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[37159, 1523, 247, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[37409, 1535, 228, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[37640, 1547, 210, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[37853, 1559, 173, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[38029, 1569, 221, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[38253, 1581, 215, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[38471, 1591, 253, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[38727, 1603, 206, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[38936, 1613, 188, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[39127, 1623, 248, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[39378, 1635, 230, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[39611, 1647, 222, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[39836, 1657, 226, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[40065, 1667, 254, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[40322, 1679, 261, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[40586, 1691, 226, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[40815, 1703, 228, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[41046, 1715, 244, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[41293, 1727, 203, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[41499, 1737, 198, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[41700, 1747, 255, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[41958, 1759, 250, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[42211, 1771, 229, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[42443, 1783, 249, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[42695, 1795, 225, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[42923, 1807, 245, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[43171, 1819, 225, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[43399, 1829, 224, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[43626, 1839, 228, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[43857, 1849, 244, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[44104, 1861, 223, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[44330, 1873, 210, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[44543, 1885, 243, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[44789, 1897, 243, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[45035, 1909, 226, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[45264, 1921, 205, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[45472, 1931, 234, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[45709, 1941, 214, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[45926, 1951, 239, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[46168, 1963, 251, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[46422, 1975, 235, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[46660, 1987, 243, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[46906, 1999, 240, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[47149, 2011, 239, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[47391, 2023, 226, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[47620, 2035, 240, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[47863, 2047, 241, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[48107, 2059, 253, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[48363, 2071, 229, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[48595, 2081, 213, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[48811, 2091, 251, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[49065, 2103, 260, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[49328, 2115, 220, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[49551, 2125, 227, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[49781, 2137, 176, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[49960, 2147, 226, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[50189, 2157, 229, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[50421, 2167, 263, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[50687, 2179, 215, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[50905, 2189, 240, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[51148, 2201, 196, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[51347, 2211, 248, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[51598, 2223, 196, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[51797, 2233, 193, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[51993, 2243, 228, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[52224, 2253, 197, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[52424, 2263, 195, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[52622, 2273, 244, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[52869, 2285, 203, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[53075, 2295, 247, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[53325, 2307, 230, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[53558, 2319, 227, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[53788, 2331, 232, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[54023, 2343, 229, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[54255, 2355, 219, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[54477, 2367, 237, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[54717, 2379, 232, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[54952, 2391, 229, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[55184, 2403, 190, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[55377, 2413, 211, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[55591, 2423, 258, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[55852, 2433, 200, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[56055, 2443, 205, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[56263, 2453, 230, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[56496, 2465, 247, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[56746, 2477, 227, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[56976, 2489, 187, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[57166, 2499, 208, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[57377, 2509, 177, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[57557, 2519, 197, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[57757, 2529, 235, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[57995, 2541, 233, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[58231, 2553, 206, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[58440, 2563, 252, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[58695, 2575, 204, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[58902, 2585, 193, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[59098, 2595, 189, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[59290, 2605, 287, 10, 29, "Index",
   CellTags->"alpha"],
  Cell[59580, 2617, 292, 10, 29, "Index",
   CellTags->"alpha"],
  Cell[59875, 2629, 277, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[60155, 2641, 238, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[60396, 2653, 200, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[60599, 2663, 205, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[60807, 2673, 202, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[61012, 2683, 212, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[61227, 2693, 245, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[61475, 2705, 228, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[61706, 2717, 183, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[61892, 2727, 217, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[62112, 2739, 226, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[62341, 2751, 242, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[62586, 2763, 196, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[62785, 2773, 227, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[63015, 2785, 258, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[63276, 2797, 269, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[63548, 2809, 209, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[63760, 2819, 212, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[63975, 2829, 202, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[64180, 2839, 198, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[64381, 2849, 201, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[64585, 2859, 272, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[64860, 2871, 237, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[65100, 2883, 211, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[65314, 2893, 229, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[65546, 2905, 230, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[65779, 2917, 195, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[65977, 2927, 270, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[66250, 2939, 252, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[66505, 2951, 349, 12, 15, "Index",
   CellTags->"alpha"],
  Cell[66857, 2965, 262, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[67122, 2977, 223, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[67348, 2989, 221, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[67572, 2999, 253, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[67828, 3011, 223, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[68054, 3023, 205, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[68262, 3033, 239, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[68504, 3045, 206, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[68713, 3055, 214, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[68930, 3065, 201, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[69134, 3075, 251, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[69388, 3087, 240, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[69631, 3099, 252, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[69886, 3111, 235, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[70124, 3123, 210, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[70337, 3133, 198, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[70538, 3143, 214, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[70755, 3153, 214, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[70972, 3163, 219, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[71194, 3175, 251, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[71448, 3187, 288, 10, 29, "Index",
   CellTags->"alpha"],
  Cell[71739, 3199, 253, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[71995, 3211, 238, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[72236, 3223, 258, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[72497, 3235, 246, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[72746, 3247, 215, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[72964, 3259, 207, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[73174, 3269, 209, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[73386, 3279, 256, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[73645, 3291, 184, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[73832, 3301, 198, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[74033, 3311, 203, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[74239, 3321, 194, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[74436, 3331, 191, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[74630, 3341, 242, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[74875, 3351, 237, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[75115, 3363, 204, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[75322, 3373, 272, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[75597, 3385, 342, 14, 15, "Index",
   CellTags->"alpha"],
  Cell[75942, 3401, 235, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[76180, 3411, 236, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[76419, 3421, 236, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[76658, 3433, 231, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[76892, 3445, 266, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[77161, 3457, 227, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[77391, 3469, 251, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[77645, 3481, 269, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[77917, 3493, 202, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[78122, 3503, 203, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[78328, 3513, 226, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[78557, 3525, 222, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[78782, 3537, 209, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[78994, 3547, 248, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[79245, 3559, 229, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[79477, 3569, 227, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[79707, 3581, 225, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[79935, 3593, 222, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[80160, 3605, 248, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[80411, 3617, 229, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[80643, 3627, 222, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[80868, 3639, 215, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[81086, 3651, 226, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[81315, 3663, 226, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[81544, 3675, 219, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[81766, 3687, 227, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[81996, 3699, 220, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[82219, 3711, 248, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[82470, 3723, 202, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[82675, 3733, 201, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[82879, 3743, 200, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[83082, 3753, 204, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[83289, 3763, 234, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[83526, 3775, 251, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[83780, 3787, 253, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[84036, 3799, 220, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[84259, 3811, 252, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[84514, 3823, 226, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[84743, 3835, 242, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[84988, 3847, 227, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[85218, 3859, 243, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[85464, 3871, 182, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[85649, 3881, 183, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[85835, 3891, 183, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[86021, 3901, 235, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[86259, 3913, 191, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[86453, 3923, 230, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[86686, 3933, 226, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[86915, 3943, 200, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[87118, 3953, 243, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[87364, 3965, 228, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[87595, 3977, 235, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[87833, 3989, 232, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[88068, 4001, 206, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[88277, 4011, 207, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[88487, 4021, 242, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[88732, 4033, 248, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[88983, 4045, 210, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[89196, 4055, 242, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[89441, 4067, 249, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[89693, 4079, 248, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[89944, 4091, 250, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[90197, 4103, 215, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[90415, 4115, 235, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[90653, 4127, 232, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[90888, 4137, 263, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[91154, 4149, 244, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[91401, 4161, 196, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[91600, 4171, 209, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[91812, 4181, 206, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[92021, 4191, 225, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[92249, 4201, 228, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[92480, 4213, 222, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[92705, 4223, 219, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[92927, 4233, 206, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[93136, 4245, 218, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[93357, 4257, 242, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[93602, 4269, 236, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[93841, 4281, 231, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[94075, 4293, 220, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[94298, 4303, 253, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[94554, 4315, 257, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[94814, 4327, 237, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[95054, 4339, 249, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[95306, 4351, 222, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[95531, 4363, 237, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[95771, 4375, 249, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[96023, 4387, 223, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[96249, 4397, 264, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[96516, 4409, 256, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[96775, 4421, 205, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[96983, 4431, 201, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[97187, 4441, 218, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[97408, 4451, 253, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[97664, 4463, 242, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[97909, 4475, 254, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[98166, 4487, 237, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[98406, 4499, 246, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[98655, 4511, 182, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[98840, 4521, 218, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[99061, 4531, 213, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[99277, 4541, 213, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[99493, 4551, 210, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[99706, 4561, 240, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[99949, 4573, 273, 10, 29, "Index",
   CellTags->"alpha"],
  Cell[100225, 4585, 241, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[100469, 4597, 270, 10, 29, "Index",
   CellTags->"alpha"],
  Cell[100742, 4609, 217, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[100962, 4619, 269, 10, 29, "Index",
   CellTags->"alpha"],
  Cell[101234, 4631, 212, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[101449, 4643, 208, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[101660, 4653, 227, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[101890, 4665, 192, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[102085, 4675, 214, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[102302, 4687, 228, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[102533, 4697, 255, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[102791, 4709, 251, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[103045, 4721, 240, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[103288, 4733, 255, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[103546, 4745, 213, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[103762, 4755, 217, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[103982, 4767, 204, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[104189, 4777, 218, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[104410, 4787, 228, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[104641, 4799, 241, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[104885, 4811, 242, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[105130, 4823, 237, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[105370, 4835, 229, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[105602, 4847, 216, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[105821, 4857, 219, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[106043, 4867, 219, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[106265, 4879, 257, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[106525, 4891, 239, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[106767, 4903, 220, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[106990, 4913, 250, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[107243, 4925, 215, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[107461, 4935, 216, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[107680, 4945, 215, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[107898, 4955, 222, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[108123, 4965, 258, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[108384, 4977, 227, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[108614, 4989, 232, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[108849, 5001, 243, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[109095, 5013, 265, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[109363, 5025, 216, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[109582, 5035, 208, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[109793, 5045, 234, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[110030, 5057, 222, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[110255, 5069, 215, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[110473, 5079, 233, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[110709, 5089, 267, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[110979, 5101, 210, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[111192, 5111, 251, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[111446, 5121, 210, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[111659, 5131, 215, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[111877, 5141, 216, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[112096, 5151, 221, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[112320, 5161, 223, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[112546, 5171, 206, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[112755, 5181, 235, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[112993, 5193, 241, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[113237, 5203, 190, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[113430, 5213, 239, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[113672, 5225, 207, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[113882, 5235, 232, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[114117, 5247, 250, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[114370, 5259, 186, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[114559, 5269, 204, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[114766, 5279, 205, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[114974, 5289, 201, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[115178, 5299, 207, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[115388, 5309, 254, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[115645, 5321, 203, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[115851, 5331, 214, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[116068, 5341, 188, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[116259, 5351, 298, 10, 29, "Index",
   CellTags->"alpha"],
  Cell[116560, 5363, 248, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[116811, 5375, 245, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[117059, 5387, 204, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[117266, 5397, 200, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[117469, 5407, 198, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[117670, 5417, 200, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[117873, 5427, 195, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[118071, 5437, 264, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[118338, 5449, 217, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[118558, 5461, 207, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[118768, 5471, 258, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[119029, 5483, 276, 10, 29, "Index",
   CellTags->"alpha"],
  Cell[119308, 5495, 250, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[119561, 5507, 256, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[119820, 5519, 240, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[120063, 5531, 241, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[120307, 5543, 246, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[120556, 5555, 240, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[120799, 5567, 238, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[121040, 5579, 257, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[121300, 5591, 241, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[121544, 5603, 242, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[121789, 5615, 247, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[122039, 5627, 241, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[122283, 5639, 239, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[122525, 5651, 248, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[122776, 5663, 236, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[123015, 5675, 250, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[123268, 5685, 200, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[123471, 5695, 257, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[123731, 5707, 205, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[123939, 5717, 227, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[124169, 5727, 256, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[124428, 5739, 235, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[124666, 5749, 232, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[124901, 5759, 249, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[125153, 5771, 237, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[125393, 5783, 258, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[125654, 5795, 214, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[125871, 5805, 266, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[126140, 5817, 264, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[126407, 5829, 224, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[126634, 5841, 241, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[126878, 5853, 254, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[127135, 5865, 227, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[127365, 5877, 220, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[127588, 5889, 228, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[127819, 5901, 221, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[128043, 5913, 249, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[128295, 5925, 203, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[128501, 5935, 202, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[128706, 5945, 201, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[128910, 5955, 205, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[129118, 5965, 410, 14, 30, "Index",
   CellTags->"alpha"],
  Cell[129531, 5981, 254, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[129788, 5993, 268, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[130059, 6005, 252, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[130314, 6017, 183, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[130500, 6027, 271, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[130774, 6039, 233, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[131010, 6051, 209, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[131222, 6061, 226, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[131451, 6073, 180, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[131634, 6083, 269, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[131906, 6095, 248, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[132157, 6107, 259, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[132419, 6119, 249, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[132671, 6131, 237, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[132911, 6143, 258, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[133172, 6155, 249, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[133424, 6167, 229, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[133656, 6177, 199, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[133858, 6187, 253, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[134114, 6199, 252, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[134369, 6211, 259, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[134631, 6223, 247, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[134881, 6235, 265, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[135149, 6247, 249, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[135401, 6259, 262, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[135666, 6271, 199, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[135868, 6281, 235, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[136106, 6293, 194, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[136303, 6303, 232, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[136538, 6315, 217, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[136758, 6327, 207, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[136968, 6337, 247, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[137218, 6347, 207, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[137428, 6357, 240, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[137671, 6367, 227, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[137901, 6379, 228, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[138132, 6391, 232, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[138367, 6403, 212, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[138582, 6413, 233, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[138818, 6425, 239, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[139060, 6437, 254, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[139317, 6449, 243, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[139563, 6461, 229, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[139795, 6471, 217, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[140015, 6483, 226, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[140244, 6495, 242, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[140489, 6507, 196, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[140688, 6517, 256, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[140947, 6529, 212, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[141162, 6541, 211, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[141376, 6551, 200, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[141579, 6561, 205, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[141787, 6571, 209, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[141999, 6581, 214, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[142216, 6593, 253, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[142472, 6605, 227, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[142702, 6617, 260, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[142965, 6629, 273, 10, 15, "Index",
   CellTags->{"StyleBox[Indeterminate, MR]", "alpha"}],
  Cell[143241, 6641, 187, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[143431, 6651, 215, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[143649, 6661, 190, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[143842, 6671, 214, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[144059, 6683, 193, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[144255, 6693, 185, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[144443, 6703, 183, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[144629, 6713, 188, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[144820, 6723, 181, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[145004, 6733, 211, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[145218, 6745, 205, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[145426, 6757, 182, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[145611, 6767, 186, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[145800, 6777, 200, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[146003, 6787, 200, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[146206, 6797, 198, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[146407, 6807, 257, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[146667, 6819, 230, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[146900, 6829, 248, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[147151, 6841, 243, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[147397, 6853, 194, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[147594, 6863, 191, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[147788, 6873, 229, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[148020, 6885, 226, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[148249, 6897, 209, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[148461, 6907, 175, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[148639, 6917, 248, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[148890, 6929, 240, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[149133, 6941, 221, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[149357, 6951, 217, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[149577, 6961, 237, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[149817, 6973, 249, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[150069, 6985, 257, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[150329, 6997, 229, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[150561, 7007, 227, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[150791, 7017, 216, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[151010, 7029, 224, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[151237, 7041, 271, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[151511, 7053, 268, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[151782, 7065, 272, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[152057, 7077, 202, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[152262, 7087, 245, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[152510, 7099, 248, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[152761, 7111, 237, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[153001, 7123, 210, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[153214, 7133, 248, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[153465, 7145, 249, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[153717, 7157, 234, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[153954, 7169, 238, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[154195, 7181, 226, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[154424, 7193, 242, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[154669, 7205, 227, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[154899, 7217, 243, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[155145, 7229, 264, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[155412, 7241, 220, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[155635, 7251, 264, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[155902, 7263, 228, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[156133, 7275, 229, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[156365, 7287, 214, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[156582, 7297, 225, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[156810, 7307, 228, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[157041, 7319, 230, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[157274, 7331, 227, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[157504, 7343, 217, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[157724, 7355, 269, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[157996, 7367, 253, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[158252, 7379, 242, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[158497, 7391, 254, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[158754, 7403, 249, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[159006, 7415, 248, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[159257, 7427, 204, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[159464, 7437, 198, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[159665, 7447, 202, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[159870, 7457, 199, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[160072, 7467, 189, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[160264, 7477, 189, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[160456, 7487, 205, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[160664, 7497, 205, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[160872, 7507, 214, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[161089, 7517, 214, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[161306, 7527, 194, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[161503, 7537, 198, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[161704, 7547, 247, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[161954, 7559, 236, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[162193, 7571, 248, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[162444, 7583, 217, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[162664, 7593, 255, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[162922, 7605, 244, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[163169, 7617, 217, 8, 15, "Index",
   CellTags->"alpha"],
  Cell[163389, 7627, 221, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[163613, 7639, 245, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[163861, 7651, 261, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[164125, 7663, 265, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[164393, 7675, 230, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[164626, 7687, 248, 8, 15, "Index",
   CellTags->{"Z[n, I]", "alpha"}],
  Cell[164877, 7697, 248, 8, 15, "Index",
   CellTags->{"Z[n, k]", "alpha"}],
  Cell[165128, 7707, 368, 14, 29, "Index",
   CellTags->"alpha"],
  Cell[165499, 7723, 264, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[165766, 7735, 216, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[165985, 7747, 251, 10, 15, "Index",
   CellTags->"alpha"],
  Cell[166239, 7759, 265, 10, 15, "Index",
   CellTags->"alpha"]},
 "i:4"->{
  Cell[17245, 555, 108, 2, 56, "Subsection",
   CellTags->{"alpha", "i:4"}]},
 "StyleBox[Indeterminate, MR]"->{
  Cell[142965, 6629, 273, 10, 15, "Index",
   CellTags->{"StyleBox[Indeterminate, MR]", "alpha"}]},
 "Z[n, I]"->{
  Cell[164626, 7687, 248, 8, 15, "Index",
   CellTags->{"Z[n, I]", "alpha"}]},
 "Z[n, k]"->{
  Cell[164877, 7697, 248, 8, 15, "Index",
   CellTags->{"Z[n, k]", "alpha"}]},
 "pack"->{
  Cell[166541, 7774, 104, 2, 36, "Subsection",
   CellTags->{"pack", "i:5"}],
  Cell[166648, 7778, 718, 16, 67, "Text",
   CellTags->{
    "pack", "Core", "FiniteFields", "Groupoids", "GroupProperties", "Joint", 
     "LabCode", "Morphisms", "RingExtensions", "Ringoids", "RingProperties", 
     "Zd"}],
  Cell[167391, 7798, 73, 1, 34, "Subsubsection",
   CellTags->{"Core", "i:7", "pack"}],
  Cell[167467, 7801, 1819, 29, 386, "Text",
   InitializationCell->False,
   CellTags->{"Core", "pack"}],
  Cell[169323, 7835, 89, 1, 34, "Subsubsection",
   CellTags->{"FiniteFields", "i:8", "pack"}],
  Cell[169415, 7838, 347, 8, 64, "Text",
   InitializationCell->False,
   CellTags->{"FiniteFields", "pack"}],
  Cell[169799, 7851, 83, 1, 34, "Subsubsection",
   CellTags->{"Groupoids", "i:9", "pack"}],
  Cell[169885, 7854, 483, 10, 92, "Text",
   InitializationCell->False,
   CellTags->{"Groupoids", "pack"}],
  Cell[170405, 7869, 96, 1, 34, "Subsubsection",
   CellTags->{"GroupProperties", "i:10", "pack"}],
  Cell[170504, 7872, 501, 10, 92, "Text",
   InitializationCell->False,
   CellTags->{"GroupProperties", "pack"}],
  Cell[171042, 7887, 76, 1, 34, "Subsubsection",
   CellTags->{"Joint", "i:11", "pack"}],
  Cell[171121, 7890, 438, 9, 78, "Text",
   InitializationCell->False,
   CellTags->{"Joint", "pack"}],
  Cell[171596, 7904, 80, 1, 34, "Subsubsection",
   CellTags->{"LabCode", "i:12", "pack"}],
  Cell[171679, 7907, 264, 7, 50, "Text",
   InitializationCell->False,
   CellTags->{"LabCode", "pack"}],
  Cell[171980, 7919, 82, 1, 34, "Subsubsection",
   CellTags->{"Matrices", "i:13", "pack"}],
  Cell[172065, 7922, 664, 12, 134, "Text",
   InitializationCell->False,
   CellTags->{"Matrices", "pack"}],
  Cell[172766, 7939, 84, 1, 34, "Subsubsection",
   CellTags->{"Morphisms", "i:14", "pack"}],
  Cell[172853, 7942, 736, 14, 148, "Text",
   InitializationCell->False,
   CellTags->{"Morphisms", "pack"}],
  Cell[173626, 7961, 90, 1, 34, "Subsubsection",
   CellTags->{"Permutations", "i:15", "pack"}],
  Cell[173719, 7964, 676, 13, 134, "Text",
   InitializationCell->False,
   CellTags->{"Permutations", "pack"}],
  Cell[174432, 7982, 95, 1, 34, "Subsubsection",
   CellTags->{"RingExtensions", "i:16", "pack"}],
  Cell[174530, 7985, 523, 11, 92, "Text",
   InitializationCell->False,
   CellTags->{"RingExtensions", "pack"}],
  Cell[175090, 8001, 83, 1, 34, "Subsubsection",
   CellTags->{"Ringoids", "i:17", "pack"}],
  Cell[175176, 8004, 188, 4, 22, "Text",
   InitializationCell->False,
   CellTags->{"Ringoids", "pack"}],
  Cell[175401, 8013, 95, 1, 34, "Subsubsection",
   CellTags->{"RingProperties", "i:18", "pack"}],
  Cell[175499, 8016, 1033, 17, 188, "Text",
   InitializationCell->False,
   CellTags->{"RingProperties", "pack"}],
  Cell[176569, 8038, 71, 1, 34, "Subsubsection",
   CellTags->{"Zd", "i:19", "pack"}],
  Cell[176643, 8041, 429, 9, 83, "Text",
   InitializationCell->False,
   CellTags->{"Zd", "pack"}]},
 "i:5"->{
  Cell[166541, 7774, 104, 2, 36, "Subsection",
   CellTags->{"pack", "i:5"}]},
 "Core"->{
  Cell[166648, 7778, 718, 16, 67, "Text",
   CellTags->{
    "pack", "Core", "FiniteFields", "Groupoids", "GroupProperties", "Joint", 
     "LabCode", "Morphisms", "RingExtensions", "Ringoids", "RingProperties", 
     "Zd"}],
  Cell[167391, 7798, 73, 1, 34, "Subsubsection",
   CellTags->{"Core", "i:7", "pack"}],
  Cell[167467, 7801, 1819, 29, 386, "Text",
   InitializationCell->False,
   CellTags->{"Core", "pack"}]},
 "FiniteFields"->{
  Cell[166648, 7778, 718, 16, 67, "Text",
   CellTags->{
    "pack", "Core", "FiniteFields", "Groupoids", "GroupProperties", "Joint", 
     "LabCode", "Morphisms", "RingExtensions", "Ringoids", "RingProperties", 
     "Zd"}],
  Cell[169323, 7835, 89, 1, 34, "Subsubsection",
   CellTags->{"FiniteFields", "i:8", "pack"}],
  Cell[169415, 7838, 347, 8, 64, "Text",
   InitializationCell->False,
   CellTags->{"FiniteFields", "pack"}]},
 "Groupoids"->{
  Cell[166648, 7778, 718, 16, 67, "Text",
   CellTags->{
    "pack", "Core", "FiniteFields", "Groupoids", "GroupProperties", "Joint", 
     "LabCode", "Morphisms", "RingExtensions", "Ringoids", "RingProperties", 
     "Zd"}],
  Cell[169799, 7851, 83, 1, 34, "Subsubsection",
   CellTags->{"Groupoids", "i:9", "pack"}],
  Cell[169885, 7854, 483, 10, 92, "Text",
   InitializationCell->False,
   CellTags->{"Groupoids", "pack"}]},
 "GroupProperties"->{
  Cell[166648, 7778, 718, 16, 67, "Text",
   CellTags->{
    "pack", "Core", "FiniteFields", "Groupoids", "GroupProperties", "Joint", 
     "LabCode", "Morphisms", "RingExtensions", "Ringoids", "RingProperties", 
     "Zd"}],
  Cell[170405, 7869, 96, 1, 34, "Subsubsection",
   CellTags->{"GroupProperties", "i:10", "pack"}],
  Cell[170504, 7872, 501, 10, 92, "Text",
   InitializationCell->False,
   CellTags->{"GroupProperties", "pack"}]},
 "Joint"->{
  Cell[166648, 7778, 718, 16, 67, "Text",
   CellTags->{
    "pack", "Core", "FiniteFields", "Groupoids", "GroupProperties", "Joint", 
     "LabCode", "Morphisms", "RingExtensions", "Ringoids", "RingProperties", 
     "Zd"}],
  Cell[171042, 7887, 76, 1, 34, "Subsubsection",
   CellTags->{"Joint", "i:11", "pack"}],
  Cell[171121, 7890, 438, 9, 78, "Text",
   InitializationCell->False,
   CellTags->{"Joint", "pack"}]},
 "LabCode"->{
  Cell[166648, 7778, 718, 16, 67, "Text",
   CellTags->{
    "pack", "Core", "FiniteFields", "Groupoids", "GroupProperties", "Joint", 
     "LabCode", "Morphisms", "RingExtensions", "Ringoids", "RingProperties", 
     "Zd"}],
  Cell[171596, 7904, 80, 1, 34, "Subsubsection",
   CellTags->{"LabCode", "i:12", "pack"}],
  Cell[171679, 7907, 264, 7, 50, "Text",
   InitializationCell->False,
   CellTags->{"LabCode", "pack"}]},
 "Morphisms"->{
  Cell[166648, 7778, 718, 16, 67, "Text",
   CellTags->{
    "pack", "Core", "FiniteFields", "Groupoids", "GroupProperties", "Joint", 
     "LabCode", "Morphisms", "RingExtensions", "Ringoids", "RingProperties", 
     "Zd"}],
  Cell[172766, 7939, 84, 1, 34, "Subsubsection",
   CellTags->{"Morphisms", "i:14", "pack"}],
  Cell[172853, 7942, 736, 14, 148, "Text",
   InitializationCell->False,
   CellTags->{"Morphisms", "pack"}]},
 "RingExtensions"->{
  Cell[166648, 7778, 718, 16, 67, "Text",
   CellTags->{
    "pack", "Core", "FiniteFields", "Groupoids", "GroupProperties", "Joint", 
     "LabCode", "Morphisms", "RingExtensions", "Ringoids", "RingProperties", 
     "Zd"}],
  Cell[174432, 7982, 95, 1, 34, "Subsubsection",
   CellTags->{"RingExtensions", "i:16", "pack"}],
  Cell[174530, 7985, 523, 11, 92, "Text",
   InitializationCell->False,
   CellTags->{"RingExtensions", "pack"}]},
 "Ringoids"->{
  Cell[166648, 7778, 718, 16, 67, "Text",
   CellTags->{
    "pack", "Core", "FiniteFields", "Groupoids", "GroupProperties", "Joint", 
     "LabCode", "Morphisms", "RingExtensions", "Ringoids", "RingProperties", 
     "Zd"}],
  Cell[175090, 8001, 83, 1, 34, "Subsubsection",
   CellTags->{"Ringoids", "i:17", "pack"}],
  Cell[175176, 8004, 188, 4, 22, "Text",
   InitializationCell->False,
   CellTags->{"Ringoids", "pack"}]},
 "RingProperties"->{
  Cell[166648, 7778, 718, 16, 67, "Text",
   CellTags->{
    "pack", "Core", "FiniteFields", "Groupoids", "GroupProperties", "Joint", 
     "LabCode", "Morphisms", "RingExtensions", "Ringoids", "RingProperties", 
     "Zd"}],
  Cell[175401, 8013, 95, 1, 34, "Subsubsection",
   CellTags->{"RingProperties", "i:18", "pack"}],
  Cell[175499, 8016, 1033, 17, 188, "Text",
   InitializationCell->False,
   CellTags->{"RingProperties", "pack"}]},
 "Zd"->{
  Cell[166648, 7778, 718, 16, 67, "Text",
   CellTags->{
    "pack", "Core", "FiniteFields", "Groupoids", "GroupProperties", "Joint", 
     "LabCode", "Morphisms", "RingExtensions", "Ringoids", "RingProperties", 
     "Zd"}],
  Cell[176569, 8038, 71, 1, 34, "Subsubsection",
   CellTags->{"Zd", "i:19", "pack"}],
  Cell[176643, 8041, 429, 9, 83, "Text",
   InitializationCell->False,
   CellTags->{"Zd", "pack"}]},
 "i:7"->{
  Cell[167391, 7798, 73, 1, 34, "Subsubsection",
   CellTags->{"Core", "i:7", "pack"}]},
 "i:8"->{
  Cell[169323, 7835, 89, 1, 34, "Subsubsection",
   CellTags->{"FiniteFields", "i:8", "pack"}]},
 "i:9"->{
  Cell[169799, 7851, 83, 1, 34, "Subsubsection",
   CellTags->{"Groupoids", "i:9", "pack"}]},
 "i:10"->{
  Cell[170405, 7869, 96, 1, 34, "Subsubsection",
   CellTags->{"GroupProperties", "i:10", "pack"}]},
 "i:11"->{
  Cell[171042, 7887, 76, 1, 34, "Subsubsection",
   CellTags->{"Joint", "i:11", "pack"}]},
 "i:12"->{
  Cell[171596, 7904, 80, 1, 34, "Subsubsection",
   CellTags->{"LabCode", "i:12", "pack"}]},
 "Matrices"->{
  Cell[171980, 7919, 82, 1, 34, "Subsubsection",
   CellTags->{"Matrices", "i:13", "pack"}],
  Cell[172065, 7922, 664, 12, 134, "Text",
   InitializationCell->False,
   CellTags->{"Matrices", "pack"}]},
 "i:13"->{
  Cell[171980, 7919, 82, 1, 34, "Subsubsection",
   CellTags->{"Matrices", "i:13", "pack"}]},
 "i:14"->{
  Cell[172766, 7939, 84, 1, 34, "Subsubsection",
   CellTags->{"Morphisms", "i:14", "pack"}]},
 "Permutations"->{
  Cell[173626, 7961, 90, 1, 34, "Subsubsection",
   CellTags->{"Permutations", "i:15", "pack"}],
  Cell[173719, 7964, 676, 13, 134, "Text",
   InitializationCell->False,
   CellTags->{"Permutations", "pack"}]},
 "i:15"->{
  Cell[173626, 7961, 90, 1, 34, "Subsubsection",
   CellTags->{"Permutations", "i:15", "pack"}]},
 "i:16"->{
  Cell[174432, 7982, 95, 1, 34, "Subsubsection",
   CellTags->{"RingExtensions", "i:16", "pack"}]},
 "i:17"->{
  Cell[175090, 8001, 83, 1, 34, "Subsubsection",
   CellTags->{"Ringoids", "i:17", "pack"}]},
 "i:18"->{
  Cell[175401, 8013, 95, 1, 34, "Subsubsection",
   CellTags->{"RingProperties", "i:18", "pack"}]},
 "i:19"->{
  Cell[176569, 8038, 71, 1, 34, "Subsubsection",
   CellTags->{"Zd", "i:19", "pack"}]},
 "ext"->{
  Cell[177121, 8056, 184, 8, 64, "Subsection",
   CellTags->{"ext", "i:20"}],
  Cell[177308, 8066, 388, 7, 83, "Text",
   CellTags->"ext"]},
 "i:20"->{
  Cell[177121, 8056, 184, 8, 64, "Subsection",
   CellTags->{"ext", "i:20"}]},
 "usagealpha"->{
  Cell[177733, 8078, 116, 2, 64, "Subsection",
   CellTags->{"usagealpha", "i:22"}],
  Cell[177852, 8082, 126532, 2404, 13400, "Input",
   CellTags->"usagealpha"]},
 "i:22"->{
  Cell[177733, 8078, 116, 2, 64, "Subsection",
   CellTags->{"usagealpha", "i:22"}]},
 "usagepackages"->{
  Cell[304421, 10491, 116, 2, 64, "Subsection",
   CellTags->{"usagepackages", "i:23"}],
  Cell[304562, 10497, 80, 1, 56, "Subsubsection",
   CellTags->{"CoreUsage", "usagepackages"}],
  Cell[304645, 10500, 40973, 743, 3494, "Input",
   InitializationCell->True,
   CellTags->{"CoreUsage", "usagepackages"}],
  Cell[345655, 11248, 96, 1, 56, "Subsubsection",
   CellTags->{"FiniteFieldsUsage", "usagepackages"}],
  Cell[345754, 11251, 3032, 57, 296, "Input",
   InitializationCell->True,
   CellTags->{"FiniteFieldsUsage", "usagepackages"}],
  Cell[348823, 11313, 90, 1, 56, "Subsubsection",
   CellTags->{"GroupoidsUsage", "usagepackages"}],
  Cell[348916, 11316, 6745, 133, 868, "Input",
   InitializationCell->True,
   CellTags->{"GroupoidsUsage", "usagepackages"}],
  Cell[355698, 11454, 102, 1, 56, "Subsubsection",
   CellTags->{"GroupPropertiesUsage", "usagepackages"}],
  Cell[355803, 11457, 3891, 89, 660, "Input",
   InitializationCell->True,
   CellTags->{"GroupPropertiesUsage", "usagepackages"}],
  Cell[359731, 11551, 82, 1, 56, "Subsubsection",
   CellTags->{"JointUsage", "usagepackages"}],
  Cell[359816, 11554, 6286, 117, 634, "Input",
   InitializationCell->True,
   CellTags->{"JointUsage", "usagepackages"}],
  Cell[366139, 11676, 86, 1, 56, "Subsubsection",
   CellTags->{"LabCodeUsage", "usagepackages"}],
  Cell[366228, 11679, 5379, 117, 894, "Input",
   InitializationCell->True,
   CellTags->{"LabCodeUsage", "usagepackages"}],
  Cell[371644, 11801, 88, 1, 56, "Subsubsection",
   CellTags->{"MatricesUsage", "usagepackages"}],
  Cell[371735, 11804, 9316, 189, 1206, "Input",
   InitializationCell->True,
   CellTags->{"MatricesUsage", "usagepackages"}],
  Cell[381088, 11998, 90, 1, 56, "Subsubsection",
   CellTags->{"MorphismsUsage", "usagepackages"}],
  Cell[381181, 12001, 10422, 197, 1154, "Input",
   InitializationCell->True,
   CellTags->{"MorphismsUsage", "usagepackages"}],
  Cell[391640, 12203, 96, 1, 56, "Subsubsection",
   CellTags->{"PermutationsUsage", "usagepackages"}],
  Cell[391739, 12206, 11017, 204, 1050, "Input",
   InitializationCell->True,
   CellTags->{"PermutationsUsage", "usagepackages"}],
  Cell[402793, 12415, 101, 1, 56, "Subsubsection",
   CellTags->{"RingExtensionsUsage", "usagepackages"}],
  Cell[402897, 12418, 13401, 236, 1024, "Input",
   InitializationCell->True,
   CellTags->{"RingExtensionsUsage", "usagepackages"}],
  Cell[416335, 12659, 89, 1, 56, "Subsubsection",
   CellTags->{"RingoidsUsage", "usagepackages"}],
  Cell[416427, 12662, 1146, 22, 114, "Input",
   InitializationCell->True,
   CellTags->{"RingoidsUsage", "usagepackages"}],
  Cell[417610, 12689, 101, 1, 56, "Subsubsection",
   CellTags->{"RingPropertiesUsage", "usagepackages"}],
  Cell[417714, 12692, 12327, 256, 1648, "Input",
   InitializationCell->True,
   CellTags->{"RingPropertiesUsage", "usagepackages"}],
  Cell[430078, 12953, 77, 1, 56, "Subsubsection",
   CellTags->{"ZdUsage", "usagepackages"}],
  Cell[430158, 12956, 5538, 107, 582, "Input",
   InitializationCell->True,
   CellTags->{"ZdUsage", "usagepackages"}]},
 "i:23"->{
  Cell[304421, 10491, 116, 2, 64, "Subsection",
   CellTags->{"usagepackages", "i:23"}]},
 "CoreUsage"->{
  Cell[304562, 10497, 80, 1, 56, "Subsubsection",
   CellTags->{"CoreUsage", "usagepackages"}],
  Cell[304645, 10500, 40973, 743, 3494, "Input",
   InitializationCell->True,
   CellTags->{"CoreUsage", "usagepackages"}]},
 "FiniteFieldsUsage"->{
  Cell[345655, 11248, 96, 1, 56, "Subsubsection",
   CellTags->{"FiniteFieldsUsage", "usagepackages"}],
  Cell[345754, 11251, 3032, 57, 296, "Input",
   InitializationCell->True,
   CellTags->{"FiniteFieldsUsage", "usagepackages"}]},
 "GroupoidsUsage"->{
  Cell[348823, 11313, 90, 1, 56, "Subsubsection",
   CellTags->{"GroupoidsUsage", "usagepackages"}],
  Cell[348916, 11316, 6745, 133, 868, "Input",
   InitializationCell->True,
   CellTags->{"GroupoidsUsage", "usagepackages"}]},
 "GroupPropertiesUsage"->{
  Cell[355698, 11454, 102, 1, 56, "Subsubsection",
   CellTags->{"GroupPropertiesUsage", "usagepackages"}],
  Cell[355803, 11457, 3891, 89, 660, "Input",
   InitializationCell->True,
   CellTags->{"GroupPropertiesUsage", "usagepackages"}]},
 "JointUsage"->{
  Cell[359731, 11551, 82, 1, 56, "Subsubsection",
   CellTags->{"JointUsage", "usagepackages"}],
  Cell[359816, 11554, 6286, 117, 634, "Input",
   InitializationCell->True,
   CellTags->{"JointUsage", "usagepackages"}]},
 "LabCodeUsage"->{
  Cell[366139, 11676, 86, 1, 56, "Subsubsection",
   CellTags->{"LabCodeUsage", "usagepackages"}],
  Cell[366228, 11679, 5379, 117, 894, "Input",
   InitializationCell->True,
   CellTags->{"LabCodeUsage", "usagepackages"}]},
 "MatricesUsage"->{
  Cell[371644, 11801, 88, 1, 56, "Subsubsection",
   CellTags->{"MatricesUsage", "usagepackages"}],
  Cell[371735, 11804, 9316, 189, 1206, "Input",
   InitializationCell->True,
   CellTags->{"MatricesUsage", "usagepackages"}]},
 "MorphismsUsage"->{
  Cell[381088, 11998, 90, 1, 56, "Subsubsection",
   CellTags->{"MorphismsUsage", "usagepackages"}],
  Cell[381181, 12001, 10422, 197, 1154, "Input",
   InitializationCell->True,
   CellTags->{"MorphismsUsage", "usagepackages"}]},
 "PermutationsUsage"->{
  Cell[391640, 12203, 96, 1, 56, "Subsubsection",
   CellTags->{"PermutationsUsage", "usagepackages"}],
  Cell[391739, 12206, 11017, 204, 1050, "Input",
   InitializationCell->True,
   CellTags->{"PermutationsUsage", "usagepackages"}]},
 "RingExtensionsUsage"->{
  Cell[402793, 12415, 101, 1, 56, "Subsubsection",
   CellTags->{"RingExtensionsUsage", "usagepackages"}],
  Cell[402897, 12418, 13401, 236, 1024, "Input",
   InitializationCell->True,
   CellTags->{"RingExtensionsUsage", "usagepackages"}]},
 "RingoidsUsage"->{
  Cell[416335, 12659, 89, 1, 56, "Subsubsection",
   CellTags->{"RingoidsUsage", "usagepackages"}],
  Cell[416427, 12662, 1146, 22, 114, "Input",
   InitializationCell->True,
   CellTags->{"RingoidsUsage", "usagepackages"}]},
 "RingPropertiesUsage"->{
  Cell[417610, 12689, 101, 1, 56, "Subsubsection",
   CellTags->{"RingPropertiesUsage", "usagepackages"}],
  Cell[417714, 12692, 12327, 256, 1648, "Input",
   InitializationCell->True,
   CellTags->{"RingPropertiesUsage", "usagepackages"}]},
 "ZdUsage"->{
  Cell[430078, 12953, 77, 1, 56, "Subsubsection",
   CellTags->{"ZdUsage", "usagepackages"}],
  Cell[430158, 12956, 5538, 107, 582, "Input",
   InitializationCell->True,
   CellTags->{"ZdUsage", "usagepackages"}]},
 "errormessages"->{
  Cell[435745, 13069, 92, 2, 64, "Subsection",
   CellTags->"errormessages"],
  Cell[435840, 13073, 14111, 358, 3156, "Input",
   CellTags->"errormessages"]},
 "Lab0"->{
  Cell[450000, 13437, 107, 3, 76, "Section",
   CellTags->{"Lab0", "i:21"}],
  Cell[450110, 13442, 1032, 31, 113, "Text",
   CellTags->"Lab0"]},
 "i:21"->{
  Cell[450000, 13437, 107, 3, 76, "Section",
   CellTags->{"Lab0", "i:21"}]}
 }
*)
(*CellTagsIndex
CellTagsIndex->{
 {"i:1", 453406, 13524},
 {"install2w", 453499, 13527},
 {"install2o", 453791, 13536},
 {"install3", 454010, 13543},
 {"installFromWeb", 454497, 13558},
 {"i:3", 454729, 13565},
 {"MathematicaRefs", 454836, 13568},
 {"alpha", 456158, 13605},
 {"i:4", 498027, 14892},
 {"StyleBox[Indeterminate, MR]", 498139, 14895},
 {"Z[n, I]", 498253, 14898},
 {"Z[n, k]", 498346, 14901},
 {"pack", 498436, 14904},
 {"i:5", 501393, 14977},
 {"Core", 501483, 14980},
 {"FiniteFields", 501923, 14991},
 {"Groupoids", 502373, 15002},
 {"GroupProperties", 502824, 15013},
 {"Joint", 503278, 15024},
 {"LabCode", 503713, 15035},
 {"Morphisms", 504154, 15046},
 {"RingExtensions", 504606, 15057},
 {"Ringoids", 505061, 15068},
 {"RingProperties", 505509, 15079},
 {"Zd", 505960, 15090},
 {"i:7", 506385, 15101},
 {"i:8", 506484, 15104},
 {"i:9", 506591, 15107},
 {"i:10", 506696, 15110},
 {"i:11", 506808, 15113},
 {"i:12", 506910, 15116},
 {"Matrices", 507018, 15119},
 {"i:13", 507232, 15125},
 {"i:14", 507337, 15128},
 {"Permutations", 507451, 15131},
 {"i:15", 507673, 15137},
 {"i:16", 507782, 15140},
 {"i:17", 507893, 15143},
 {"i:18", 507998, 15146},
 {"i:19", 508109, 15149},
 {"ext", 508207, 15152},
 {"i:20", 508359, 15157},
 {"usagealpha", 508455, 15160},
 {"i:22", 508631, 15165},
 {"usagepackages", 508737, 15168},
 {"i:23", 511817, 15236},
 {"CoreUsage", 511923, 15239},
 {"FiniteFieldsUsage", 512168, 15245},
 {"GroupoidsUsage", 512423, 15251},
 {"GroupPropertiesUsage", 512679, 15257},
 {"JointUsage", 512937, 15263},
 {"LabCodeUsage", 513177, 15269},
 {"MatricesUsage", 513422, 15275},
 {"MorphismsUsage", 513671, 15281},
 {"PermutationsUsage", 513926, 15287},
 {"RingExtensionsUsage", 514189, 15293},
 {"RingoidsUsage", 514451, 15299},
 {"RingPropertiesUsage", 514703, 15305},
 {"ZdUsage", 514959, 15311},
 {"errormessages", 515194, 15317},
 {"Lab0", 515364, 15322},
 {"i:21", 515520, 15327}
 }
*)
(*NotebookFileOutline
Notebook[{
Cell[568, 21, 781, 30, 81, "Subsubtitle",
 Evaluatable->False],
Cell[CellGroupData[{
Cell[1374, 55, 164, 5, 54, "Title"],
Cell[CellGroupData[{
Cell[1563, 64, 131, 3, 76, "Section",
 CellTags->{"i:1", "install2w"}],
Cell[CellGroupData[{
Cell[1719, 71, 99, 2, 64, "Subsection",
 CellTags->"install2w"],
Cell[1821, 75, 647, 19, 68, "Text",
 CellTags->"install2w"],
Cell[2471, 96, 702, 15, 98, "Text",
 CellTags->"install2w"]
}, Open  ]],
Cell[CellGroupData[{
Cell[3210, 116, 107, 2, 64, "Subsection",
 CellTags->"install2o"],
Cell[3320, 120, 579, 17, 68, "Text",
 CellTags->"install2o"],
Cell[3902, 139, 333, 10, 53, "Text",
 CellTags->"install2o"]
}, Open  ]],
Cell[CellGroupData[{
Cell[4272, 154, 94, 2, 68, "Subsection",
 CellTags->"install3"],
Cell[4369, 158, 773, 18, 106, "Text",
 CellTags->"install3"],
Cell[5145, 178, 302, 8, 59, "Text",
 CellTags->"install3"],
Cell[5450, 188, 599, 15, 112, "Text",
 CellTags->"install3"],
Cell[6052, 205, 864, 28, 335, "Text",
 CellTags->"install3"],
Cell[6919, 235, 1253, 26, 211, "Text",
 CellTags->"install3"],
Cell[8175, 263, 1363, 33, 197, "Text",
 CellTags->"install3"]
}, Open  ]],
Cell[CellGroupData[{
Cell[9575, 301, 83, 1, 68, "Subsection",
 CellTags->"installFromWeb"],
Cell[9661, 304, 2039, 49, 291, "Text",
 CellTags->"installFromWeb"],
Cell[11703, 355, 896, 17, 421, "Text",
 CellTags->"installFromWeb"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[12648, 378, 122, 3, 81, "Section",
 CellTags->{"i:3", "MathematicaRefs"}],
Cell[12773, 383, 307, 8, 51, "Text",
 CellTags->"MathematicaRefs"],
Cell[13083, 393, 271, 10, 35, "Text",
 CellTags->"MathematicaRefs"],
Cell[13357, 405, 251, 7, 51, "Text",
 CellTags->"MathematicaRefs"],
Cell[13611, 414, 249, 7, 51, "Text",
 CellTags->"MathematicaRefs"],
Cell[13863, 423, 223, 7, 35, "Text",
 CellTags->"MathematicaRefs"],
Cell[14089, 432, 243, 7, 35, "Text",
 CellTags->"MathematicaRefs"],
Cell[14335, 441, 244, 7, 51, "Text",
 CellTags->"MathematicaRefs"],
Cell[14582, 450, 309, 8, 51, "Text",
 CellTags->"MathematicaRefs"],
Cell[14894, 460, 233, 7, 35, "Text",
 CellTags->"MathematicaRefs"],
Cell[15130, 469, 241, 7, 35, "Text",
 CellTags->"MathematicaRefs"],
Cell[15374, 478, 220, 7, 35, "Text",
 CellTags->"MathematicaRefs"],
Cell[15597, 487, 214, 7, 35, "Text",
 CellTags->"MathematicaRefs"],
Cell[15814, 496, 244, 7, 23, "Text",
 CellTags->"MathematicaRefs"],
Cell[16061, 505, 228, 7, 23, "Text",
 CellTags->"MathematicaRefs"],
Cell[16292, 514, 287, 9, 39, "Text",
 CellTags->"MathematicaRefs"],
Cell[16582, 525, 247, 9, 23, "Text",
 CellTags->"MathematicaRefs"],
Cell[16832, 536, 252, 8, 39, "Text",
 CellTags->"MathematicaRefs"]
}, Open  ]],
Cell[CellGroupData[{
Cell[17121, 549, 99, 2, 69, "Section"],
Cell[CellGroupData[{
Cell[17245, 555, 108, 2, 56, "Subsection",
 CellTags->{"alpha", "i:4"}],
Cell[17356, 559, 206, 8, 15, "Index",
 CellTags->"alpha"],
Cell[17565, 569, 247, 10, 15, "Index",
 CellTags->"alpha"],
Cell[17815, 581, 251, 10, 15, "Index",
 CellTags->"alpha"],
Cell[18069, 593, 231, 10, 15, "Index",
 CellTags->"alpha"],
Cell[18303, 605, 243, 10, 15, "Index",
 CellTags->"alpha"],
Cell[18549, 617, 216, 10, 15, "Index",
 CellTags->"alpha"],
Cell[18768, 629, 243, 10, 15, "Index",
 CellTags->"alpha"],
Cell[19014, 641, 217, 8, 15, "Index",
 CellTags->"alpha"],
Cell[19234, 651, 205, 8, 15, "Index",
 CellTags->"alpha"],
Cell[19442, 661, 217, 10, 15, "Index",
 CellTags->"alpha"],
Cell[19662, 673, 210, 8, 15, "Index",
 CellTags->"alpha"],
Cell[19875, 683, 243, 10, 15, "Index",
 CellTags->"alpha"],
Cell[20121, 695, 216, 8, 15, "Index",
 CellTags->"alpha"],
Cell[20340, 705, 250, 10, 15, "Index",
 CellTags->"alpha"],
Cell[20593, 717, 245, 10, 15, "Index",
 CellTags->"alpha"],
Cell[20841, 729, 204, 8, 15, "Index",
 CellTags->"alpha"],
Cell[21048, 739, 213, 8, 15, "Index",
 CellTags->"alpha"],
Cell[21264, 749, 265, 10, 15, "Index",
 CellTags->"alpha"],
Cell[21532, 761, 233, 10, 15, "Index",
 CellTags->"alpha"],
Cell[21768, 773, 243, 10, 15, "Index",
 CellTags->"alpha"],
Cell[22014, 785, 248, 10, 15, "Index",
 CellTags->"alpha"],
Cell[22265, 797, 247, 10, 15, "Index",
 CellTags->"alpha"],
Cell[22515, 809, 253, 10, 15, "Index",
 CellTags->"alpha"],
Cell[22771, 821, 252, 10, 15, "Index",
 CellTags->"alpha"],
Cell[23026, 833, 270, 10, 15, "Index",
 CellTags->"alpha"],
Cell[23299, 845, 223, 10, 15, "Index",
 CellTags->"alpha"],
Cell[23525, 857, 223, 10, 15, "Index",
 CellTags->"alpha"],
Cell[23751, 869, 247, 10, 15, "Index",
 CellTags->"alpha"],
Cell[24001, 881, 235, 10, 15, "Index",
 CellTags->"alpha"],
Cell[24239, 893, 184, 8, 15, "Index",
 CellTags->"alpha"],
Cell[24426, 903, 193, 8, 15, "Index",
 CellTags->"alpha"],
Cell[24622, 913, 198, 8, 15, "Index",
 CellTags->"alpha"],
Cell[24823, 923, 194, 8, 15, "Index",
 CellTags->"alpha"],
Cell[25020, 933, 226, 8, 15, "Index",
 CellTags->"alpha"],
Cell[25249, 943, 247, 10, 15, "Index",
 CellTags->"alpha"],
Cell[25499, 955, 243, 10, 15, "Index",
 CellTags->"alpha"],
Cell[25745, 967, 222, 10, 15, "Index",
 CellTags->"alpha"],
Cell[25970, 979, 239, 10, 15, "Index",
 CellTags->"alpha"],
Cell[26212, 991, 229, 8, 15, "Index",
 CellTags->"alpha"],
Cell[26444, 1001, 259, 10, 15, "Index",
 CellTags->"alpha"],
Cell[26706, 1013, 207, 8, 15, "Index",
 CellTags->"alpha"],
Cell[26916, 1023, 240, 10, 15, "Index",
 CellTags->"alpha"],
Cell[27159, 1035, 230, 10, 15, "Index",
 CellTags->"alpha"],
Cell[27392, 1047, 228, 10, 15, "Index",
 CellTags->"alpha"],
Cell[27623, 1059, 225, 10, 15, "Index",
 CellTags->"alpha"],
Cell[27851, 1071, 211, 10, 15, "Index",
 CellTags->"alpha"],
Cell[28065, 1083, 192, 8, 15, "Index",
 CellTags->"alpha"],
Cell[28260, 1093, 239, 10, 15, "Index",
 CellTags->"alpha"],
Cell[28502, 1105, 230, 10, 15, "Index",
 CellTags->"alpha"],
Cell[28735, 1117, 225, 10, 15, "Index",
 CellTags->"alpha"],
Cell[28963, 1129, 226, 10, 15, "Index",
 CellTags->"alpha"],
Cell[29192, 1141, 204, 8, 15, "Index",
 CellTags->"alpha"],
Cell[29399, 1151, 209, 8, 15, "Index",
 CellTags->"alpha"],
Cell[29611, 1161, 241, 10, 15, "Index",
 CellTags->"alpha"],
Cell[29855, 1173, 202, 8, 15, "Index",
 CellTags->"alpha"],
Cell[30060, 1183, 202, 8, 15, "Index",
 CellTags->"alpha"],
Cell[30265, 1193, 241, 10, 15, "Index",
 CellTags->"alpha"],
Cell[30509, 1205, 248, 10, 15, "Index",
 CellTags->"alpha"],
Cell[30760, 1217, 265, 10, 15, "Index",
 CellTags->"alpha"],
Cell[31028, 1229, 232, 10, 15, "Index",
 CellTags->"alpha"],
Cell[31263, 1241, 260, 10, 15, "Index",
 CellTags->"alpha"],
Cell[31526, 1253, 203, 8, 15, "Index",
 CellTags->"alpha"],
Cell[31732, 1263, 200, 8, 15, "Index",
 CellTags->"alpha"],
Cell[31935, 1273, 179, 8, 15, "Index",
 CellTags->"alpha"],
Cell[32117, 1283, 239, 10, 15, "Index",
 CellTags->"alpha"],
Cell[32359, 1295, 266, 10, 15, "Index",
 CellTags->"alpha"],
Cell[32628, 1307, 270, 10, 15, "Index",
 CellTags->"alpha"],
Cell[32901, 1319, 238, 8, 15, "Index",
 CellTags->"alpha"],
Cell[33142, 1329, 255, 10, 15, "Index",
 CellTags->"alpha"],
Cell[33400, 1341, 253, 10, 15, "Index",
 CellTags->"alpha"],
Cell[33656, 1353, 234, 10, 15, "Index",
 CellTags->"alpha"],
Cell[33893, 1365, 252, 10, 15, "Index",
 CellTags->"alpha"],
Cell[34148, 1377, 245, 10, 15, "Index",
 CellTags->"alpha"],
Cell[34396, 1389, 270, 10, 15, "Index",
 CellTags->"alpha"],
Cell[34669, 1401, 233, 10, 15, "Index",
 CellTags->"alpha"],
Cell[34905, 1413, 234, 10, 15, "Index",
 CellTags->"alpha"],
Cell[35142, 1425, 216, 8, 15, "Index",
 CellTags->"alpha"],
Cell[35361, 1435, 207, 8, 15, "Index",
 CellTags->"alpha"],
Cell[35571, 1445, 187, 8, 15, "Index",
 CellTags->"alpha"],
Cell[35761, 1455, 235, 10, 15, "Index",
 CellTags->"alpha"],
Cell[35999, 1467, 212, 8, 15, "Index",
 CellTags->"alpha"],
Cell[36214, 1477, 232, 10, 15, "Index",
 CellTags->"alpha"],
Cell[36449, 1489, 207, 8, 15, "Index",
 CellTags->"alpha"],
Cell[36659, 1499, 249, 10, 15, "Index",
 CellTags->"alpha"],
Cell[36911, 1511, 245, 10, 15, "Index",
 CellTags->"alpha"],
Cell[37159, 1523, 247, 10, 15, "Index",
 CellTags->"alpha"],
Cell[37409, 1535, 228, 10, 15, "Index",
 CellTags->"alpha"],
Cell[37640, 1547, 210, 10, 15, "Index",
 CellTags->"alpha"],
Cell[37853, 1559, 173, 8, 15, "Index",
 CellTags->"alpha"],
Cell[38029, 1569, 221, 10, 15, "Index",
 CellTags->"alpha"],
Cell[38253, 1581, 215, 8, 15, "Index",
 CellTags->"alpha"],
Cell[38471, 1591, 253, 10, 15, "Index",
 CellTags->"alpha"],
Cell[38727, 1603, 206, 8, 15, "Index",
 CellTags->"alpha"],
Cell[38936, 1613, 188, 8, 15, "Index",
 CellTags->"alpha"],
Cell[39127, 1623, 248, 10, 15, "Index",
 CellTags->"alpha"],
Cell[39378, 1635, 230, 10, 15, "Index",
 CellTags->"alpha"],
Cell[39611, 1647, 222, 8, 15, "Index",
 CellTags->"alpha"],
Cell[39836, 1657, 226, 8, 15, "Index",
 CellTags->"alpha"],
Cell[40065, 1667, 254, 10, 15, "Index",
 CellTags->"alpha"],
Cell[40322, 1679, 261, 10, 15, "Index",
 CellTags->"alpha"],
Cell[40586, 1691, 226, 10, 15, "Index",
 CellTags->"alpha"],
Cell[40815, 1703, 228, 10, 15, "Index",
 CellTags->"alpha"],
Cell[41046, 1715, 244, 10, 15, "Index",
 CellTags->"alpha"],
Cell[41293, 1727, 203, 8, 15, "Index",
 CellTags->"alpha"],
Cell[41499, 1737, 198, 8, 15, "Index",
 CellTags->"alpha"],
Cell[41700, 1747, 255, 10, 15, "Index",
 CellTags->"alpha"],
Cell[41958, 1759, 250, 10, 15, "Index",
 CellTags->"alpha"],
Cell[42211, 1771, 229, 10, 15, "Index",
 CellTags->"alpha"],
Cell[42443, 1783, 249, 10, 15, "Index",
 CellTags->"alpha"],
Cell[42695, 1795, 225, 10, 15, "Index",
 CellTags->"alpha"],
Cell[42923, 1807, 245, 10, 15, "Index",
 CellTags->"alpha"],
Cell[43171, 1819, 225, 8, 15, "Index",
 CellTags->"alpha"],
Cell[43399, 1829, 224, 8, 15, "Index",
 CellTags->"alpha"],
Cell[43626, 1839, 228, 8, 15, "Index",
 CellTags->"alpha"],
Cell[43857, 1849, 244, 10, 15, "Index",
 CellTags->"alpha"],
Cell[44104, 1861, 223, 10, 15, "Index",
 CellTags->"alpha"],
Cell[44330, 1873, 210, 10, 15, "Index",
 CellTags->"alpha"],
Cell[44543, 1885, 243, 10, 15, "Index",
 CellTags->"alpha"],
Cell[44789, 1897, 243, 10, 15, "Index",
 CellTags->"alpha"],
Cell[45035, 1909, 226, 10, 15, "Index",
 CellTags->"alpha"],
Cell[45264, 1921, 205, 8, 15, "Index",
 CellTags->"alpha"],
Cell[45472, 1931, 234, 8, 15, "Index",
 CellTags->"alpha"],
Cell[45709, 1941, 214, 8, 15, "Index",
 CellTags->"alpha"],
Cell[45926, 1951, 239, 10, 15, "Index",
 CellTags->"alpha"],
Cell[46168, 1963, 251, 10, 15, "Index",
 CellTags->"alpha"],
Cell[46422, 1975, 235, 10, 15, "Index",
 CellTags->"alpha"],
Cell[46660, 1987, 243, 10, 15, "Index",
 CellTags->"alpha"],
Cell[46906, 1999, 240, 10, 15, "Index",
 CellTags->"alpha"],
Cell[47149, 2011, 239, 10, 15, "Index",
 CellTags->"alpha"],
Cell[47391, 2023, 226, 10, 15, "Index",
 CellTags->"alpha"],
Cell[47620, 2035, 240, 10, 15, "Index",
 CellTags->"alpha"],
Cell[47863, 2047, 241, 10, 15, "Index",
 CellTags->"alpha"],
Cell[48107, 2059, 253, 10, 15, "Index",
 CellTags->"alpha"],
Cell[48363, 2071, 229, 8, 15, "Index",
 CellTags->"alpha"],
Cell[48595, 2081, 213, 8, 15, "Index",
 CellTags->"alpha"],
Cell[48811, 2091, 251, 10, 15, "Index",
 CellTags->"alpha"],
Cell[49065, 2103, 260, 10, 15, "Index",
 CellTags->"alpha"],
Cell[49328, 2115, 220, 8, 15, "Index",
 CellTags->"alpha"],
Cell[49551, 2125, 227, 10, 15, "Index",
 CellTags->"alpha"],
Cell[49781, 2137, 176, 8, 15, "Index",
 CellTags->"alpha"],
Cell[49960, 2147, 226, 8, 15, "Index",
 CellTags->"alpha"],
Cell[50189, 2157, 229, 8, 15, "Index",
 CellTags->"alpha"],
Cell[50421, 2167, 263, 10, 15, "Index",
 CellTags->"alpha"],
Cell[50687, 2179, 215, 8, 15, "Index",
 CellTags->"alpha"],
Cell[50905, 2189, 240, 10, 15, "Index",
 CellTags->"alpha"],
Cell[51148, 2201, 196, 8, 15, "Index",
 CellTags->"alpha"],
Cell[51347, 2211, 248, 10, 15, "Index",
 CellTags->"alpha"],
Cell[51598, 2223, 196, 8, 15, "Index",
 CellTags->"alpha"],
Cell[51797, 2233, 193, 8, 15, "Index",
 CellTags->"alpha"],
Cell[51993, 2243, 228, 8, 15, "Index",
 CellTags->"alpha"],
Cell[52224, 2253, 197, 8, 15, "Index",
 CellTags->"alpha"],
Cell[52424, 2263, 195, 8, 15, "Index",
 CellTags->"alpha"],
Cell[52622, 2273, 244, 10, 15, "Index",
 CellTags->"alpha"],
Cell[52869, 2285, 203, 8, 15, "Index",
 CellTags->"alpha"],
Cell[53075, 2295, 247, 10, 15, "Index",
 CellTags->"alpha"],
Cell[53325, 2307, 230, 10, 15, "Index",
 CellTags->"alpha"],
Cell[53558, 2319, 227, 10, 15, "Index",
 CellTags->"alpha"],
Cell[53788, 2331, 232, 10, 15, "Index",
 CellTags->"alpha"],
Cell[54023, 2343, 229, 10, 15, "Index",
 CellTags->"alpha"],
Cell[54255, 2355, 219, 10, 15, "Index",
 CellTags->"alpha"],
Cell[54477, 2367, 237, 10, 15, "Index",
 CellTags->"alpha"],
Cell[54717, 2379, 232, 10, 15, "Index",
 CellTags->"alpha"],
Cell[54952, 2391, 229, 10, 15, "Index",
 CellTags->"alpha"],
Cell[55184, 2403, 190, 8, 15, "Index",
 CellTags->"alpha"],
Cell[55377, 2413, 211, 8, 15, "Index",
 CellTags->"alpha"],
Cell[55591, 2423, 258, 8, 15, "Index",
 CellTags->"alpha"],
Cell[55852, 2433, 200, 8, 15, "Index",
 CellTags->"alpha"],
Cell[56055, 2443, 205, 8, 15, "Index",
 CellTags->"alpha"],
Cell[56263, 2453, 230, 10, 15, "Index",
 CellTags->"alpha"],
Cell[56496, 2465, 247, 10, 15, "Index",
 CellTags->"alpha"],
Cell[56746, 2477, 227, 10, 15, "Index",
 CellTags->"alpha"],
Cell[56976, 2489, 187, 8, 15, "Index",
 CellTags->"alpha"],
Cell[57166, 2499, 208, 8, 15, "Index",
 CellTags->"alpha"],
Cell[57377, 2509, 177, 8, 15, "Index",
 CellTags->"alpha"],
Cell[57557, 2519, 197, 8, 15, "Index",
 CellTags->"alpha"],
Cell[57757, 2529, 235, 10, 15, "Index",
 CellTags->"alpha"],
Cell[57995, 2541, 233, 10, 15, "Index",
 CellTags->"alpha"],
Cell[58231, 2553, 206, 8, 15, "Index",
 CellTags->"alpha"],
Cell[58440, 2563, 252, 10, 15, "Index",
 CellTags->"alpha"],
Cell[58695, 2575, 204, 8, 15, "Index",
 CellTags->"alpha"],
Cell[58902, 2585, 193, 8, 15, "Index",
 CellTags->"alpha"],
Cell[59098, 2595, 189, 8, 15, "Index",
 CellTags->"alpha"],
Cell[59290, 2605, 287, 10, 29, "Index",
 CellTags->"alpha"],
Cell[59580, 2617, 292, 10, 29, "Index",
 CellTags->"alpha"],
Cell[59875, 2629, 277, 10, 15, "Index",
 CellTags->"alpha"],
Cell[60155, 2641, 238, 10, 15, "Index",
 CellTags->"alpha"],
Cell[60396, 2653, 200, 8, 15, "Index",
 CellTags->"alpha"],
Cell[60599, 2663, 205, 8, 15, "Index",
 CellTags->"alpha"],
Cell[60807, 2673, 202, 8, 15, "Index",
 CellTags->"alpha"],
Cell[61012, 2683, 212, 8, 15, "Index",
 CellTags->"alpha"],
Cell[61227, 2693, 245, 10, 15, "Index",
 CellTags->"alpha"],
Cell[61475, 2705, 228, 10, 15, "Index",
 CellTags->"alpha"],
Cell[61706, 2717, 183, 8, 15, "Index",
 CellTags->"alpha"],
Cell[61892, 2727, 217, 10, 15, "Index",
 CellTags->"alpha"],
Cell[62112, 2739, 226, 10, 15, "Index",
 CellTags->"alpha"],
Cell[62341, 2751, 242, 10, 15, "Index",
 CellTags->"alpha"],
Cell[62586, 2763, 196, 8, 15, "Index",
 CellTags->"alpha"],
Cell[62785, 2773, 227, 10, 15, "Index",
 CellTags->"alpha"],
Cell[63015, 2785, 258, 10, 15, "Index",
 CellTags->"alpha"],
Cell[63276, 2797, 269, 10, 15, "Index",
 CellTags->"alpha"],
Cell[63548, 2809, 209, 8, 15, "Index",
 CellTags->"alpha"],
Cell[63760, 2819, 212, 8, 15, "Index",
 CellTags->"alpha"],
Cell[63975, 2829, 202, 8, 15, "Index",
 CellTags->"alpha"],
Cell[64180, 2839, 198, 8, 15, "Index",
 CellTags->"alpha"],
Cell[64381, 2849, 201, 8, 15, "Index",
 CellTags->"alpha"],
Cell[64585, 2859, 272, 10, 15, "Index",
 CellTags->"alpha"],
Cell[64860, 2871, 237, 10, 15, "Index",
 CellTags->"alpha"],
Cell[65100, 2883, 211, 8, 15, "Index",
 CellTags->"alpha"],
Cell[65314, 2893, 229, 10, 15, "Index",
 CellTags->"alpha"],
Cell[65546, 2905, 230, 10, 15, "Index",
 CellTags->"alpha"],
Cell[65779, 2917, 195, 8, 15, "Index",
 CellTags->"alpha"],
Cell[65977, 2927, 270, 10, 15, "Index",
 CellTags->"alpha"],
Cell[66250, 2939, 252, 10, 15, "Index",
 CellTags->"alpha"],
Cell[66505, 2951, 349, 12, 15, "Index",
 CellTags->"alpha"],
Cell[66857, 2965, 262, 10, 15, "Index",
 CellTags->"alpha"],
Cell[67122, 2977, 223, 10, 15, "Index",
 CellTags->"alpha"],
Cell[67348, 2989, 221, 8, 15, "Index",
 CellTags->"alpha"],
Cell[67572, 2999, 253, 10, 15, "Index",
 CellTags->"alpha"],
Cell[67828, 3011, 223, 10, 15, "Index",
 CellTags->"alpha"],
Cell[68054, 3023, 205, 8, 15, "Index",
 CellTags->"alpha"],
Cell[68262, 3033, 239, 10, 15, "Index",
 CellTags->"alpha"],
Cell[68504, 3045, 206, 8, 15, "Index",
 CellTags->"alpha"],
Cell[68713, 3055, 214, 8, 15, "Index",
 CellTags->"alpha"],
Cell[68930, 3065, 201, 8, 15, "Index",
 CellTags->"alpha"],
Cell[69134, 3075, 251, 10, 15, "Index",
 CellTags->"alpha"],
Cell[69388, 3087, 240, 10, 15, "Index",
 CellTags->"alpha"],
Cell[69631, 3099, 252, 10, 15, "Index",
 CellTags->"alpha"],
Cell[69886, 3111, 235, 10, 15, "Index",
 CellTags->"alpha"],
Cell[70124, 3123, 210, 8, 15, "Index",
 CellTags->"alpha"],
Cell[70337, 3133, 198, 8, 15, "Index",
 CellTags->"alpha"],
Cell[70538, 3143, 214, 8, 15, "Index",
 CellTags->"alpha"],
Cell[70755, 3153, 214, 8, 15, "Index",
 CellTags->"alpha"],
Cell[70972, 3163, 219, 10, 15, "Index",
 CellTags->"alpha"],
Cell[71194, 3175, 251, 10, 15, "Index",
 CellTags->"alpha"],
Cell[71448, 3187, 288, 10, 29, "Index",
 CellTags->"alpha"],
Cell[71739, 3199, 253, 10, 15, "Index",
 CellTags->"alpha"],
Cell[71995, 3211, 238, 10, 15, "Index",
 CellTags->"alpha"],
Cell[72236, 3223, 258, 10, 15, "Index",
 CellTags->"alpha"],
Cell[72497, 3235, 246, 10, 15, "Index",
 CellTags->"alpha"],
Cell[72746, 3247, 215, 10, 15, "Index",
 CellTags->"alpha"],
Cell[72964, 3259, 207, 8, 15, "Index",
 CellTags->"alpha"],
Cell[73174, 3269, 209, 8, 15, "Index",
 CellTags->"alpha"],
Cell[73386, 3279, 256, 10, 15, "Index",
 CellTags->"alpha"],
Cell[73645, 3291, 184, 8, 15, "Index",
 CellTags->"alpha"],
Cell[73832, 3301, 198, 8, 15, "Index",
 CellTags->"alpha"],
Cell[74033, 3311, 203, 8, 15, "Index",
 CellTags->"alpha"],
Cell[74239, 3321, 194, 8, 15, "Index",
 CellTags->"alpha"],
Cell[74436, 3331, 191, 8, 15, "Index",
 CellTags->"alpha"],
Cell[74630, 3341, 242, 8, 15, "Index",
 CellTags->"alpha"],
Cell[74875, 3351, 237, 10, 15, "Index",
 CellTags->"alpha"],
Cell[75115, 3363, 204, 8, 15, "Index",
 CellTags->"alpha"],
Cell[75322, 3373, 272, 10, 15, "Index",
 CellTags->"alpha"],
Cell[75597, 3385, 342, 14, 15, "Index",
 CellTags->"alpha"],
Cell[75942, 3401, 235, 8, 15, "Index",
 CellTags->"alpha"],
Cell[76180, 3411, 236, 8, 15, "Index",
 CellTags->"alpha"],
Cell[76419, 3421, 236, 10, 15, "Index",
 CellTags->"alpha"],
Cell[76658, 3433, 231, 10, 15, "Index",
 CellTags->"alpha"],
Cell[76892, 3445, 266, 10, 15, "Index",
 CellTags->"alpha"],
Cell[77161, 3457, 227, 10, 15, "Index",
 CellTags->"alpha"],
Cell[77391, 3469, 251, 10, 15, "Index",
 CellTags->"alpha"],
Cell[77645, 3481, 269, 10, 15, "Index",
 CellTags->"alpha"],
Cell[77917, 3493, 202, 8, 15, "Index",
 CellTags->"alpha"],
Cell[78122, 3503, 203, 8, 15, "Index",
 CellTags->"alpha"],
Cell[78328, 3513, 226, 10, 15, "Index",
 CellTags->"alpha"],
Cell[78557, 3525, 222, 10, 15, "Index",
 CellTags->"alpha"],
Cell[78782, 3537, 209, 8, 15, "Index",
 CellTags->"alpha"],
Cell[78994, 3547, 248, 10, 15, "Index",
 CellTags->"alpha"],
Cell[79245, 3559, 229, 8, 15, "Index",
 CellTags->"alpha"],
Cell[79477, 3569, 227, 10, 15, "Index",
 CellTags->"alpha"],
Cell[79707, 3581, 225, 10, 15, "Index",
 CellTags->"alpha"],
Cell[79935, 3593, 222, 10, 15, "Index",
 CellTags->"alpha"],
Cell[80160, 3605, 248, 10, 15, "Index",
 CellTags->"alpha"],
Cell[80411, 3617, 229, 8, 15, "Index",
 CellTags->"alpha"],
Cell[80643, 3627, 222, 10, 15, "Index",
 CellTags->"alpha"],
Cell[80868, 3639, 215, 10, 15, "Index",
 CellTags->"alpha"],
Cell[81086, 3651, 226, 10, 15, "Index",
 CellTags->"alpha"],
Cell[81315, 3663, 226, 10, 15, "Index",
 CellTags->"alpha"],
Cell[81544, 3675, 219, 10, 15, "Index",
 CellTags->"alpha"],
Cell[81766, 3687, 227, 10, 15, "Index",
 CellTags->"alpha"],
Cell[81996, 3699, 220, 10, 15, "Index",
 CellTags->"alpha"],
Cell[82219, 3711, 248, 10, 15, "Index",
 CellTags->"alpha"],
Cell[82470, 3723, 202, 8, 15, "Index",
 CellTags->"alpha"],
Cell[82675, 3733, 201, 8, 15, "Index",
 CellTags->"alpha"],
Cell[82879, 3743, 200, 8, 15, "Index",
 CellTags->"alpha"],
Cell[83082, 3753, 204, 8, 15, "Index",
 CellTags->"alpha"],
Cell[83289, 3763, 234, 10, 15, "Index",
 CellTags->"alpha"],
Cell[83526, 3775, 251, 10, 15, "Index",
 CellTags->"alpha"],
Cell[83780, 3787, 253, 10, 15, "Index",
 CellTags->"alpha"],
Cell[84036, 3799, 220, 10, 15, "Index",
 CellTags->"alpha"],
Cell[84259, 3811, 252, 10, 15, "Index",
 CellTags->"alpha"],
Cell[84514, 3823, 226, 10, 15, "Index",
 CellTags->"alpha"],
Cell[84743, 3835, 242, 10, 15, "Index",
 CellTags->"alpha"],
Cell[84988, 3847, 227, 10, 15, "Index",
 CellTags->"alpha"],
Cell[85218, 3859, 243, 10, 15, "Index",
 CellTags->"alpha"],
Cell[85464, 3871, 182, 8, 15, "Index",
 CellTags->"alpha"],
Cell[85649, 3881, 183, 8, 15, "Index",
 CellTags->"alpha"],
Cell[85835, 3891, 183, 8, 15, "Index",
 CellTags->"alpha"],
Cell[86021, 3901, 235, 10, 15, "Index",
 CellTags->"alpha"],
Cell[86259, 3913, 191, 8, 15, "Index",
 CellTags->"alpha"],
Cell[86453, 3923, 230, 8, 15, "Index",
 CellTags->"alpha"],
Cell[86686, 3933, 226, 8, 15, "Index",
 CellTags->"alpha"],
Cell[86915, 3943, 200, 8, 15, "Index",
 CellTags->"alpha"],
Cell[87118, 3953, 243, 10, 15, "Index",
 CellTags->"alpha"],
Cell[87364, 3965, 228, 10, 15, "Index",
 CellTags->"alpha"],
Cell[87595, 3977, 235, 10, 15, "Index",
 CellTags->"alpha"],
Cell[87833, 3989, 232, 10, 15, "Index",
 CellTags->"alpha"],
Cell[88068, 4001, 206, 8, 15, "Index",
 CellTags->"alpha"],
Cell[88277, 4011, 207, 8, 15, "Index",
 CellTags->"alpha"],
Cell[88487, 4021, 242, 10, 15, "Index",
 CellTags->"alpha"],
Cell[88732, 4033, 248, 10, 15, "Index",
 CellTags->"alpha"],
Cell[88983, 4045, 210, 8, 15, "Index",
 CellTags->"alpha"],
Cell[89196, 4055, 242, 10, 15, "Index",
 CellTags->"alpha"],
Cell[89441, 4067, 249, 10, 15, "Index",
 CellTags->"alpha"],
Cell[89693, 4079, 248, 10, 15, "Index",
 CellTags->"alpha"],
Cell[89944, 4091, 250, 10, 15, "Index",
 CellTags->"alpha"],
Cell[90197, 4103, 215, 10, 15, "Index",
 CellTags->"alpha"],
Cell[90415, 4115, 235, 10, 15, "Index",
 CellTags->"alpha"],
Cell[90653, 4127, 232, 8, 15, "Index",
 CellTags->"alpha"],
Cell[90888, 4137, 263, 10, 15, "Index",
 CellTags->"alpha"],
Cell[91154, 4149, 244, 10, 15, "Index",
 CellTags->"alpha"],
Cell[91401, 4161, 196, 8, 15, "Index",
 CellTags->"alpha"],
Cell[91600, 4171, 209, 8, 15, "Index",
 CellTags->"alpha"],
Cell[91812, 4181, 206, 8, 15, "Index",
 CellTags->"alpha"],
Cell[92021, 4191, 225, 8, 15, "Index",
 CellTags->"alpha"],
Cell[92249, 4201, 228, 10, 15, "Index",
 CellTags->"alpha"],
Cell[92480, 4213, 222, 8, 15, "Index",
 CellTags->"alpha"],
Cell[92705, 4223, 219, 8, 15, "Index",
 CellTags->"alpha"],
Cell[92927, 4233, 206, 10, 15, "Index",
 CellTags->"alpha"],
Cell[93136, 4245, 218, 10, 15, "Index",
 CellTags->"alpha"],
Cell[93357, 4257, 242, 10, 15, "Index",
 CellTags->"alpha"],
Cell[93602, 4269, 236, 10, 15, "Index",
 CellTags->"alpha"],
Cell[93841, 4281, 231, 10, 15, "Index",
 CellTags->"alpha"],
Cell[94075, 4293, 220, 8, 15, "Index",
 CellTags->"alpha"],
Cell[94298, 4303, 253, 10, 15, "Index",
 CellTags->"alpha"],
Cell[94554, 4315, 257, 10, 15, "Index",
 CellTags->"alpha"],
Cell[94814, 4327, 237, 10, 15, "Index",
 CellTags->"alpha"],
Cell[95054, 4339, 249, 10, 15, "Index",
 CellTags->"alpha"],
Cell[95306, 4351, 222, 10, 15, "Index",
 CellTags->"alpha"],
Cell[95531, 4363, 237, 10, 15, "Index",
 CellTags->"alpha"],
Cell[95771, 4375, 249, 10, 15, "Index",
 CellTags->"alpha"],
Cell[96023, 4387, 223, 8, 15, "Index",
 CellTags->"alpha"],
Cell[96249, 4397, 264, 10, 15, "Index",
 CellTags->"alpha"],
Cell[96516, 4409, 256, 10, 15, "Index",
 CellTags->"alpha"],
Cell[96775, 4421, 205, 8, 15, "Index",
 CellTags->"alpha"],
Cell[96983, 4431, 201, 8, 15, "Index",
 CellTags->"alpha"],
Cell[97187, 4441, 218, 8, 15, "Index",
 CellTags->"alpha"],
Cell[97408, 4451, 253, 10, 15, "Index",
 CellTags->"alpha"],
Cell[97664, 4463, 242, 10, 15, "Index",
 CellTags->"alpha"],
Cell[97909, 4475, 254, 10, 15, "Index",
 CellTags->"alpha"],
Cell[98166, 4487, 237, 10, 15, "Index",
 CellTags->"alpha"],
Cell[98406, 4499, 246, 10, 15, "Index",
 CellTags->"alpha"],
Cell[98655, 4511, 182, 8, 15, "Index",
 CellTags->"alpha"],
Cell[98840, 4521, 218, 8, 15, "Index",
 CellTags->"alpha"],
Cell[99061, 4531, 213, 8, 15, "Index",
 CellTags->"alpha"],
Cell[99277, 4541, 213, 8, 15, "Index",
 CellTags->"alpha"],
Cell[99493, 4551, 210, 8, 15, "Index",
 CellTags->"alpha"],
Cell[99706, 4561, 240, 10, 15, "Index",
 CellTags->"alpha"],
Cell[99949, 4573, 273, 10, 29, "Index",
 CellTags->"alpha"],
Cell[100225, 4585, 241, 10, 15, "Index",
 CellTags->"alpha"],
Cell[100469, 4597, 270, 10, 29, "Index",
 CellTags->"alpha"],
Cell[100742, 4609, 217, 8, 15, "Index",
 CellTags->"alpha"],
Cell[100962, 4619, 269, 10, 29, "Index",
 CellTags->"alpha"],
Cell[101234, 4631, 212, 10, 15, "Index",
 CellTags->"alpha"],
Cell[101449, 4643, 208, 8, 15, "Index",
 CellTags->"alpha"],
Cell[101660, 4653, 227, 10, 15, "Index",
 CellTags->"alpha"],
Cell[101890, 4665, 192, 8, 15, "Index",
 CellTags->"alpha"],
Cell[102085, 4675, 214, 10, 15, "Index",
 CellTags->"alpha"],
Cell[102302, 4687, 228, 8, 15, "Index",
 CellTags->"alpha"],
Cell[102533, 4697, 255, 10, 15, "Index",
 CellTags->"alpha"],
Cell[102791, 4709, 251, 10, 15, "Index",
 CellTags->"alpha"],
Cell[103045, 4721, 240, 10, 15, "Index",
 CellTags->"alpha"],
Cell[103288, 4733, 255, 10, 15, "Index",
 CellTags->"alpha"],
Cell[103546, 4745, 213, 8, 15, "Index",
 CellTags->"alpha"],
Cell[103762, 4755, 217, 10, 15, "Index",
 CellTags->"alpha"],
Cell[103982, 4767, 204, 8, 15, "Index",
 CellTags->"alpha"],
Cell[104189, 4777, 218, 8, 15, "Index",
 CellTags->"alpha"],
Cell[104410, 4787, 228, 10, 15, "Index",
 CellTags->"alpha"],
Cell[104641, 4799, 241, 10, 15, "Index",
 CellTags->"alpha"],
Cell[104885, 4811, 242, 10, 15, "Index",
 CellTags->"alpha"],
Cell[105130, 4823, 237, 10, 15, "Index",
 CellTags->"alpha"],
Cell[105370, 4835, 229, 10, 15, "Index",
 CellTags->"alpha"],
Cell[105602, 4847, 216, 8, 15, "Index",
 CellTags->"alpha"],
Cell[105821, 4857, 219, 8, 15, "Index",
 CellTags->"alpha"],
Cell[106043, 4867, 219, 10, 15, "Index",
 CellTags->"alpha"],
Cell[106265, 4879, 257, 10, 15, "Index",
 CellTags->"alpha"],
Cell[106525, 4891, 239, 10, 15, "Index",
 CellTags->"alpha"],
Cell[106767, 4903, 220, 8, 15, "Index",
 CellTags->"alpha"],
Cell[106990, 4913, 250, 10, 15, "Index",
 CellTags->"alpha"],
Cell[107243, 4925, 215, 8, 15, "Index",
 CellTags->"alpha"],
Cell[107461, 4935, 216, 8, 15, "Index",
 CellTags->"alpha"],
Cell[107680, 4945, 215, 8, 15, "Index",
 CellTags->"alpha"],
Cell[107898, 4955, 222, 8, 15, "Index",
 CellTags->"alpha"],
Cell[108123, 4965, 258, 10, 15, "Index",
 CellTags->"alpha"],
Cell[108384, 4977, 227, 10, 15, "Index",
 CellTags->"alpha"],
Cell[108614, 4989, 232, 10, 15, "Index",
 CellTags->"alpha"],
Cell[108849, 5001, 243, 10, 15, "Index",
 CellTags->"alpha"],
Cell[109095, 5013, 265, 10, 15, "Index",
 CellTags->"alpha"],
Cell[109363, 5025, 216, 8, 15, "Index",
 CellTags->"alpha"],
Cell[109582, 5035, 208, 8, 15, "Index",
 CellTags->"alpha"],
Cell[109793, 5045, 234, 10, 15, "Index",
 CellTags->"alpha"],
Cell[110030, 5057, 222, 10, 15, "Index",
 CellTags->"alpha"],
Cell[110255, 5069, 215, 8, 15, "Index",
 CellTags->"alpha"],
Cell[110473, 5079, 233, 8, 15, "Index",
 CellTags->"alpha"],
Cell[110709, 5089, 267, 10, 15, "Index",
 CellTags->"alpha"],
Cell[110979, 5101, 210, 8, 15, "Index",
 CellTags->"alpha"],
Cell[111192, 5111, 251, 8, 15, "Index",
 CellTags->"alpha"],
Cell[111446, 5121, 210, 8, 15, "Index",
 CellTags->"alpha"],
Cell[111659, 5131, 215, 8, 15, "Index",
 CellTags->"alpha"],
Cell[111877, 5141, 216, 8, 15, "Index",
 CellTags->"alpha"],
Cell[112096, 5151, 221, 8, 15, "Index",
 CellTags->"alpha"],
Cell[112320, 5161, 223, 8, 15, "Index",
 CellTags->"alpha"],
Cell[112546, 5171, 206, 8, 15, "Index",
 CellTags->"alpha"],
Cell[112755, 5181, 235, 10, 15, "Index",
 CellTags->"alpha"],
Cell[112993, 5193, 241, 8, 15, "Index",
 CellTags->"alpha"],
Cell[113237, 5203, 190, 8, 15, "Index",
 CellTags->"alpha"],
Cell[113430, 5213, 239, 10, 15, "Index",
 CellTags->"alpha"],
Cell[113672, 5225, 207, 8, 15, "Index",
 CellTags->"alpha"],
Cell[113882, 5235, 232, 10, 15, "Index",
 CellTags->"alpha"],
Cell[114117, 5247, 250, 10, 15, "Index",
 CellTags->"alpha"],
Cell[114370, 5259, 186, 8, 15, "Index",
 CellTags->"alpha"],
Cell[114559, 5269, 204, 8, 15, "Index",
 CellTags->"alpha"],
Cell[114766, 5279, 205, 8, 15, "Index",
 CellTags->"alpha"],
Cell[114974, 5289, 201, 8, 15, "Index",
 CellTags->"alpha"],
Cell[115178, 5299, 207, 8, 15, "Index",
 CellTags->"alpha"],
Cell[115388, 5309, 254, 10, 15, "Index",
 CellTags->"alpha"],
Cell[115645, 5321, 203, 8, 15, "Index",
 CellTags->"alpha"],
Cell[115851, 5331, 214, 8, 15, "Index",
 CellTags->"alpha"],
Cell[116068, 5341, 188, 8, 15, "Index",
 CellTags->"alpha"],
Cell[116259, 5351, 298, 10, 29, "Index",
 CellTags->"alpha"],
Cell[116560, 5363, 248, 10, 15, "Index",
 CellTags->"alpha"],
Cell[116811, 5375, 245, 10, 15, "Index",
 CellTags->"alpha"],
Cell[117059, 5387, 204, 8, 15, "Index",
 CellTags->"alpha"],
Cell[117266, 5397, 200, 8, 15, "Index",
 CellTags->"alpha"],
Cell[117469, 5407, 198, 8, 15, "Index",
 CellTags->"alpha"],
Cell[117670, 5417, 200, 8, 15, "Index",
 CellTags->"alpha"],
Cell[117873, 5427, 195, 8, 15, "Index",
 CellTags->"alpha"],
Cell[118071, 5437, 264, 10, 15, "Index",
 CellTags->"alpha"],
Cell[118338, 5449, 217, 10, 15, "Index",
 CellTags->"alpha"],
Cell[118558, 5461, 207, 8, 15, "Index",
 CellTags->"alpha"],
Cell[118768, 5471, 258, 10, 15, "Index",
 CellTags->"alpha"],
Cell[119029, 5483, 276, 10, 29, "Index",
 CellTags->"alpha"],
Cell[119308, 5495, 250, 10, 15, "Index",
 CellTags->"alpha"],
Cell[119561, 5507, 256, 10, 15, "Index",
 CellTags->"alpha"],
Cell[119820, 5519, 240, 10, 15, "Index",
 CellTags->"alpha"],
Cell[120063, 5531, 241, 10, 15, "Index",
 CellTags->"alpha"],
Cell[120307, 5543, 246, 10, 15, "Index",
 CellTags->"alpha"],
Cell[120556, 5555, 240, 10, 15, "Index",
 CellTags->"alpha"],
Cell[120799, 5567, 238, 10, 15, "Index",
 CellTags->"alpha"],
Cell[121040, 5579, 257, 10, 15, "Index",
 CellTags->"alpha"],
Cell[121300, 5591, 241, 10, 15, "Index",
 CellTags->"alpha"],
Cell[121544, 5603, 242, 10, 15, "Index",
 CellTags->"alpha"],
Cell[121789, 5615, 247, 10, 15, "Index",
 CellTags->"alpha"],
Cell[122039, 5627, 241, 10, 15, "Index",
 CellTags->"alpha"],
Cell[122283, 5639, 239, 10, 15, "Index",
 CellTags->"alpha"],
Cell[122525, 5651, 248, 10, 15, "Index",
 CellTags->"alpha"],
Cell[122776, 5663, 236, 10, 15, "Index",
 CellTags->"alpha"],
Cell[123015, 5675, 250, 8, 15, "Index",
 CellTags->"alpha"],
Cell[123268, 5685, 200, 8, 15, "Index",
 CellTags->"alpha"],
Cell[123471, 5695, 257, 10, 15, "Index",
 CellTags->"alpha"],
Cell[123731, 5707, 205, 8, 15, "Index",
 CellTags->"alpha"],
Cell[123939, 5717, 227, 8, 15, "Index",
 CellTags->"alpha"],
Cell[124169, 5727, 256, 10, 15, "Index",
 CellTags->"alpha"],
Cell[124428, 5739, 235, 8, 15, "Index",
 CellTags->"alpha"],
Cell[124666, 5749, 232, 8, 15, "Index",
 CellTags->"alpha"],
Cell[124901, 5759, 249, 10, 15, "Index",
 CellTags->"alpha"],
Cell[125153, 5771, 237, 10, 15, "Index",
 CellTags->"alpha"],
Cell[125393, 5783, 258, 10, 15, "Index",
 CellTags->"alpha"],
Cell[125654, 5795, 214, 8, 15, "Index",
 CellTags->"alpha"],
Cell[125871, 5805, 266, 10, 15, "Index",
 CellTags->"alpha"],
Cell[126140, 5817, 264, 10, 15, "Index",
 CellTags->"alpha"],
Cell[126407, 5829, 224, 10, 15, "Index",
 CellTags->"alpha"],
Cell[126634, 5841, 241, 10, 15, "Index",
 CellTags->"alpha"],
Cell[126878, 5853, 254, 10, 15, "Index",
 CellTags->"alpha"],
Cell[127135, 5865, 227, 10, 15, "Index",
 CellTags->"alpha"],
Cell[127365, 5877, 220, 10, 15, "Index",
 CellTags->"alpha"],
Cell[127588, 5889, 228, 10, 15, "Index",
 CellTags->"alpha"],
Cell[127819, 5901, 221, 10, 15, "Index",
 CellTags->"alpha"],
Cell[128043, 5913, 249, 10, 15, "Index",
 CellTags->"alpha"],
Cell[128295, 5925, 203, 8, 15, "Index",
 CellTags->"alpha"],
Cell[128501, 5935, 202, 8, 15, "Index",
 CellTags->"alpha"],
Cell[128706, 5945, 201, 8, 15, "Index",
 CellTags->"alpha"],
Cell[128910, 5955, 205, 8, 15, "Index",
 CellTags->"alpha"],
Cell[129118, 5965, 410, 14, 30, "Index",
 CellTags->"alpha"],
Cell[129531, 5981, 254, 10, 15, "Index",
 CellTags->"alpha"],
Cell[129788, 5993, 268, 10, 15, "Index",
 CellTags->"alpha"],
Cell[130059, 6005, 252, 10, 15, "Index",
 CellTags->"alpha"],
Cell[130314, 6017, 183, 8, 15, "Index",
 CellTags->"alpha"],
Cell[130500, 6027, 271, 10, 15, "Index",
 CellTags->"alpha"],
Cell[130774, 6039, 233, 10, 15, "Index",
 CellTags->"alpha"],
Cell[131010, 6051, 209, 8, 15, "Index",
 CellTags->"alpha"],
Cell[131222, 6061, 226, 10, 15, "Index",
 CellTags->"alpha"],
Cell[131451, 6073, 180, 8, 15, "Index",
 CellTags->"alpha"],
Cell[131634, 6083, 269, 10, 15, "Index",
 CellTags->"alpha"],
Cell[131906, 6095, 248, 10, 15, "Index",
 CellTags->"alpha"],
Cell[132157, 6107, 259, 10, 15, "Index",
 CellTags->"alpha"],
Cell[132419, 6119, 249, 10, 15, "Index",
 CellTags->"alpha"],
Cell[132671, 6131, 237, 10, 15, "Index",
 CellTags->"alpha"],
Cell[132911, 6143, 258, 10, 15, "Index",
 CellTags->"alpha"],
Cell[133172, 6155, 249, 10, 15, "Index",
 CellTags->"alpha"],
Cell[133424, 6167, 229, 8, 15, "Index",
 CellTags->"alpha"],
Cell[133656, 6177, 199, 8, 15, "Index",
 CellTags->"alpha"],
Cell[133858, 6187, 253, 10, 15, "Index",
 CellTags->"alpha"],
Cell[134114, 6199, 252, 10, 15, "Index",
 CellTags->"alpha"],
Cell[134369, 6211, 259, 10, 15, "Index",
 CellTags->"alpha"],
Cell[134631, 6223, 247, 10, 15, "Index",
 CellTags->"alpha"],
Cell[134881, 6235, 265, 10, 15, "Index",
 CellTags->"alpha"],
Cell[135149, 6247, 249, 10, 15, "Index",
 CellTags->"alpha"],
Cell[135401, 6259, 262, 10, 15, "Index",
 CellTags->"alpha"],
Cell[135666, 6271, 199, 8, 15, "Index",
 CellTags->"alpha"],
Cell[135868, 6281, 235, 10, 15, "Index",
 CellTags->"alpha"],
Cell[136106, 6293, 194, 8, 15, "Index",
 CellTags->"alpha"],
Cell[136303, 6303, 232, 10, 15, "Index",
 CellTags->"alpha"],
Cell[136538, 6315, 217, 10, 15, "Index",
 CellTags->"alpha"],
Cell[136758, 6327, 207, 8, 15, "Index",
 CellTags->"alpha"],
Cell[136968, 6337, 247, 8, 15, "Index",
 CellTags->"alpha"],
Cell[137218, 6347, 207, 8, 15, "Index",
 CellTags->"alpha"],
Cell[137428, 6357, 240, 8, 15, "Index",
 CellTags->"alpha"],
Cell[137671, 6367, 227, 10, 15, "Index",
 CellTags->"alpha"],
Cell[137901, 6379, 228, 10, 15, "Index",
 CellTags->"alpha"],
Cell[138132, 6391, 232, 10, 15, "Index",
 CellTags->"alpha"],
Cell[138367, 6403, 212, 8, 15, "Index",
 CellTags->"alpha"],
Cell[138582, 6413, 233, 10, 15, "Index",
 CellTags->"alpha"],
Cell[138818, 6425, 239, 10, 15, "Index",
 CellTags->"alpha"],
Cell[139060, 6437, 254, 10, 15, "Index",
 CellTags->"alpha"],
Cell[139317, 6449, 243, 10, 15, "Index",
 CellTags->"alpha"],
Cell[139563, 6461, 229, 8, 15, "Index",
 CellTags->"alpha"],
Cell[139795, 6471, 217, 10, 15, "Index",
 CellTags->"alpha"],
Cell[140015, 6483, 226, 10, 15, "Index",
 CellTags->"alpha"],
Cell[140244, 6495, 242, 10, 15, "Index",
 CellTags->"alpha"],
Cell[140489, 6507, 196, 8, 15, "Index",
 CellTags->"alpha"],
Cell[140688, 6517, 256, 10, 15, "Index",
 CellTags->"alpha"],
Cell[140947, 6529, 212, 10, 15, "Index",
 CellTags->"alpha"],
Cell[141162, 6541, 211, 8, 15, "Index",
 CellTags->"alpha"],
Cell[141376, 6551, 200, 8, 15, "Index",
 CellTags->"alpha"],
Cell[141579, 6561, 205, 8, 15, "Index",
 CellTags->"alpha"],
Cell[141787, 6571, 209, 8, 15, "Index",
 CellTags->"alpha"],
Cell[141999, 6581, 214, 10, 15, "Index",
 CellTags->"alpha"],
Cell[142216, 6593, 253, 10, 15, "Index",
 CellTags->"alpha"],
Cell[142472, 6605, 227, 10, 15, "Index",
 CellTags->"alpha"],
Cell[142702, 6617, 260, 10, 15, "Index",
 CellTags->"alpha"],
Cell[142965, 6629, 273, 10, 15, "Index",
 CellTags->{"StyleBox[Indeterminate, MR]", "alpha"}],
Cell[143241, 6641, 187, 8, 15, "Index",
 CellTags->"alpha"],
Cell[143431, 6651, 215, 8, 15, "Index",
 CellTags->"alpha"],
Cell[143649, 6661, 190, 8, 15, "Index",
 CellTags->"alpha"],
Cell[143842, 6671, 214, 10, 15, "Index",
 CellTags->"alpha"],
Cell[144059, 6683, 193, 8, 15, "Index",
 CellTags->"alpha"],
Cell[144255, 6693, 185, 8, 15, "Index",
 CellTags->"alpha"],
Cell[144443, 6703, 183, 8, 15, "Index",
 CellTags->"alpha"],
Cell[144629, 6713, 188, 8, 15, "Index",
 CellTags->"alpha"],
Cell[144820, 6723, 181, 8, 15, "Index",
 CellTags->"alpha"],
Cell[145004, 6733, 211, 10, 15, "Index",
 CellTags->"alpha"],
Cell[145218, 6745, 205, 10, 15, "Index",
 CellTags->"alpha"],
Cell[145426, 6757, 182, 8, 15, "Index",
 CellTags->"alpha"],
Cell[145611, 6767, 186, 8, 15, "Index",
 CellTags->"alpha"],
Cell[145800, 6777, 200, 8, 15, "Index",
 CellTags->"alpha"],
Cell[146003, 6787, 200, 8, 15, "Index",
 CellTags->"alpha"],
Cell[146206, 6797, 198, 8, 15, "Index",
 CellTags->"alpha"],
Cell[146407, 6807, 257, 10, 15, "Index",
 CellTags->"alpha"],
Cell[146667, 6819, 230, 8, 15, "Index",
 CellTags->"alpha"],
Cell[146900, 6829, 248, 10, 15, "Index",
 CellTags->"alpha"],
Cell[147151, 6841, 243, 10, 15, "Index",
 CellTags->"alpha"],
Cell[147397, 6853, 194, 8, 15, "Index",
 CellTags->"alpha"],
Cell[147594, 6863, 191, 8, 15, "Index",
 CellTags->"alpha"],
Cell[147788, 6873, 229, 10, 15, "Index",
 CellTags->"alpha"],
Cell[148020, 6885, 226, 10, 15, "Index",
 CellTags->"alpha"],
Cell[148249, 6897, 209, 8, 15, "Index",
 CellTags->"alpha"],
Cell[148461, 6907, 175, 8, 15, "Index",
 CellTags->"alpha"],
Cell[148639, 6917, 248, 10, 15, "Index",
 CellTags->"alpha"],
Cell[148890, 6929, 240, 10, 15, "Index",
 CellTags->"alpha"],
Cell[149133, 6941, 221, 8, 15, "Index",
 CellTags->"alpha"],
Cell[149357, 6951, 217, 8, 15, "Index",
 CellTags->"alpha"],
Cell[149577, 6961, 237, 10, 15, "Index",
 CellTags->"alpha"],
Cell[149817, 6973, 249, 10, 15, "Index",
 CellTags->"alpha"],
Cell[150069, 6985, 257, 10, 15, "Index",
 CellTags->"alpha"],
Cell[150329, 6997, 229, 8, 15, "Index",
 CellTags->"alpha"],
Cell[150561, 7007, 227, 8, 15, "Index",
 CellTags->"alpha"],
Cell[150791, 7017, 216, 10, 15, "Index",
 CellTags->"alpha"],
Cell[151010, 7029, 224, 10, 15, "Index",
 CellTags->"alpha"],
Cell[151237, 7041, 271, 10, 15, "Index",
 CellTags->"alpha"],
Cell[151511, 7053, 268, 10, 15, "Index",
 CellTags->"alpha"],
Cell[151782, 7065, 272, 10, 15, "Index",
 CellTags->"alpha"],
Cell[152057, 7077, 202, 8, 15, "Index",
 CellTags->"alpha"],
Cell[152262, 7087, 245, 10, 15, "Index",
 CellTags->"alpha"],
Cell[152510, 7099, 248, 10, 15, "Index",
 CellTags->"alpha"],
Cell[152761, 7111, 237, 10, 15, "Index",
 CellTags->"alpha"],
Cell[153001, 7123, 210, 8, 15, "Index",
 CellTags->"alpha"],
Cell[153214, 7133, 248, 10, 15, "Index",
 CellTags->"alpha"],
Cell[153465, 7145, 249, 10, 15, "Index",
 CellTags->"alpha"],
Cell[153717, 7157, 234, 10, 15, "Index",
 CellTags->"alpha"],
Cell[153954, 7169, 238, 10, 15, "Index",
 CellTags->"alpha"],
Cell[154195, 7181, 226, 10, 15, "Index",
 CellTags->"alpha"],
Cell[154424, 7193, 242, 10, 15, "Index",
 CellTags->"alpha"],
Cell[154669, 7205, 227, 10, 15, "Index",
 CellTags->"alpha"],
Cell[154899, 7217, 243, 10, 15, "Index",
 CellTags->"alpha"],
Cell[155145, 7229, 264, 10, 15, "Index",
 CellTags->"alpha"],
Cell[155412, 7241, 220, 8, 15, "Index",
 CellTags->"alpha"],
Cell[155635, 7251, 264, 10, 15, "Index",
 CellTags->"alpha"],
Cell[155902, 7263, 228, 10, 15, "Index",
 CellTags->"alpha"],
Cell[156133, 7275, 229, 10, 15, "Index",
 CellTags->"alpha"],
Cell[156365, 7287, 214, 8, 15, "Index",
 CellTags->"alpha"],
Cell[156582, 7297, 225, 8, 15, "Index",
 CellTags->"alpha"],
Cell[156810, 7307, 228, 10, 15, "Index",
 CellTags->"alpha"],
Cell[157041, 7319, 230, 10, 15, "Index",
 CellTags->"alpha"],
Cell[157274, 7331, 227, 10, 15, "Index",
 CellTags->"alpha"],
Cell[157504, 7343, 217, 10, 15, "Index",
 CellTags->"alpha"],
Cell[157724, 7355, 269, 10, 15, "Index",
 CellTags->"alpha"],
Cell[157996, 7367, 253, 10, 15, "Index",
 CellTags->"alpha"],
Cell[158252, 7379, 242, 10, 15, "Index",
 CellTags->"alpha"],
Cell[158497, 7391, 254, 10, 15, "Index",
 CellTags->"alpha"],
Cell[158754, 7403, 249, 10, 15, "Index",
 CellTags->"alpha"],
Cell[159006, 7415, 248, 10, 15, "Index",
 CellTags->"alpha"],
Cell[159257, 7427, 204, 8, 15, "Index",
 CellTags->"alpha"],
Cell[159464, 7437, 198, 8, 15, "Index",
 CellTags->"alpha"],
Cell[159665, 7447, 202, 8, 15, "Index",
 CellTags->"alpha"],
Cell[159870, 7457, 199, 8, 15, "Index",
 CellTags->"alpha"],
Cell[160072, 7467, 189, 8, 15, "Index",
 CellTags->"alpha"],
Cell[160264, 7477, 189, 8, 15, "Index",
 CellTags->"alpha"],
Cell[160456, 7487, 205, 8, 15, "Index",
 CellTags->"alpha"],
Cell[160664, 7497, 205, 8, 15, "Index",
 CellTags->"alpha"],
Cell[160872, 7507, 214, 8, 15, "Index",
 CellTags->"alpha"],
Cell[161089, 7517, 214, 8, 15, "Index",
 CellTags->"alpha"],
Cell[161306, 7527, 194, 8, 15, "Index",
 CellTags->"alpha"],
Cell[161503, 7537, 198, 8, 15, "Index",
 CellTags->"alpha"],
Cell[161704, 7547, 247, 10, 15, "Index",
 CellTags->"alpha"],
Cell[161954, 7559, 236, 10, 15, "Index",
 CellTags->"alpha"],
Cell[162193, 7571, 248, 10, 15, "Index",
 CellTags->"alpha"],
Cell[162444, 7583, 217, 8, 15, "Index",
 CellTags->"alpha"],
Cell[162664, 7593, 255, 10, 15, "Index",
 CellTags->"alpha"],
Cell[162922, 7605, 244, 10, 15, "Index",
 CellTags->"alpha"],
Cell[163169, 7617, 217, 8, 15, "Index",
 CellTags->"alpha"],
Cell[163389, 7627, 221, 10, 15, "Index",
 CellTags->"alpha"],
Cell[163613, 7639, 245, 10, 15, "Index",
 CellTags->"alpha"],
Cell[163861, 7651, 261, 10, 15, "Index",
 CellTags->"alpha"],
Cell[164125, 7663, 265, 10, 15, "Index",
 CellTags->"alpha"],
Cell[164393, 7675, 230, 10, 15, "Index",
 CellTags->"alpha"],
Cell[164626, 7687, 248, 8, 15, "Index",
 CellTags->{"Z[n, I]", "alpha"}],
Cell[164877, 7697, 248, 8, 15, "Index",
 CellTags->{"Z[n, k]", "alpha"}],
Cell[165128, 7707, 368, 14, 29, "Index",
 CellTags->"alpha"],
Cell[165499, 7723, 264, 10, 15, "Index",
 CellTags->"alpha"],
Cell[165766, 7735, 216, 10, 15, "Index",
 CellTags->"alpha"],
Cell[165985, 7747, 251, 10, 15, "Index",
 CellTags->"alpha"],
Cell[166239, 7759, 265, 10, 15, "Index",
 CellTags->"alpha"]
}, Open  ]],
Cell[CellGroupData[{
Cell[166541, 7774, 104, 2, 36, "Subsection",
 CellTags->{"pack", "i:5"}],
Cell[166648, 7778, 718, 16, 67, "Text",
 CellTags->{
  "pack", "Core", "FiniteFields", "Groupoids", "GroupProperties", "Joint", 
   "LabCode", "Morphisms", "RingExtensions", "Ringoids", "RingProperties", 
   "Zd"}],
Cell[CellGroupData[{
Cell[167391, 7798, 73, 1, 34, "Subsubsection",
 CellTags->{"Core", "i:7", "pack"}],
Cell[167467, 7801, 1819, 29, 386, "Text",
 InitializationCell->False,
 CellTags->{"Core", "pack"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[169323, 7835, 89, 1, 34, "Subsubsection",
 CellTags->{"FiniteFields", "i:8", "pack"}],
Cell[169415, 7838, 347, 8, 64, "Text",
 InitializationCell->False,
 CellTags->{"FiniteFields", "pack"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[169799, 7851, 83, 1, 34, "Subsubsection",
 CellTags->{"Groupoids", "i:9", "pack"}],
Cell[169885, 7854, 483, 10, 92, "Text",
 InitializationCell->False,
 CellTags->{"Groupoids", "pack"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[170405, 7869, 96, 1, 34, "Subsubsection",
 CellTags->{"GroupProperties", "i:10", "pack"}],
Cell[170504, 7872, 501, 10, 92, "Text",
 InitializationCell->False,
 CellTags->{"GroupProperties", "pack"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[171042, 7887, 76, 1, 34, "Subsubsection",
 CellTags->{"Joint", "i:11", "pack"}],
Cell[171121, 7890, 438, 9, 78, "Text",
 InitializationCell->False,
 CellTags->{"Joint", "pack"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[171596, 7904, 80, 1, 34, "Subsubsection",
 CellTags->{"LabCode", "i:12", "pack"}],
Cell[171679, 7907, 264, 7, 50, "Text",
 InitializationCell->False,
 CellTags->{"LabCode", "pack"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[171980, 7919, 82, 1, 34, "Subsubsection",
 CellTags->{"Matrices", "i:13", "pack"}],
Cell[172065, 7922, 664, 12, 134, "Text",
 InitializationCell->False,
 CellTags->{"Matrices", "pack"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[172766, 7939, 84, 1, 34, "Subsubsection",
 CellTags->{"Morphisms", "i:14", "pack"}],
Cell[172853, 7942, 736, 14, 148, "Text",
 InitializationCell->False,
 CellTags->{"Morphisms", "pack"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[173626, 7961, 90, 1, 34, "Subsubsection",
 CellTags->{"Permutations", "i:15", "pack"}],
Cell[173719, 7964, 676, 13, 134, "Text",
 InitializationCell->False,
 CellTags->{"Permutations", "pack"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[174432, 7982, 95, 1, 34, "Subsubsection",
 CellTags->{"RingExtensions", "i:16", "pack"}],
Cell[174530, 7985, 523, 11, 92, "Text",
 InitializationCell->False,
 CellTags->{"RingExtensions", "pack"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[175090, 8001, 83, 1, 34, "Subsubsection",
 CellTags->{"Ringoids", "i:17", "pack"}],
Cell[175176, 8004, 188, 4, 22, "Text",
 InitializationCell->False,
 CellTags->{"Ringoids", "pack"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[175401, 8013, 95, 1, 34, "Subsubsection",
 CellTags->{"RingProperties", "i:18", "pack"}],
Cell[175499, 8016, 1033, 17, 188, "Text",
 InitializationCell->False,
 CellTags->{"RingProperties", "pack"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[176569, 8038, 71, 1, 34, "Subsubsection",
 CellTags->{"Zd", "i:19", "pack"}],
Cell[176643, 8041, 429, 9, 83, "Text",
 InitializationCell->False,
 CellTags->{"Zd", "pack"}]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[177121, 8056, 184, 8, 64, "Subsection",
 CellTags->{"ext", "i:20"}],
Cell[177308, 8066, 388, 7, 83, "Text",
 CellTags->"ext"]
}, Open  ]],
Cell[CellGroupData[{
Cell[177733, 8078, 116, 2, 64, "Subsection",
 CellTags->{"usagealpha", "i:22"}],
Cell[177852, 8082, 126532, 2404, 13400, "Input",
 CellTags->"usagealpha"]
}, Open  ]],
Cell[CellGroupData[{
Cell[304421, 10491, 116, 2, 64, "Subsection",
 CellTags->{"usagepackages", "i:23"}],
Cell[CellGroupData[{
Cell[304562, 10497, 80, 1, 56, "Subsubsection",
 CellTags->{"CoreUsage", "usagepackages"}],
Cell[304645, 10500, 40973, 743, 3494, "Input",
 InitializationCell->True,
 CellTags->{"CoreUsage", "usagepackages"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[345655, 11248, 96, 1, 56, "Subsubsection",
 CellTags->{"FiniteFieldsUsage", "usagepackages"}],
Cell[345754, 11251, 3032, 57, 296, "Input",
 InitializationCell->True,
 CellTags->{"FiniteFieldsUsage", "usagepackages"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[348823, 11313, 90, 1, 56, "Subsubsection",
 CellTags->{"GroupoidsUsage", "usagepackages"}],
Cell[348916, 11316, 6745, 133, 868, "Input",
 InitializationCell->True,
 CellTags->{"GroupoidsUsage", "usagepackages"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[355698, 11454, 102, 1, 56, "Subsubsection",
 CellTags->{"GroupPropertiesUsage", "usagepackages"}],
Cell[355803, 11457, 3891, 89, 660, "Input",
 InitializationCell->True,
 CellTags->{"GroupPropertiesUsage", "usagepackages"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[359731, 11551, 82, 1, 56, "Subsubsection",
 CellTags->{"JointUsage", "usagepackages"}],
Cell[359816, 11554, 6286, 117, 634, "Input",
 InitializationCell->True,
 CellTags->{"JointUsage", "usagepackages"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[366139, 11676, 86, 1, 56, "Subsubsection",
 CellTags->{"LabCodeUsage", "usagepackages"}],
Cell[366228, 11679, 5379, 117, 894, "Input",
 InitializationCell->True,
 CellTags->{"LabCodeUsage", "usagepackages"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[371644, 11801, 88, 1, 56, "Subsubsection",
 CellTags->{"MatricesUsage", "usagepackages"}],
Cell[371735, 11804, 9316, 189, 1206, "Input",
 InitializationCell->True,
 CellTags->{"MatricesUsage", "usagepackages"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[381088, 11998, 90, 1, 56, "Subsubsection",
 CellTags->{"MorphismsUsage", "usagepackages"}],
Cell[381181, 12001, 10422, 197, 1154, "Input",
 InitializationCell->True,
 CellTags->{"MorphismsUsage", "usagepackages"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[391640, 12203, 96, 1, 56, "Subsubsection",
 CellTags->{"PermutationsUsage", "usagepackages"}],
Cell[391739, 12206, 11017, 204, 1050, "Input",
 InitializationCell->True,
 CellTags->{"PermutationsUsage", "usagepackages"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[402793, 12415, 101, 1, 56, "Subsubsection",
 CellTags->{"RingExtensionsUsage", "usagepackages"}],
Cell[402897, 12418, 13401, 236, 1024, "Input",
 InitializationCell->True,
 CellTags->{"RingExtensionsUsage", "usagepackages"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[416335, 12659, 89, 1, 56, "Subsubsection",
 CellTags->{"RingoidsUsage", "usagepackages"}],
Cell[416427, 12662, 1146, 22, 114, "Input",
 InitializationCell->True,
 CellTags->{"RingoidsUsage", "usagepackages"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[417610, 12689, 101, 1, 56, "Subsubsection",
 CellTags->{"RingPropertiesUsage", "usagepackages"}],
Cell[417714, 12692, 12327, 256, 1648, "Input",
 InitializationCell->True,
 CellTags->{"RingPropertiesUsage", "usagepackages"}]
}, Open  ]],
Cell[CellGroupData[{
Cell[430078, 12953, 77, 1, 56, "Subsubsection",
 CellTags->{"ZdUsage", "usagepackages"}],
Cell[430158, 12956, 5538, 107, 582, "Input",
 InitializationCell->True,
 CellTags->{"ZdUsage", "usagepackages"}]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[435745, 13069, 92, 2, 64, "Subsection",
 CellTags->"errormessages"],
Cell[435840, 13073, 14111, 358, 3156, "Input",
 CellTags->"errormessages"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[450000, 13437, 107, 3, 76, "Section",
 CellTags->{"Lab0", "i:21"}],
Cell[450110, 13442, 1032, 31, 113, "Text",
 CellTags->"Lab0"]
}, Open  ]]
}, Open  ]]
}
]
*)

(* End of internal cache information *)

